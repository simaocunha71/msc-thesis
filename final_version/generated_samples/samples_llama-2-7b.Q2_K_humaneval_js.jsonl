{"task_id": "JavaScript/0", "generation": "  const numberSet = new\u040b\u043c\u0402\u0403\u040e\u0420\u045c\u0405\u040e (numbers); // create set from numbers (remove duplicates)\n  if (!numberSet.size) return false; // exit early if no numbers to check\n  const distanceMatrix = numberSet.map((v, i) => [ v, Math.abs(i - numberSet.first()) ]); // convert each num into matrix where row is num and column is index of num relative to the first one in set\n  let currentIndex = numberSet.first(); // index for first num from list\n  const currentNum = distanceMatrix[currentIndex][0];\n  const currentDistance = distanceMatrix[currentIndex][1];\n  let closestIndex; // index of num which is closer than threshold from current one\n  if (currentDistance > threshold) { // if thresh has not been met yet\n    for (let i = 1; i <= numberSet.size(); ++i) { // iterate over array, and only between first index and last\n      let prevIndex = null;\n      while (prevIndex && (distanceMatrix[currentIndex][2] > threshold)) { // while prev index is closer than thresh to curent index\n        prevIndex = distanceMatrix.indexOf(prevIndex);\n      }\n      const numsDistance = Math.abs((i - numberSet.first()) - currentNum) + 1; // distance between i and current num (1 because it's not the same num)\n      if (!closestIndex || numsDistance < closestIndex && numsDistance != prevIndex && numsDistance > threshold) { // set new one as index of closest to curent that is closer than thresh from prev index\n        closestIndex = i;\n      } else if (numsDistance == prevIndex) { // update distance if\n"}
{"task_id": "JavaScript/1", "generation": "  const res = [];\n  let i;\n  while((i = paren_string.indexOf('(')) != -1){ //find the index of any open parentheses in the string and add it to the result list\n    if(paren_string[i] == ')'){//if we found an open parenthesis at that location, then keep going until we find a close parenthesis\n      while((i = paren_string.indexOf(')', i+1)) != -1){ //find the index of any close parentheses in this section\n        if(paren_string[i] == ')' && (i+1) == paren_string.length-1){ //if we find a close parenthesis and it is right next to an open parenthesis then add them both to the result list\n          res.push('(' + paren_string.slice(0, i) + ')' )// if so, push those two parentheses together into the result list\n        }else if((i+1) == paren_string.length-1){ //if we find a close parenthesis in this section that is right next to an open parenthesis then add those both to our final result\n          res.push('(' + paren_string.slice(0, i+1))//push those two parentheses together into the result list and done with this part of checking for nested parentheses\n        }else{ //if we find a close parenthesis in this section and it isn't right next to an open parenthesis then go ahead and push it into our results\n          res.push('(' + paren_string.slice(0, i) + ')' )//and done with checking for nested parentheses\n        }\n      }\n    }else{ //if we found an\n"}
{"task_id": "JavaScript/2", "generation": "  const sign = Math.signbit(number); // -1 is positive or zero, +1 is negative\n  const intPart = Math.abs(number), // integer part in absolute value\n    decimals = Math.round((intPart * 100) / 100); // the remainder as a decimal; if\n                                            // it's positive, then it's a fraction of\n                                            // a larger integer\n  return sign > 0 ? (decimals < 2 && intPart === decimals ? -1 : decimals) : (intPart === -1 ? -1 : intPart);\n};\nexport default truncateNumber;\n"}
