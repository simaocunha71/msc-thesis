{"task_id": "Go/0", "prompt": "import (\n    \"math\"\n)\n\n// Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n// >>> HasCloseElements([]float64{1.0, 2.0, 3.0}, 0.5)\n// false\n// >>> HasCloseElements([]float64{1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\n// true\nfunc HasCloseElements(numbers []float64, threshold float64) bool {\n", "import": "import (\n    \"math\"\n)\n", "docstring": "// Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n// >>> HasCloseElements([]float64{1.0, 2.0, 3.0}, 0.5)\n// false\n// >>> HasCloseElements([]float64{1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\n// true\n", "declaration": "\nfunc HasCloseElements(numbers []float64, threshold float64) bool {\n", "canonical_solution": "    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            var distance float64 = math.Abs(numbers[i] - numbers[j])\n            if distance < threshold {\n                return true\n            }\n        }\n    }\n    return false\n}\n\n", "test": "func TestHasCloseElements(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, HasCloseElements([]float64{11.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.3))\n    assert.Equal(false, HasCloseElements([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.05))\n    assert.Equal(true, HasCloseElements([]float64{1.0, 2.0, 5.9, 4.0, 5.0}, 0.95))\n    assert.Equal(false, HasCloseElements([]float64{1.0, 2.0, 5.9, 4.0, 5.0}, 0.8))\n    assert.Equal(true, HasCloseElements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}, 0.1))\n    assert.Equal(true, HasCloseElements([]float64{1.1, 2.2, 3.1, 4.1, 5.1}, 1.0))\n    assert.Equal(false, HasCloseElements([]float64{1.1, 2.2, 3.1, 4.1, 5.1}, 0.5))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestHasCloseElements(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(false, HasCloseElements([]float64{1.0, 2.0, 3.0}, 0.5))\n    assert.Equal(true, HasCloseElements([]float64{1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3))\n}\n", "prompt_text": "Check if in given list of numbers, are any two numbers closer to each other than given threshold.", "prompt_explain": "Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n>>> HasCloseElements([]float64{1.0, 2.0, 3.0}, 0.5)\nfalse\n>>> HasCloseElements([]float64{1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\ntrue\n", "func_title": "func HasCloseElements(numbers []float64, threshold float64) bool ", "prompt_text_chinese": "检查在给定的数字列表中，是否有任何两个数字比给定的阈值更接近。"}
{"task_id": "Go/1", "prompt": "\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> SeparateParenGroups('( ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nfunc SeparateParenGroups(paren_string string) []string {\n", "import": "", "docstring": "// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> SeparateParenGroups('( ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\n", "declaration": "\nfunc SeparateParenGroups(paren_string string) []string {\n", "canonical_solution": "    result := make([]string, 0)\n    current_string := make([]rune, 0)\n    current_depth := 0\n\n    for _, c := range paren_string {\n        if c == '(' {\n            current_depth += 1\n            current_string = append(current_string, c)\n        }else if c== ')'{\n            current_depth -= 1\n            current_string = append(current_string, c)\n\n            if current_depth == 0{\n                result = append(result, string(current_string))\n                current_string =  make([]rune, 0)\n            }\n        }\n\n    }\n    return result\n}\n\n", "test": "func TestSeparateParenGroups(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]string{\"(()())\", \"((()))\", \"()\", \"((())()())\"}, SeparateParenGroups(\"(()()) ((())) () ((())()())\"))\n    assert.Equal([]string{\"()\", \"(())\", \"((()))\", \"(((())))\"}, SeparateParenGroups(\"() (()) ((())) (((())))\"))\n    assert.Equal([]string{\"(()(())((())))\"}, SeparateParenGroups(\"(()(())((())))\"))\n    assert.Equal([]string{\"()\", \"(())\", \"(()())\"}, SeparateParenGroups(\"( ) (( )) (( )( ))\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSeparateParenGroups(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]string{\"()\", \"(())\", \"(()())\"}, SeparateParenGroups(\"( ) (( )) (( )( ))\"))\n}\n", "prompt_text": "Input to this function is a string containing multiple groups of nested parentheses. Your goal is to separate those group into separate strings and return the list of those. Separate groups are balanced (each open brace is properly closed) and not nested within each other Ignore any spaces in the input string.", "prompt_explain": "Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\nseparate those group into separate strings and return the list of those.\nSeparate groups are balanced (each open brace is properly closed) and not nested within each other\nIgnore any spaces in the input string.\n>>> SeparateParenGroups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']\n", "func_title": "func SeparateParenGroups(paren_string string) []string ", "prompt_text_chinese": "这个函数的输入是一个包含多组嵌套括号的字符串。您的目标是将这些组分离为单独的字符串，并返回这些字符串的列表。独立的组是平衡的(每个开大括号都是正确关闭的)，并且彼此之间不嵌套。"}
{"task_id": "Go/2", "prompt": "import (\n    \"math\"\n)\n\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// \n// Return the decimal part of the number.\n// >>> TruncateNumber(3.5)\n// 0.5\nfunc TruncateNumber(number float64) float64 {\n", "import": "import (\n    \"math\"\n)\n", "docstring": "// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// \n// Return the decimal part of the number.\n// >>> TruncateNumber(3.5)\n// 0.5\n", "declaration": "\nfunc TruncateNumber(number float64) float64 {\n", "canonical_solution": "    return math.Mod(number,1)\n}\n\n", "test": "func TestTruncateNumber(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(0.5, TruncateNumber(3.5))\n    assert.Equal(true, math.Abs(TruncateNumber(1.33)-0.33) < 1e-6)\n    assert.Equal(true, math.Abs(TruncateNumber(123.456)-0.456) < 1e-6)\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestTruncateNumber(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(0.5, TruncateNumber(3.5))\n}\n", "prompt_text": "Given a positive floating point number, it can be decomposed into and integer part (largest integer smaller than given number) and decimals (leftover part always smaller than 1).  Return the decimal part of the number.", "prompt_explain": "Given a positive floating point number, it can be decomposed into\nand integer part (largest integer smaller than given number) and decimals\n(leftover part always smaller than 1).\n\nReturn the decimal part of the number.\n>>> TruncateNumber(3.5)\n0.5\n", "func_title": "func TruncateNumber(number float64) float64 ", "prompt_text_chinese": "给定一个正浮点数，它可以分解为整数部分(小于给定数字的最大整数)和小数部分(剩余部分总是小于1)，返回该数字的小数部分。"}
{"task_id": "Go/3", "prompt": "\n// You're given a list of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> BelowZero([1, 2, 3])\n// false\n// >>> BelowZero([1, 2, -4, 5])\n// true\nfunc BelowZero(operations []int) bool {\n", "import": "", "docstring": "// You're given a list of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> BelowZero([1, 2, 3])\n// false\n// >>> BelowZero([1, 2, -4, 5])\n// true\n", "declaration": "\nfunc BelowZero(operations []int) bool {\n", "canonical_solution": "    balance := 0\n    for _, op := range operations {\n        balance += op\n        if balance < 0 {\n            return true\n        }\n    }\n    return false\n}\n\n", "test": "func TestBelowZero(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(false, BelowZero([]int{}))\n    assert.Equal(false, BelowZero([]int{1, 2, -3, 1, 2, -3}))\n    assert.Equal(true, BelowZero([]int{1, 2, -4, 5, 6}))\n    assert.Equal(false, BelowZero([]int{1, -1, 2, -2, 5, -5, 4, -4}))\n    assert.Equal(true, BelowZero([]int{1, -1, 2, -2, 5, -5, 4, -5}))\n    assert.Equal(true, BelowZero([]int{1, -2, 2, -2, 5, -5, 4, -4}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestBelowZero(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(false, BelowZero([]int{1, 2, 3}))\n    assert.Equal(true, BelowZero([]int{1, 2, -4, 5}))\n}\n", "prompt_text": "You're given a list of deposit and withdrawal operations on a bank account that starts with zero balance. Your task is to detect if at any point the balance of account fallls below zero, and at that point function should return true. Otherwise it should return false.", "prompt_explain": "You're given a list of deposit and withdrawal operations on a bank account that starts with\nzero balance. Your task is to detect if at any point the balance of account fallls below zero, and\nat that point function should return true. Otherwise it should return false.\n>>> BelowZero([1, 2, 3])\nfalse\n>>> BelowZero([1, 2, -4, 5])\ntrue\n", "func_title": "func BelowZero(operations []int) bool ", "prompt_text_chinese": "给你一个银行账户的存款和取款操作列表，余额为零。您的任务是检测帐户余额是否在任何时刻低于零，并且在该点函数应该返回true。否则返回false。"}
{"task_id": "Go/4", "prompt": "import (\n    \"math\"\n)\n\n// For a given list of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> MeanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n// 1.0\nfunc MeanAbsoluteDeviation(numbers []float64) float64 {\n", "import": "import (\n    \"math\"\n)\n", "docstring": "// For a given list of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> MeanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n// 1.0\n", "declaration": "\nfunc MeanAbsoluteDeviation(numbers []float64) float64 {\n", "canonical_solution": "    sum := func(numbers []float64) float64 {\n        sum := 0.0\n        for _, num := range numbers {\n            sum += num\n        }\n        return sum\n    }\n\n    mean := sum(numbers) / float64(len(numbers))\n    numList := make([]float64, 0)\n    for _, x := range numbers {\n        numList = append(numList, math.Abs(x-mean))\n    }\n    return sum(numList) / float64(len(numbers))\n}\n\n", "test": "func TestMeanAbsoluteDeviation(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, math.Abs(MeanAbsoluteDeviation([]float64{1.0, 2.0, 3.0})-2.0/3.0) < 1e-6)\n    assert.Equal(true, math.Abs(MeanAbsoluteDeviation([]float64{1.0, 2.0, 3.0, 4.0})-1.0) < 1e-6)\n    assert.Equal(true, math.Abs(MeanAbsoluteDeviation([]float64{1.0, 2.0, 3.0, 4.0, 5.0})-6.0/5.0) < 1e-6)\n\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestMeanAbsoluteDeviation(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, math.Abs(MeanAbsoluteDeviation([]float64{1.0, 2.0, 3.0, 4.0})-1.0) < 1e-6)\n}\n", "prompt_text": "For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset. Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case): MAD = average | x - x_mean |", "prompt_explain": "For a given list of input numbers, calculate Mean Absolute Deviation\naround the mean of this dataset.\nMean Absolute Deviation is the average absolute difference between each\nelement and a centerpoint (mean in this case):\nMAD = average | x - x_mean |\n>>> MeanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n1.0\n", "func_title": "func MeanAbsoluteDeviation(numbers []float64) float64 ", "prompt_text_chinese": "对于给定的输入数字列表，计算该数据集平均值附近的平均绝对偏差。平均绝对偏差是每个元素与中心点之间的平均绝对差值(在本例中为平均值):MAD = average | x - x_mean |"}
{"task_id": "Go/5", "prompt": "\n// Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n// >>> Intersperse([], 4)\n// []\n// >>> Intersperse([1, 2, 3], 4)\n// [1, 4, 2, 4, 3]\nfunc Intersperse(numbers []int, delimeter int) []int {\n", "import": "", "docstring": "// Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n// >>> Intersperse([], 4)\n// []\n// >>> Intersperse([1, 2, 3], 4)\n// [1, 4, 2, 4, 3]\n", "declaration": "\nfunc Intersperse(numbers []int, delimeter int) []int {\n", "canonical_solution": "    result := make([]int, 0)\n    if len(numbers) == 0 {\n        return result\n    }\n    for i := 0; i < len(numbers)-1; i++ {\n        n := numbers[i]\n        result = append(result, n)\n        result = append(result, delimeter)\n    }\n    result = append(result, numbers[len(numbers)-1])\n    return result\n}\n\n", "test": "func TestIntersperse(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{}, Intersperse([]int{}, 7))\n    assert.Equal([]int{5, 8, 6, 8, 3, 8, 2}, Intersperse([]int{5, 6, 3, 2}, 8))\n    assert.Equal([]int{2, 2, 2, 2, 2}, Intersperse([]int{2, 2, 2}, 2))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestIntersperse(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{}, Intersperse([]int{}, 4))\n    assert.Equal([]int{1,4,2,4,3}, Intersperse([]int{1,2,3}, 4))\n}\n", "prompt_text": "Insert a number 'delimeter' between every two consecutive elements of input list `numbers'", "prompt_explain": "Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n>>> Intersperse([], 4)\n[]\n>>> Intersperse([1, 2, 3], 4)\n[1, 4, 2, 4, 3]\n", "func_title": "func Intersperse(numbers []int, delimeter int) []int ", "prompt_text_chinese": "在输入列表“numbers”的每两个连续元素之间插入一个数字“delimeter”"}
{"task_id": "Go/6", "prompt": "import (\n    \"math\"\n    \"strings\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// \n// >>> ParseNestedParens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nfunc ParseNestedParens(paren_string string) []int {\n", "import": "import (\n    \"math\"\n    \"strings\"\n)\n", "docstring": "// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// \n// >>> ParseNestedParens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\n", "declaration": "\nfunc ParseNestedParens(paren_string string) []int {\n", "canonical_solution": "    parse_paren_group := func(s string) int {\n        depth := 0\n        max_depth := 0\n        for _, c := range s {\n            if c == '(' {\n                depth += 1\n                max_depth = int(math.Max(float64(depth), float64(max_depth)))\n            } else {\n                depth -= 1\n            }\n        }\n        return max_depth\n    }\n    result := make([]int, 0)\n    for _, x := range strings.Split(paren_string, \" \") {\n        result = append(result, parse_paren_group(x))\n    }\n    return result\n\n}\n\n", "test": "func TestParseNestedParens(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{2, 3, 1, 3}, ParseNestedParens(\"(()()) ((())) () ((())()())\"))\n    assert.Equal([]int{1, 2, 3, 4}, ParseNestedParens(\"() (()) ((())) (((())))\"))\n    assert.Equal([]int{4}, ParseNestedParens(\"(()(())((())))\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestParseNestedParens(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{2, 3, 1, 3}, ParseNestedParens(\"(()()) ((())) () ((())()())\"))\n}\n", "prompt_text": "Input to this function is a string represented multiple groups for nested parentheses separated by spaces. For each of the group, output the deepest level of nesting of parentheses. E.g. (()()) has maximum two levels of nesting while ((())) has three. ", "prompt_explain": "Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\nFor each of the group, output the deepest level of nesting of parentheses.\nE.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n>>> ParseNestedParens('(()()) ((())) () ((())()())')\n[2, 3, 1, 3]\n", "func_title": "func ParseNestedParens(paren_string string) []int ", "prompt_text_chinese": "该函数的输入是一个字符串，表示由空格分隔的嵌套括号中的多个组。对于每个组，输出圆括号嵌套的最深层次。"}
{"task_id": "Go/7", "prompt": "import (\n    \"strings\"\n)\n\n// Filter an input list of strings only for ones that contain given substring\n// >>> FilterBySubstring([], 'a')\n// []\n// >>> FilterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nfunc FilterBySubstring(stringList []string, substring string) []string {\n", "import": "import (\n    \"strings\"\n)\n", "docstring": "// Filter an input list of strings only for ones that contain given substring\n// >>> FilterBySubstring([], 'a')\n// []\n// >>> FilterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\n", "declaration": "\nfunc FilterBySubstring(stringList []string, substring string) []string {\n", "canonical_solution": "    result := make([]string, 0)\n    for _, x := range stringList {\n        if strings.Index(x, substring) != -1 {\n            result = append(result, x)\n        }\n    }\n    return result\n}\n\n", "test": "func TestFilterBySubstring(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]string{}, FilterBySubstring([]string{}, \"john\"))\n    assert.Equal([]string{\"xxx\", \"xxxAAA\", \"xxx\"}, FilterBySubstring([]string{\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xxx\"))\n    assert.Equal([]string{\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"}, FilterBySubstring([]string{\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xx\"))\n    assert.Equal([]string{\"grunt\", \"prune\"}, FilterBySubstring([]string{\"grunt\", \"trumpet\", \"prune\", \"gruesome\"}, \"run\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestFilterBySubstring(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]string{}, FilterBySubstring([]string{}, \"a\"))\n    assert.Equal([]string{\"abc\", \"bacd\", \"array\"}, FilterBySubstring([]string{\"abc\", \"bacd\", \"cde\", \"array\"}, \"a\"))\n}\n", "prompt_text": "Filter an input list of strings only for ones that contain given substring", "prompt_explain": "Filter an input list of strings only for ones that contain given substring\n>>> FilterBySubstring([], 'a')\n[]\n>>> FilterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n['abc', 'bacd', 'array']\n", "func_title": "func FilterBySubstring(stringList []string, substring string) []string ", "prompt_text_chinese": "只过滤包含给定子字符串的输入字符串列表"}
{"task_id": "Go/8", "prompt": "\n// For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> SumProduct([])\n// (0, 1)\n// >>> SumProduct([1, 2, 3, 4])\n// (10, 24)\nfunc SumProduct(numbers []int) [2]int {\n", "import": "", "docstring": "// For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> SumProduct([])\n// (0, 1)\n// >>> SumProduct([1, 2, 3, 4])\n// (10, 24)\n", "declaration": "\nfunc SumProduct(numbers []int) [2]int {\n", "canonical_solution": "    sum_value := 0\n    prod_value := 1\n\n    for _, n := range numbers {\n        sum_value += n\n        prod_value *= n\n    }\n    return [2]int{sum_value, prod_value}\n}\n\n", "test": "func TestSumProduct(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([2]int{0, 1}, SumProduct([]int{}))\n    assert.Equal([2]int{3, 1}, SumProduct([]int{1, 1, 1}))\n    assert.Equal([2]int{100, 0}, SumProduct([]int{100, 0}))\n    assert.Equal([2]int{3 + 5 + 7, 3 * 5 * 7}, SumProduct([]int{3, 5, 7}))\n    assert.Equal([2]int{10, 10}, SumProduct([]int{10}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSumProduct(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([2]int{0, 1}, SumProduct([]int{}))\n    assert.Equal([2]int{10,24}, SumProduct([]int{1, 2,3,4}))\n}\n", "prompt_text": "For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list. Empty sum should be equal to 0 and empty product should be equal to 1.", "prompt_explain": "For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\nEmpty sum should be equal to 0 and empty product should be equal to 1.\n>>> SumProduct([])\n(0, 1)\n>>> SumProduct([1, 2, 3, 4])\n(10, 24)\n", "func_title": "func SumProduct(numbers []int) [2]int ", "prompt_text_chinese": "对于给定的整数列表，返回一个元组，该元组由列表中所有整数的和和乘积组成。空和应该等于0，空积应该等于1。"}
{"task_id": "Go/9", "prompt": "import (\n    \"math\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> RollingMax([1, 2, 3, 2, 3, 4, 2])\n// [1, 2, 3, 3, 3, 4, 4]\nfunc RollingMax(numbers []int) []int {\n", "import": "import (\n    \"math\"\n)\n", "docstring": "// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> RollingMax([1, 2, 3, 2, 3, 4, 2])\n// [1, 2, 3, 3, 3, 4, 4]\n", "declaration": "\nfunc RollingMax(numbers []int) []int {\n", "canonical_solution": "    running_max := math.MinInt32\n    result := make([]int, 0)\n\n    for _, n := range numbers {\n        if running_max == math.MinInt32 {\n            running_max = n\n        } else {\n            running_max = int(math.Max(float64(running_max), float64(n)))\n        }\n        result = append(result, running_max)\n    }\n\n    return result\n}\n\n", "test": "func TestRollingMax(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{}, RollingMax([]int{}))\n    assert.Equal([]int{1, 2, 3, 4}, RollingMax([]int{1, 2, 3, 4}))\n    assert.Equal([]int{4, 4, 4, 4}, RollingMax([]int{4, 3, 2, 1}))\n    assert.Equal([]int{3, 3, 3, 100, 100}, RollingMax([]int{3, 2, 3, 100, 3}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestRollingMax(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{1, 2, 3,3, 3, 4, 4}, RollingMax([]int{1, 2, 3, 2, 3, 4, 2}))\n}\n", "prompt_text": "From a given list of integers, generate a list of rolling maximum element found until given moment in the sequence.", "prompt_explain": "From a given list of integers, generate a list of rolling maximum element found until given moment\nin the sequence.\n>>> RollingMax([1, 2, 3, 2, 3, 4, 2])\n[1, 2, 3, 3, 3, 4, 4]\n", "func_title": "func RollingMax(numbers []int) []int ", "prompt_text_chinese": "从给定的整数列表中，生成一个滚动到序列中给定时刻为止的最大元素列表。"}
{"task_id": "Go/10", "prompt": "import (\n    \"strings\"\n)\n\n// Test if given string is a palindrome.\nfunc IsPalindrome(str string) bool {\n    runes := []rune(str)\n    result := make([]rune, 0)\n    for i := len(runes) - 1; i >= 0; i-- {\n        result = append(result, runes[i])\n    }\n    return str == string(result)\n}\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> MakePalindrome('')\n// ''\n// >>> MakePalindrome('cat')\n// 'catac'\n// >>> MakePalindrome('cata')\n// 'catac'\nfunc MakePalindrome(str string) string {\n", "import": "import (\n    \"strings\"\n)\n", "docstring": "// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> MakePalindrome('')\n// ''\n// >>> MakePalindrome('cat')\n// 'catac'\n// >>> MakePalindrome('cata')\n// 'catac'\n", "declaration": "\nfunc MakePalindrome(str string) string {\n", "canonical_solution": "    if strings.TrimSpace(str) == \"\" {\n        return \"\"\n    }\n    beginning_of_suffix := 0\n    runes := []rune(str)\n    for !IsPalindrome(string(runes[beginning_of_suffix:])) {\n        beginning_of_suffix += 1\n    }\n    result := make([]rune, 0)\n    for i := len(str[:beginning_of_suffix]) - 1; i >= 0; i-- {\n        result = append(result, runes[i])\n    }\n    return str + string(result)\n}\n\n", "test": "func TestMakePalindrome(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"\", MakePalindrome(\"\"))\n    assert.Equal(\"x\", MakePalindrome(\"x\"))\n    assert.Equal(\"xyzyx\", MakePalindrome(\"xyz\"))\n    assert.Equal(\"xyx\", MakePalindrome(\"xyx\"))\n    assert.Equal(\"jerryrrej\", MakePalindrome(\"jerry\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestMakePalindrome(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"\", MakePalindrome(\"\"))\n    assert.Equal(\"catac\", MakePalindrome(\"cat\"))\n    assert.Equal(\"catac\", MakePalindrome(\"cata\"))\n}\n", "prompt_text": "Find the shortest palindrome that begins with a supplied string. Algorithm idea is simple: - Find the longest postfix of supplied string that is a palindrome. - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.", "prompt_explain": "Find the shortest palindrome that begins with a supplied string.\nAlgorithm idea is simple:\n- Find the longest postfix of supplied string that is a palindrome.\n- Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n>>> MakePalindrome('')\n''\n>>> MakePalindrome('cat')\n'catac'\n>>> MakePalindrome('cata')\n'catac'\n", "func_title": "func MakePalindrome(str string) string ", "prompt_text_chinese": "找到以提供的字符串开头的最短回文。算法思想很简单:-找到所提供的字符串的最长后缀，这是一个回文。—附加到回文后缀前的字符串前缀的反转的字符串末尾。"}
{"task_id": "Go/11", "prompt": "import (\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> StringXor('010', '110')\n// '100'\nfunc StringXor(a string, b string) string {\n", "import": "import (\n    \"fmt\"\n)\n", "docstring": "// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> StringXor('010', '110')\n// '100'\n", "declaration": "\nfunc StringXor(a string, b string) string {\n", "canonical_solution": "    s2b := func(bs string) int32 {\n        result := int32(0)\n        runes := []rune(bs)\n        for _, r := range runes {\n            result = result << 1\n            temp := r - rune('0')\n            result += temp\n        }\n        return result\n    }\n    ab := s2b(a)\n    bb := s2b(b)\n    res := ab ^ bb\n    sprint := fmt.Sprintf(\"%b\", res)\n    for i := 0; i < len(a)-len(sprint); i++ {\n        sprint = \"0\" + sprint\n    }\n    return sprint\n}\n\n", "test": "func TestStringXor(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"010010\", StringXor(\"111000\", \"101010\"))\n    assert.Equal(\"0\", StringXor(\"1\", \"1\"))\n    assert.Equal(\"0101\", StringXor(\"0101\", \"0000\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestStringXor(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"100\", StringXor(\"010\", \"110\"))\n}\n", "prompt_text": "Input are two strings a and b consisting only of 1s and 0s. Perform binary XOR on these inputs and return result also as a string.", "prompt_explain": "Input are two strings a and b consisting only of 1s and 0s.\nPerform binary XOR on these inputs and return result also as a string.\n>>> StringXor('010', '110')\n'100'\n", "func_title": "func StringXor(a string, b string) string ", "prompt_text_chinese": "输入是由1和0组成的两个字符串a和b。对这些输入执行二进制异或，并以字符串形式返回结果。"}
{"task_id": "Go/12", "prompt": "// Out of list of strings, return the Longest one. Return the first one in case of multiple\n// strings of the same length. Return nil in case the input list is empty.\n// >>> Longest([])\n// nil\n// >>> Longest(['a', 'b', 'c'])\n// 'a'\n// >>> Longest(['a', 'bb', 'ccc'])\n// 'ccc'\nfunc Longest(strings []string) interface{}{\n", "import": "", "docstring": "// Out of list of strings, return the Longest one. Return the first one in case of multiple\n// strings of the same length. Return nil in case the input list is empty.\n// >>> Longest([])\n// nil\n// >>> Longest(['a', 'b', 'c'])\n// 'a'\n// >>> Longest(['a', 'bb', 'ccc'])\n// 'ccc'\n", "declaration": "\nfunc Longest(strings []string) interface{}{\n", "canonical_solution": "    if strings == nil || len(strings) == 0 {\n        return nil\n    }\n    maxlen := 0\n    maxi := 0\n    for i, s := range strings {\n        if maxlen < len(s) {\n            maxlen = len(s)\n            maxi = i\n        }\n    }\n    return strings[maxi]\n}\n\n", "test": "func TestLongest(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(nil, Longest([]string{}))\n\tassert.Equal(\"x\", Longest([]string{\"x\", \"y\", \"z\"}))\n\tassert.Equal(\"zzzz\", Longest([]string{\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestLongest(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(nil, Longest([]string{}))\n\tassert.Equal(\"a\", Longest([]string{\"a\", \"b\", \"c\"}))\n\tassert.Equal(\"ccc\", Longest([]string{\"a\", \"bb\", \"ccc\"}))\n}\n", "prompt_text": "Out of list of strings, return the Longest one. Return the first one in case of multiple strings of the same length. Return nil in case the input list is empty.", "prompt_explain": "Out of list of strings, return the Longest one. Return the first one in case of multiple\nstrings of the same length. Return nil in case the input list is empty.\n>>> Longest([])\nnil\n>>> Longest(['a', 'b', 'c'])\n'a'\n>>> Longest(['a', 'bb', 'ccc'])\n'ccc'\n", "func_title": "func Longest(strings []string) interface{}", "prompt_text_chinese": "在字符串列表之外，返回最长的字符串。如果有多个相同长度的字符串，则返回第一个。如果输入列表为空，则返回nil。"}
{"task_id": "Go/13", "prompt": "\n// Return a greatest common divisor of two integers a and b\n// >>> GreatestCommonDivisor(3, 5)\n// 1\n// >>> GreatestCommonDivisor(25, 15)\n// 5\nfunc GreatestCommonDivisor(a int,b int) int{\n", "import": "", "docstring": "// Return a greatest common divisor of two integers a and b\n// >>> GreatestCommonDivisor(3, 5)\n// 1\n// >>> GreatestCommonDivisor(25, 15)\n// 5\n", "declaration": "\nfunc GreatestCommonDivisor(a int,b int) int{\n", "canonical_solution": "    if b < 2 {\n\t\treturn b\n\t}\n\tvar gcd int = 1\n\tfor i := 2; i < b; i++ {\n\t\tif a%i == 0 && b%i == 0 {\n\t\t\tgcd = i\n\t\t}\n\t}\n\treturn gcd\n}\n\n", "test": "func TestGreatestCommonDivisor(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(1, GreatestCommonDivisor(3, 7))\n    assert.Equal(5, GreatestCommonDivisor(10, 15))\n    assert.Equal(7, GreatestCommonDivisor(49, 14))\n    assert.Equal(12, GreatestCommonDivisor(144, 60))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestGreatestCommonDivisor(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(1, GreatestCommonDivisor(3, 5))\n    assert.Equal(5, GreatestCommonDivisor(25, 15))\n}\n", "prompt_text": "Return a greatest common divisor of two integers a and b", "prompt_explain": "Return a greatest common divisor of two integers a and b\n>>> GreatestCommonDivisor(3, 5)\n1\n>>> GreatestCommonDivisor(25, 15)\n5\n", "func_title": "func GreatestCommonDivisor(a int,b int) int", "prompt_text_chinese": "返回两个整数a和b的最大公约数"}
{"task_id": "Go/14", "prompt": "\n// Return list of all prefixes from shortest to longest of the input string\n// >>> AllPrefixes('abc')\n// ['a', 'ab', 'abc']\nfunc AllPrefixes(str string) []string{\n", "import": "", "docstring": "// Return list of all prefixes from shortest to longest of the input string\n// >>> AllPrefixes('abc')\n// ['a', 'ab', 'abc']\n", "declaration": "\nfunc AllPrefixes(str string) []string{\n", "canonical_solution": "    prefixes := make([]string, 0, len(str))\n\tfor i := 0; i < len(str); i++ {\n\t\tprefixes = append(prefixes, str[:i+1])\n\t}\n\treturn prefixes\n}\n\n", "test": "func TestAllPrefixes(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]string{}, AllPrefixes(\"\"))\n    assert.Equal([]string{\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"}, AllPrefixes(\"asdfgh\"))\n    assert.Equal([]string{\"W\", \"WW\", \"WWW\"}, AllPrefixes(\"WWW\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestAllPrefixes(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]string{\"a\", \"ab\", \"abc\"}, AllPrefixes(\"abc\"))\n}\n", "prompt_text": "Return list of all prefixes from shortest to longest of the input string", "prompt_explain": "Return list of all prefixes from shortest to longest of the input string\n>>> AllPrefixes('abc')\n['a', 'ab', 'abc']\n", "func_title": "func AllPrefixes(str string) []string", "prompt_text_chinese": "返回输入字符串中从最短到最长的所有前缀列表"}
{"task_id": "Go/15", "prompt": "import (\n    \"strconv\"\n)\n\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> StringSequence(0)\n// '0'\n// >>> StringSequence(5)\n// '0 1 2 3 4 5'\nfunc StringSequence(n int) string{\n", "import": "import (\n    \"strconv\"\n)\n", "docstring": "// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> StringSequence(0)\n// '0'\n// >>> StringSequence(5)\n// '0 1 2 3 4 5'\n", "declaration": "\nfunc StringSequence(n int) string{\n", "canonical_solution": "    var seq string\n    for i := 0; i <= n; i++ {\n        seq += strconv.Itoa(i)\n        if i != n {\n            seq += \" \"\n        }\n    }\n    return seq\n}\n\n", "test": "func TestStringSequence(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"0\", StringSequence(0))\n    assert.Equal(\"0 1 2 3\", StringSequence(3))\n    assert.Equal(\"0 1 2 3 4 5 6 7 8 9 10\", StringSequence(10))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestStringSequence(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"0\", StringSequence(0))\n    assert.Equal(\"0 1 2 3 4 5\", StringSequence(5))\n}\n", "prompt_text": "Return a string containing space-delimited numbers starting from 0 upto n inclusive.", "prompt_explain": "Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n>>> StringSequence(0)\n'0'\n>>> StringSequence(5)\n'0 1 2 3 4 5'\n", "func_title": "func StringSequence(n int) string", "prompt_text_chinese": "返回一个字符串，包含以空格分隔的数字，从0到n(包括n)。"}
{"task_id": "Go/16", "prompt": "import (\n    \"strings\"\n)\n\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> CountDistinctCharacters('xyzXYZ')\n// 3\n// >>> CountDistinctCharacters('Jerry')\n// 4\nfunc CountDistinctCharacters(str string) int{\n", "import": "import (\n    \"strings\"\n)\n", "docstring": "// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> CountDistinctCharacters('xyzXYZ')\n// 3\n// >>> CountDistinctCharacters('Jerry')\n// 4\n", "declaration": "\nfunc CountDistinctCharacters(str string) int{\n", "canonical_solution": "    lower := strings.ToLower(str)\n\tcount := 0\n\tset := make(map[rune]bool)\n\tfor _, i := range lower {\n\t\tif set[i] == true {\n\t\t\tcontinue\n\t\t} else {\n\t\t\tset[i] = true\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}\n\n\n", "test": "func TestCountDistinctCharacters(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(0, CountDistinctCharacters(\"\"))\n    assert.Equal(5, CountDistinctCharacters(\"abcde\"))\n    assert.Equal(5, CountDistinctCharacters(\"abcde\" + \"cade\" + \"CADE\"))\n    assert.Equal(1, CountDistinctCharacters(\"aaaaAAAAaaaa\"))\n    assert.Equal(5, CountDistinctCharacters(\"Jerry jERRY JeRRRY\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestCountDistinctCharacters(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(3, CountDistinctCharacters(\"xyzXYZ\"))\n    assert.Equal(4, CountDistinctCharacters(\"Jerry\"))\n}\n", "prompt_text": "Given a string, find out how many distinct characters (regardless of case) does it consist of", "prompt_explain": "Given a string, find out how many distinct characters (regardless of case) does it consist of\n>>> CountDistinctCharacters('xyzXYZ')\n3\n>>> CountDistinctCharacters('Jerry')\n4\n", "func_title": "func CountDistinctCharacters(str string) int", "prompt_text_chinese": "给定一个字符串，找出它由多少个不同的字符(不管大小写)组成"}
{"task_id": "Go/17", "prompt": "\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// \n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// \n// >>> ParseMusic('o o| .| o| o| .| .| .| .| o o')\n// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfunc ParseMusic(music_string string) []int{\n", "import": "", "docstring": "// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// \n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// \n// >>> ParseMusic('o o| .| o| o| .| .| .| .| o o')\n// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n", "declaration": "\nfunc ParseMusic(music_string string) []int{\n", "canonical_solution": "    note_map := map[string]int{\"o\": 4, \"o|\": 2, \".|\": 1}\n\tsplit := strings.Split(music_string, \" \")\n\tresult := make([]int, 0)\n\tfor _, x := range split {\n\t\tif i, ok := note_map[x]; ok {\n\t\t\tresult = append(result, i)\n\t\t}\n\t}\n\treturn result\n}\n\n\n", "test": "func TestParseMusic(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{}, ParseMusic(\"\"))\n    assert.Equal([]int{4, 4, 4, 4}, ParseMusic(\"o o o o\"))\n    assert.Equal([]int{1, 1, 1, 1}, ParseMusic(\".| .| .| .|\"))\n    assert.Equal([]int{2, 2, 1, 1, 4, 4, 4, 4}, ParseMusic(\"o| o| .| .| o o o o\"))\n    assert.Equal([]int{2, 1, 2, 1, 4, 2, 4, 2}, ParseMusic(\"o| .| o| .| o o| o o|\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestParseMusic(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}, ParseMusic(\"o o| .| o| o| .| .| .| .| o o\"))\n}\n", "prompt_text": "Input to this function is a string representing musical notes in a special ASCII format. Your task is to parse this string and return list of integers corresponding to how many beats does each not last.  Here is a legend: 'o' - whole note, lasts four beats 'o|' - half note, lasts two beats '.|' - quater note, lasts one beat ", "prompt_explain": "Input to this function is a string representing musical notes in a special ASCII format.\nYour task is to parse this string and return list of integers corresponding to how many beats does each\nnot last.\n\nHere is a legend:\n'o' - whole note, lasts four beats\n'o|' - half note, lasts two beats\n'.|' - quater note, lasts one beat\n\n>>> ParseMusic('o o| .| o| o| .| .| .| .| o o')\n[4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n", "func_title": "func ParseMusic(music_string string) []int", "prompt_text_chinese": "这个函数的输入是一个字符串，以特殊的ASCII格式表示音符。您的任务是解析这个字符串并返回一个整数列表，该列表对应于每个节拍不持续的次数。这里有一个传说:'o' -全音，持续四拍'o|' -半音，持续两拍'。|' -四分音符，持续一拍"}
{"task_id": "Go/18", "prompt": "\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> HowManyTimes('', 'a')\n// 0\n// >>> HowManyTimes('aaa', 'a')\n// 3\n// >>> HowManyTimes('aaaa', 'aa')\n// 3\nfunc HowManyTimes(str string,substring string) int{\n", "import": "", "docstring": "\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> HowManyTimes('', 'a')\n// 0\n// >>> HowManyTimes('aaa', 'a')\n// 3\n// >>> HowManyTimes('aaaa', 'aa')\n// 3\n", "declaration": "\nfunc HowManyTimes(str string,substring string) int{\n", "canonical_solution": "    times := 0\n\tfor i := 0; i < (len(str) - len(substring) + 1); i++ {\n\t\tif str[i:i+len(substring)] == substring {\n\t\t\ttimes += 1\n\t\t}\n\t}\n\treturn times\n}\n\n\n", "test": "func TestHowManyTimes(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(0, HowManyTimes(\"\", \"x\"))\n    assert.Equal(4, HowManyTimes(\"xyxyxyx\", \"x\"))\n    assert.Equal(4, HowManyTimes(\"cacacacac\", \"cac\"))\n    assert.Equal(1, HowManyTimes(\"john doe\", \"john\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestHowManyTimes(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(0, HowManyTimes(\"\", \"a\"))\n    assert.Equal(3, HowManyTimes(\"aaa\", \"a\"))\n    assert.Equal(3, HowManyTimes(\"aaaa\", \"aa\"))\n}\n", "prompt_text": " Find how many times a given substring can be found in the original string. Count overlaping cases.", "prompt_explain": "\nFind how many times a given substring can be found in the original string. Count overlaping cases.\n>>> HowManyTimes('', 'a')\n0\n>>> HowManyTimes('aaa', 'a')\n3\n>>> HowManyTimes('aaaa', 'aa')\n3\n", "func_title": "func HowManyTimes(str string,substring string) int", "prompt_text_chinese": "找出给定的子字符串在原始字符串中可以找到多少次。计算重叠的情况。"}
{"task_id": "Go/19", "prompt": "import (\n    \"sort\"\n    \"strings\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> SortNumbers('three one five')\n// 'one three five'\nfunc SortNumbers(numbers string) string{\n", "import": "import (\n    \"sort\"\n    \"strings\"\n)", "docstring": "// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> SortNumbers('three one five')\n// 'one three five'\n", "declaration": "\nfunc SortNumbers(numbers string) string{\n", "canonical_solution": "    valueMap := map[string]int{\n\t\t\"zero\":  0,\n\t\t\"one\":   1,\n\t\t\"two\":   2,\n\t\t\"three\": 3,\n\t\t\"four\":  4,\n\t\t\"five\":  5,\n\t\t\"six\":   6,\n\t\t\"seven\": 7,\n\t\t\"eight\": 8,\n\t\t\"nine\":  9,\n\t}\n\tstringMap := make(map[int]string)\n\tfor s, i := range valueMap {\n\t\tstringMap[i] = s\n\t}\n\tsplit := strings.Split(numbers, \" \")\n\ttemp := make([]int, 0)\n\tfor _, s := range split {\n\t\tif i, ok := valueMap[s]; ok {\n\t\t\ttemp = append(temp, i)\n\t\t}\n\t}\n\tsort.Ints(temp)\n\tresult := make([]string, 0)\n\tfor _, i := range temp {\n\t\tresult = append(result, stringMap[i])\n\t}\n\treturn strings.Join(result, \" \")\n}\n\n\n", "test": "func TestSortNumbers(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"\", SortNumbers(\"\"))\n    assert.Equal(\"three\", SortNumbers(\"three\"))\n    assert.Equal(\"three five nine\", SortNumbers(\"three five nine\"))\n    assert.Equal(\"zero four five seven eight nine\", SortNumbers(\"five zero four seven nine eight\"))\n    assert.Equal(\"zero one two three four five six\", SortNumbers(\"six five four three two one zero\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSortNumbers(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"one three five\", SortNumbers(\"three one five\"))\n}\n", "prompt_text": "Input is a space-delimited string of numberals from 'zero' to 'nine'. Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'. Return the string with numbers sorted from smallest to largest", "prompt_explain": "Input is a space-delimited string of numberals from 'zero' to 'nine'.\nValid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\nReturn the string with numbers sorted from smallest to largest\n>>> SortNumbers('three one five')\n'one three five'\n", "func_title": "func SortNumbers(numbers string) string", "prompt_text_chinese": "Nput是一个以空格分隔的数字字符串，由“0”到“9”组成。有效的选项是“0”、“1”、“2”、“3”、“4”、“5”、“6”、“7”、“8”和“9”。返回由小到大排序的字符串"}
{"task_id": "Go/20", "prompt": "\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> FindClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n// (2.0, 2.2)\n// >>> FindClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n// (2.0, 2.0)\nfunc FindClosestElements(numbers []float64) [2]float64 {\n", "import": "", "docstring": "// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> FindClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n// (2.0, 2.2)\n// >>> FindClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n// (2.0, 2.0)\n", "declaration": "\nfunc FindClosestElements(numbers []float64) [2]float64 {\n", "canonical_solution": "    distance := math.MaxFloat64\n\tvar closestPair [2]float64\n\tfor idx, elem := range numbers {\n\t\tfor idx2, elem2 := range numbers {\n\t\t\tif idx != idx2 {\n\t\t\t\tif distance == math.MinInt64 {\n\t\t\t\t\tdistance = math.Abs(elem - elem2)\n\t\t\t\t\tfloat64s := []float64{elem, elem2}\n\t\t\t\t\tsort.Float64s(float64s)\n\t\t\t\t\tclosestPair = [2]float64{float64s[0], float64s[1]}\n\t\t\t\t} else {\n\t\t\t\t\tnewDistance := math.Abs(elem - elem2)\n\t\t\t\t\tif newDistance < distance{\n\t\t\t\t\t\tdistance = newDistance\n\t\t\t\t\t\tfloat64s := []float64{elem, elem2}\n\t\t\t\t\t\tsort.Float64s(float64s)\n\t\t\t\t\t\tclosestPair = [2]float64{float64s[0], float64s[1]}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn closestPair\n}\n\n\n", "test": "func TestFindClosestElements(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([2]float64{3.9, 4.0}, FindClosestElements([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}))\n    assert.Equal([2]float64{5.0, 5.9}, FindClosestElements([]float64{1.0, 2.0, 5.9, 4.0, 5.0}))\n    assert.Equal([2]float64{2.0, 2.2}, FindClosestElements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}))\n    assert.Equal([2]float64{2.0, 2.0}, FindClosestElements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}))\n    assert.Equal([2]float64{2.2, 3.1}, FindClosestElements([]float64{1.1, 2.2, 3.1, 4.1, 5.1}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestFindClosestElements(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([2]float64{2.0, 2.2}, FindClosestElements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}))\n    assert.Equal([2]float64{2.0, 2.0}, FindClosestElements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}))\n}\n", "prompt_text": "From a supplied list of numbers (of length at least two) select and return two that are the closest to each other and return them in order (smaller number, larger number).", "prompt_explain": "From a supplied list of numbers (of length at least two) select and return two that are the closest to each\nother and return them in order (smaller number, larger number).\n>>> FindClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n(2.0, 2.2)\n>>> FindClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n(2.0, 2.0)\n", "func_title": "func FindClosestElements(numbers []float64) [2]float64 ", "prompt_text_chinese": "从提供的数字列表(长度至少为两个)中选择并返回两个彼此最接近的数字，并按顺序返回它们(较小的数字，较大的数字)。"}
{"task_id": "Go/21", "prompt": "\n// Given list of numbers (of at least two elements), apply a linear transform to that list,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> RescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc RescaleToUnit(numbers []float64) []float64 {\n", "import": "", "docstring": "// Given list of numbers (of at least two elements), apply a linear transform to that list,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> RescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n", "declaration": "\nfunc RescaleToUnit(numbers []float64) []float64 {\n", "canonical_solution": "    smallest := numbers[0]\n\tlargest := smallest\n\tfor _, n := range numbers {\n\t\tif smallest > n {\n\t\t\tsmallest = n\n\t\t}\n\t\tif largest < n {\n\t\t\tlargest = n\n\t\t}\n\t}\n\tif smallest == largest {\n\t\treturn numbers\n\t}\n\tfor i, n := range numbers {\n\t\tnumbers[i] = (n - smallest) / (largest - smallest)\n\t}\n\treturn numbers\n}\n\n", "test": "func TestRescaleToUnit(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]float64{0.0, 1.0}, RescaleToUnit([]float64{2.0, 49.9}))\n    assert.Equal([]float64{1.0, 0.0}, RescaleToUnit([]float64{100.0, 49.9}))\n    assert.Equal([]float64{0.0, 0.25, 0.5, 0.75, 1.0}, RescaleToUnit([]float64{1.0, 2.0, 3.0, 4.0, 5.0}))\n    assert.Equal([]float64{0.25, 0.0, 1.0, 0.5, 0.75}, RescaleToUnit([]float64{2.0, 1.0, 5.0, 3.0, 4.0}))\n    assert.Equal([]float64{0.25, 0.0, 1.0, 0.5, 0.75}, RescaleToUnit([]float64{12.0, 11.0, 15.0, 13.0, 14.0}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestRescaleToUnit(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]float64{0.0, 0.25, 0.5, 0.75, 1.0}, RescaleToUnit([]float64{1.0, 2.0, 3.0, 4.0, 5.0}))\n}\n", "prompt_text": "Given list of numbers (of at least two elements), apply a linear transform to that list, such that the smallest number will become 0 and the largest will become 1", "prompt_explain": "Given list of numbers (of at least two elements), apply a linear transform to that list,\nsuch that the smallest number will become 0 and the largest will become 1\n>>> RescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n[0.0, 0.25, 0.5, 0.75, 1.0]\n", "func_title": "func RescaleToUnit(numbers []float64) []float64 ", "prompt_text_chinese": "给定一个数字列表(至少包含两个元素)，对该列表应用线性变换，使最小的数字变为0，最大的数字变为1"}
{"task_id": "Go/22", "prompt": "// Filter given list of any values only for integers\n// >>> FilterIntegers(['a', 3.14, 5])\n// [5]\n// >>> FilterIntegers([1, 2, 3, 'abc', {}, []])\n// [1, 2, 3]\nfunc FilterIntegers(values []interface{}) []int {\n", "import": "", "docstring": "// Filter given list of any values only for integers\n// >>> FilterIntegers(['a', 3.14, 5])\n// [5]\n// >>> FilterIntegers([1, 2, 3, 'abc', {}, []])\n// [1, 2, 3]\n", "declaration": "\nfunc FilterIntegers(values []interface{}) []int {\n", "canonical_solution": "    result := make([]int, 0)\n    for _, val := range values {\n        switch i := val.(type) {\n        case int:\n            result = append(result, i)\n        }\n    }\n    return result\n}\n\n", "test": "func TestFilterIntegers(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{}, FilterIntegers([]interface{}{}))\n    assert.Equal([]int{4, 9}, FilterIntegers([]interface{}{4, nil, []interface{}{}, 23.2, 9, \"adasd\"}))\n    assert.Equal([]int{3, 3, 3}, FilterIntegers([]interface{}{3, 'c', 3, 3, 'a', 'b'}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestFilterIntegers(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{5}, FilterIntegers([]interface{}{'a', 3.14, 5}))\n    assert.Equal([]int{1,2,3}, FilterIntegers([]interface{}{1,2,3,\"abc\", nil, []interface{}{}}))\n}\n", "prompt_text": "Filter given list of any values only for integers", "prompt_explain": "Filter given list of any values only for integers\n>>> FilterIntegers(['a', 3.14, 5])\n[5]\n>>> FilterIntegers([1, 2, 3, 'abc', {}, []])\n[1, 2, 3]\n", "func_title": "func FilterIntegers(values []interface{}) []int ", "prompt_text_chinese": "过滤给定的任何值的列表仅为整数"}
{"task_id": "Go/23", "prompt": "\n// Return length of given string\n// >>> Strlen('')\n// 0\n// >>> Strlen('abc')\n// 3\nfunc Strlen(str string) int {\n", "import": "", "docstring": "// Return length of given string\n// >>> Strlen('')\n// 0\n// >>> Strlen('abc')\n// 3\n", "declaration": "\nfunc Strlen(str string) int {\n", "canonical_solution": "    return len(str)\n}\n\n", "test": "func TestStrlen(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(0, Strlen(\"\"))\n    assert.Equal(1, Strlen(\"x\"))\n    assert.Equal(9, Strlen(\"asdasnakj\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestStrlen(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(0, Strlen(\"\"))\n    assert.Equal(3, Strlen(\"abc\"))\n}\n", "prompt_text": "Return length of given string", "prompt_explain": "Return length of given string\n>>> Strlen('')\n0\n>>> Strlen('abc')\n3\n", "func_title": "func Strlen(str string) int ", "prompt_text_chinese": "返回给定字符串的长度"}
{"task_id": "Go/24", "prompt": "\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> LargestDivisor(15)\n// 5\nfunc LargestDivisor(n int) int {\n", "import": "", "docstring": "// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> LargestDivisor(15)\n// 5\n", "declaration": "\nfunc LargestDivisor(n int) int {\n", "canonical_solution": "    for i := n - 1; i > 0; i-- {\n\t\tif n % i == 0 {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn 0\n}\n\n", "test": "func TestLargestDivisor(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(1, LargestDivisor(3))\n    assert.Equal(1, LargestDivisor(7))\n    assert.Equal(5, LargestDivisor(10))\n    assert.Equal(50, LargestDivisor(100))\n    assert.Equal(7, LargestDivisor(49))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestLargestDivisor(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(5, LargestDivisor(15))\n}\n", "prompt_text": "For a given number n, find the largest number that divides n evenly, smaller than n", "prompt_explain": "For a given number n, find the largest number that divides n evenly, smaller than n\n>>> LargestDivisor(15)\n5\n", "func_title": "func LargestDivisor(n int) int ", "prompt_text_chinese": "对于给定的数n，求出能将n整除且小于n的最大的数"}
{"task_id": "Go/25", "prompt": "import (\n    \"math\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> Factorize(8)\n// [2, 2, 2]\n// >>> Factorize(25)\n// [5, 5]\n// >>> Factorize(70)\n// [2, 5, 7]\nfunc Factorize(n int) []int {\n", "import": "import (\n    \"math\"\n)", "docstring": "// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> Factorize(8)\n// [2, 2, 2]\n// >>> Factorize(25)\n// [5, 5]\n// >>> Factorize(70)\n// [2, 5, 7]\n", "declaration": "\nfunc Factorize(n int) []int {\n", "canonical_solution": "    fact := make([]int, 0)\n\tfor i := 2; i <= int(math.Sqrt(float64(n))+1); {\n\t\tif n%i == 0 {\n\t\t\tfact = append(fact, i)\n\t\t\tn = n / i\n\t\t} else {\n\t\t\ti++\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfact = append(fact, n)\n\t}\n\treturn fact\n}\n\n", "test": "func TestFactorize(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{2}, Factorize(2))\n    assert.Equal([]int{2, 2}, Factorize(4))\n    assert.Equal([]int{2, 2, 2}, Factorize(8))\n    assert.Equal([]int{3, 19}, Factorize(3 * 19))\n    assert.Equal([]int{3, 3, 19, 19}, Factorize(3 * 19 * 3 * 19))\n    assert.Equal([]int{3, 3, 3, 19, 19, 19}, Factorize(3 * 19 * 3 * 19 * 3 * 19))\n    assert.Equal([]int{3, 19, 19, 19}, Factorize(3 * 19 * 19 * 19))\n    assert.Equal([]int{2, 3, 3}, Factorize(3 * 2 * 3))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestFactorize(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{2, 2, 2}, Factorize(8))\n    assert.Equal([]int{5,5}, Factorize(25))\n    assert.Equal([]int{2,5,7}, Factorize(70))\n}\n", "prompt_text": "Return list of prime factors of given integer in the order from smallest to largest. Each of the factors should be listed number of times corresponding to how many times it appeares in factorization. Input number should be equal to the product of all factors", "prompt_explain": "Return list of prime factors of given integer in the order from smallest to largest.\nEach of the factors should be listed number of times corresponding to how many times it appeares in factorization.\nInput number should be equal to the product of all factors\n>>> Factorize(8)\n[2, 2, 2]\n>>> Factorize(25)\n[5, 5]\n>>> Factorize(70)\n[2, 5, 7]\n", "func_title": "func Factorize(n int) []int ", "prompt_text_chinese": "按从小到大的顺序返回给定整数的质因数列表。每一个因子都要列出它在因式分解中出现的次数。输入数应等于所有因子的乘积"}
{"task_id": "Go/26", "prompt": "\n// From a list of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> RemoveDuplicates([1, 2, 3, 2, 4])\n// [1, 3, 4]\nfunc RemoveDuplicates(numbers []int) []int {\n", "import": "", "docstring": "// From a list of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> RemoveDuplicates([1, 2, 3, 2, 4])\n// [1, 3, 4]\n", "declaration": "\nfunc RemoveDuplicates(numbers []int) []int {\n", "canonical_solution": "    c := make(map[int] int)\n\tfor _, number := range numbers {\n\t\tif i, ok := c[number]; ok {\n\t\t\tc[number] = i + 1\n\t\t} else {\n\t\t\tc[number] = 1\n\t\t}\n\t}\n\tresult := make([]int, 0)\n\tfor _, number := range numbers {\n\t\tif c[number] <= 1 {\n\t\t\tresult = append(result, number)\n\t\t}\n\t}\n\treturn result\n}\n\n", "test": "func TestRemoveDuplicates(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{}, RemoveDuplicates([]int{}))\n    assert.Equal([]int{1, 2, 3, 4}, RemoveDuplicates([]int{1, 2, 3,4}))\n    assert.Equal([]int{1, 4, 5}, RemoveDuplicates([]int{1, 2, 3, 2,4, 3, 5}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestRemoveDuplicates(t *testing.T) {\n    assert := assert.New(t)  \n    assert.Equal([]int{1,  3, 4}, RemoveDuplicates([]int{1,2, 3,2,4}))\n}\n", "prompt_text": "From a list of integers, remove all elements that occur more than once. Keep order of elements left the same as in the input.", "prompt_explain": "From a list of integers, remove all elements that occur more than once.\nKeep order of elements left the same as in the input.\n>>> RemoveDuplicates([1, 2, 3, 2, 4])\n[1, 3, 4]\n", "func_title": "func RemoveDuplicates(numbers []int) []int ", "prompt_text_chinese": "从整数列表中删除所有出现一次以上的元素。保持元素的顺序与输入相同。"}
{"task_id": "Go/27", "prompt": "import (\n    \"strings\"\n)\n\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> FlipCase('Hello')\n// 'hELLO'\nfunc FlipCase(str string) string {\n", "import": "import (\n    \"strings\"\n)", "docstring": "\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> FlipCase('Hello')\n// 'hELLO'\n", "declaration": "\nfunc FlipCase(str string) string {\n", "canonical_solution": "    result := []rune{}\n    for _, c := range str {\n        if c >= 'A' && c <= 'Z' {\n            result = append(result, 'a' + ((c - 'A' + 26) % 26))\n        } else if c >= 'a' && c <= 'z' {\n            result = append(result, 'A' + ((c - 'a' + 26) % 26))\n        } else {\n            result = append(result, c)\n        }\n    }\n    return string(result)\n}\n\n", "test": "func TestFlipCase(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"\", FlipCase(\"\"))\n    assert.Equal(\"hELLO!\", FlipCase(\"Hello!\"))\n    assert.Equal(\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\",FlipCase(\"These violent delights have violent ends\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestFlipCase(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"hELLO\", FlipCase(\"Hello\"))\n}\n", "prompt_text": " For a given string, flip lowercase characters to uppercase and uppercase to lowercase.", "prompt_explain": "\nFor a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n>>> FlipCase('Hello')\n'hELLO'\n", "func_title": "func FlipCase(str string) string ", "prompt_text_chinese": "对于给定的字符串，将小写字符转换为大写字符，将大写字符转换为小写字符。"}
{"task_id": "Go/28", "prompt": "\n// Concatenate list of strings into a single string\n// >>> Concatenate([])\n// ''\n// >>> Concatenate(['a', 'b', 'c'])\n// 'abc'\nfunc Concatenate(strings []string) string {\n", "import": "", "docstring": "// Concatenate list of strings into a single string\n// >>> Concatenate([])\n// ''\n// >>> Concatenate(['a', 'b', 'c'])\n// 'abc'\n", "declaration": "\nfunc Concatenate(strings []string) string {\n", "canonical_solution": "    if len(strings) == 0 {\n\t\treturn \"\"\n\t}\n\treturn strings[0] + Concatenate(strings[1:])\n}\n\n", "test": "func TestConcatenate(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"\", Concatenate([]string{}))\n    assert.Equal(\"xyz\", Concatenate([]string{\"x\", \"y\", \"z\"}))\n    assert.Equal(\"xyzwk\", Concatenate([]string{\"x\", \"y\",\"z\", \"w\", \"k\"}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestConcatenate(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"\", Concatenate([]string{}))\n    assert.Equal(\"abc\", Concatenate([]string{\"a\", \"b\", \"c\"}))\n}\n", "prompt_text": "Concatenate list of strings into a single string", "prompt_explain": "Concatenate list of strings into a single string\n>>> Concatenate([])\n''\n>>> Concatenate(['a', 'b', 'c'])\n'abc'\n", "func_title": "func Concatenate(strings []string) string ", "prompt_text_chinese": "串接字符串列表成一个单一的字符串"}
{"task_id": "Go/29", "prompt": "\n// Filter an input list of strings only for ones that start with a given prefix.\n// >>> FilterByPrefix([], 'a')\n// []\n// >>> FilterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n// ['abc', 'array']\nfunc FilterByPrefix(strings []string,prefix string) []string {\n", "import": "", "docstring": "// Filter an input list of strings only for ones that start with a given prefix.\n// >>> FilterByPrefix([], 'a')\n// []\n// >>> FilterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n// ['abc', 'array']\n", "declaration": "\nfunc FilterByPrefix(strings []string,prefix string) []string {\n", "canonical_solution": "    if len(strings) == 0 {\n        return []string{}\n    }\n    res := make([]string, 0, len(strings))\n\tfor _, s := range strings {\n\t\tif s[:len(prefix)] == prefix {\n\t\t\tres = append(res, s)\n\t\t}\n\t}\n\treturn res\n}\n\n\n", "test": "func TestFilterByPrefix(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]string{}, FilterByPrefix([]string{}, \"john\"))\n    assert.Equal([]string{\"xxx\", \"xxxAAA\", \"xxx\"}, FilterByPrefix([]string{\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xxx\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestFilterByPrefix(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]string{}, FilterByPrefix([]string{}, \"a\"))\n    assert.Equal([]string{\"abc\", \"array\"}, FilterByPrefix([]string{\"abc\", \"bcd\", \"cde\", \"array\"}, \"a\"))\n}\n", "prompt_text": "Filter an input list of strings only for ones that start with a given prefix.", "prompt_explain": "Filter an input list of strings only for ones that start with a given prefix.\n>>> FilterByPrefix([], 'a')\n[]\n>>> FilterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n['abc', 'array']\n", "func_title": "func FilterByPrefix(strings []string,prefix string) []string ", "prompt_text_chinese": "仅过滤以给定前缀开头的字符串的输入列表。"}
{"task_id": "Go/30", "prompt": "\n// Return only positive numbers in the list.\n// >>> GetPositive([-1, 2, -4, 5, 6])\n// [2, 5, 6]\n// >>> GetPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n// [5, 3, 2, 3, 9, 123, 1]\nfunc GetPositive(l []int) []int {\n", "import": "", "docstring": "// Return only positive numbers in the list.\n// >>> GetPositive([-1, 2, -4, 5, 6])\n// [2, 5, 6]\n// >>> GetPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n// [5, 3, 2, 3, 9, 123, 1]\n", "declaration": "\nfunc GetPositive(l []int) []int {\n", "canonical_solution": "    res := make([]int, 0)\n    for _, x := range l {\n        if x > 0 {\n            res = append(res, x)\n        }\n    }\n    return res\n}\n\n\n", "test": "func TestGetPositive(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{4, 5, 6}, GetPositive([]int{-1, -2, 4,5, 6}))\n    assert.Equal([]int{5, 3, 2, 3, 3, 9, 123, 1}, GetPositive([]int{5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}))\n    assert.Equal([]int{}, GetPositive([]int{-1, -2}))\n    assert.Equal([]int{}, GetPositive([]int{}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestGetPositive(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{2, 5, 6}, GetPositive([]int{-1, 2, -4,5, 6}))\n    assert.Equal([]int{5, 3, 2,  3, 9, 123, 1}, GetPositive([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}))\n}\n", "prompt_text": "Return only positive numbers in the list.", "prompt_explain": "Return only positive numbers in the list.\n>>> GetPositive([-1, 2, -4, 5, 6])\n[2, 5, 6]\n>>> GetPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n[5, 3, 2, 3, 9, 123, 1]\n", "func_title": "func GetPositive(l []int) []int ", "prompt_text_chinese": "只返回列表中的正数。"}
{"task_id": "Go/31", "prompt": "\n// Return true if a given number is prime, and false otherwise.\n// >>> IsPrime(6)\n// false\n// >>> IsPrime(101)\n// true\n// >>> IsPrime(11)\n// true\n// >>> IsPrime(13441)\n// true\n// >>> IsPrime(61)\n// true\n// >>> IsPrime(4)\n// false\n// >>> IsPrime(1)\n// false\nfunc IsPrime(n int) bool {\n", "import": "", "docstring": "// Return true if a given number is prime, and false otherwise.\n// >>> IsPrime(6)\n// false\n// >>> IsPrime(101)\n// true\n// >>> IsPrime(11)\n// true\n// >>> IsPrime(13441)\n// true\n// >>> IsPrime(61)\n// true\n// >>> IsPrime(4)\n// false\n// >>> IsPrime(1)\n// false\n", "declaration": "\nfunc IsPrime(n int) bool {\n", "canonical_solution": "    if n <= 1 {\n\t\treturn false\n\t}\n\tif n == 2 {\n\t\treturn true\n\t}\n\tif n%2 == 0 {\n\t\treturn false\n\t}\n\tfor i := 3; i*i <= n; i += 2 {\n\t\tif n%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n\n", "test": "func TestIsPrime(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(false, IsPrime(6))\n    assert.Equal(true, IsPrime(101))\n    assert.Equal(true, IsPrime(11))\n    assert.Equal(true, IsPrime(13441))\n    assert.Equal(true, IsPrime(61))\n    assert.Equal(false, IsPrime(4))\n    assert.Equal(false, IsPrime(1))\n    assert.Equal(true, IsPrime(5))\n    assert.Equal(true, IsPrime(11))\n    assert.Equal(true, IsPrime(17))\n    assert.Equal(false, IsPrime(5 * 17))\n    assert.Equal(false, IsPrime(11 * 7))\n    assert.Equal(false, IsPrime(13441 * 19))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestIsPrime(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(false, IsPrime(6))\n    assert.Equal(true, IsPrime(101))\n    assert.Equal(true, IsPrime(11))\n    assert.Equal(true, IsPrime(13441))\n    assert.Equal(true, IsPrime(61))\n    assert.Equal(false, IsPrime(4))\n    assert.Equal(false, IsPrime(1))\n}\n", "prompt_text": "Return true if a given number is prime, and false otherwise.", "prompt_explain": "Return true if a given number is prime, and false otherwise.\n>>> IsPrime(6)\nfalse\n>>> IsPrime(101)\ntrue\n>>> IsPrime(11)\ntrue\n>>> IsPrime(13441)\ntrue\n>>> IsPrime(61)\ntrue\n>>> IsPrime(4)\nfalse\n>>> IsPrime(1)\nfalse\n", "func_title": "func IsPrime(n int) bool ", "prompt_text_chinese": "如果给定的数字是质数则返回true，否则返回false。"}
{"task_id": "Go/32", "prompt": "import (\n    \"math\"\n)\n\n// Evaluates polynomial with coefficients xs at point x.\n// return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\nfunc Poly(xs []int, x float64) float64{\n    sum := 0.0\n    for i, coeff := range xs {\n        sum += float64(coeff) * math.Pow(x,float64(i))\n    }\n    return sum\n}\n// xs are coefficients of a polynomial.\n// FindZero find x such that Poly(x) = 0.\n// FindZero returns only only zero point, even if there are many.\n// Moreover, FindZero only takes list xs having even number of coefficients\n// and largest non zero coefficient as it guarantees\n// a solution.\n// >>> round(FindZero([1, 2]), 2) # f(x) = 1 + 2x\n// -0.5\n// >>> round(FindZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n// 1.0\nfunc FindZero(xs []int) float64 {\n", "import": "import (\n    \"math\"\n)\n", "docstring": "// xs are coefficients of a polynomial.\n// FindZero find x such that Poly(x) = 0.\n// FindZero returns only only zero point, even if there are many.\n// Moreover, FindZero only takes list xs having even number of coefficients\n// and largest non zero coefficient as it guarantees\n// a solution.\n// >>> round(FindZero([1, 2]), 2) # f(x) = 1 + 2x\n// -0.5\n// >>> round(FindZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n// 1.0\n", "declaration": "\nfunc FindZero(xs []int) float64 {\n", "canonical_solution": "    begin := -1.0\n\tend := 1.0\n\tfor Poly(xs, begin)*Poly(xs, end) > 0 {\n\t\tbegin *= 2\n\t\tend *= 2\n\t}\n\tfor end-begin > 1e-10 {\n\t\tcenter := (begin + end) / 2\n\t\tif Poly(xs, center)*Poly(xs, begin) > 0 {\n\t\t\tbegin = center\n\t\t} else {\n\t\t\tend = center\n\t\t}\n\t}\n\treturn begin\n}\n\n", "test": "func TestFindZero(t *testing.T) {\n    assert := assert.New(t)\n    randInt := func(min, max int) int {\n        rng := rand.New(rand.NewSource(42))\n        if min >= max || min == 0 || max == 0 {\n            return max\n        }\n        return rng.Intn(max-min) + min\n    }\n    copyInts := func(src []int) []int {\n        ints := make([]int, 0)\n        for _, i := range src {\n            ints = append(ints, i)\n        }\n        return ints\n    }\n    for i := 0; i < 100; i++ {\n        ncoeff := 2 * randInt(1, 4)\n        coeffs := make([]int, 0)\n        for j := 0; j < ncoeff; j++ {\n            coeff := randInt(-10, 10)\n            if coeff == 0 {\n                coeff = 1\n            }\n            coeffs = append(coeffs, coeff)\n        }\n        solution := FindZero(copyInts(coeffs))\n        assert.Equal(true, math.Abs(Poly(coeffs,solution))<1e-4)\n    }\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"math/rand\"\n    \"math\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestFindZero(t *testing.T) {\n  assert := assert.New(t)\n    assert.Equal(true, math.Abs(FindZero([]int{1,2})+0.5+rand.NormFloat64()*0.0)<1e-4)\n    assert.Equal(true, math.Abs(FindZero([]int{-6,11,-6,1})-1)<1e-4)\n}\n", "prompt_text": "xs are coefficients of a polynomial. FindZero find x such that Poly(x) = 0. FindZero returns only only zero point, even if there are many. Moreover, FindZero only takes list xs having even number of coefficients and largest non zero coefficient as it guarantees a solution.", "prompt_explain": "xs are coefficients of a polynomial.\nFindZero find x such that Poly(x) = 0.\nFindZero returns only only zero point, even if there are many.\nMoreover, FindZero only takes list xs having even number of coefficients\nand largest non zero coefficient as it guarantees\na solution.\n>>> round(FindZero([1, 2]), 2) # f(x) = 1 + 2x\n-0.5\n>>> round(FindZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n1.0\n", "func_title": "func FindZero(xs []int) float64 ", "prompt_text_chinese": "x是多项式的系数。FindZero找到x使得Poly(x) = 0。FindZero只返回0点，即使有很多。此外，FindZero只接受具有偶数个系数和最大的非零系数的列表xs，因为它保证了一个解决方案。"}
{"task_id": "Go/33", "prompt": "import (\n    \"sort\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> SortThird([1, 2, 3])\n// [1, 2, 3]\n// >>> SortThird([5, 6, 3, 4, 8, 9, 2])\n// [2, 6, 3, 4, 8, 9, 5]\nfunc SortThird(l []int) []int {\n", "import": "import (\n    \"sort\"\n)", "docstring": "// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> SortThird([1, 2, 3])\n// [1, 2, 3]\n// >>> SortThird([5, 6, 3, 4, 8, 9, 2])\n// [2, 6, 3, 4, 8, 9, 5]\n", "declaration": "\nfunc SortThird(l []int) []int {\n", "canonical_solution": "    temp := make([]int, 0)\n\tfor i := 0; i < len(l); i = i + 3 {\n\t\ttemp = append(temp, l[i])\n\t}\n\tsort.Ints(temp)\n\tj := 0\n\tfor i := 0; i < len(l); i = i + 3 {\n\t\tl[i] = temp[j]\n\t\tj++\n\t}\n\treturn l\n}\n\n", "test": "func TestSortThird(t *testing.T) {\n    assert := assert.New(t)\n\tsame := func(src []int, target []int) bool {\n\t\tfor i := 0; i < len(src); i++ {\n\t\t\tif src[i] != target[i] {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\tassert.Equal(true, same([]int{1, 2, 3}, SortThird([]int{1, 2, 3})))\n\tassert.Equal(true, same([]int{1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10}, SortThird([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})))\n\tassert.Equal(true, same([]int{-10, 8, -12,3, 23, 2, 4, 11, 12, 5}, SortThird([]int{5, 8, -12, 4, 23, 2, 3, 11, 12, -10})))\n\tassert.Equal(true, same([]int{2, 6, 3, 4, 8, 9, 5}, SortThird([]int{5, 6, 3, 4, 8, 9, 2})))\n\tassert.Equal(true, same([]int{2, 8, 3, 4, 6, 9, 5}, SortThird([]int{5, 8, 3, 4, 6, 9, 2})))\n\tassert.Equal(true, same([]int{2, 6, 9, 4, 8, 3, 5}, SortThird([]int{5, 6, 9, 4, 8, 3, 2})))\n\tassert.Equal(true, same([]int{2, 6, 3, 4, 8, 9, 5, 1}, SortThird([]int{5, 6, 3, 4, 8, 9, 2, 1})))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSortThird(t *testing.T) {\n    assert := assert.New(t)\n\tsame := func(src []int, target []int) bool {\n\t\tfor i := 0; i < len(src); i++ {\n\t\t\tif src[i] != target[i] {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\tassert.Equal(true, same([]int{1, 2, 3}, SortThird([]int{1, 2, 3})))\n\tassert.Equal(true, same([]int{2, 6, 3, 4, 8, 9, 5}, SortThird([]int{5, 6, 3, 4, 8, 9, 2})))\n}\n", "prompt_text": "This function takes a list l and returns a list l' such that l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal to the values of the corresponding indicies of l, but sorted.", "prompt_explain": "This function takes a list l and returns a list l' such that\nl' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\nto the values of the corresponding indicies of l, but sorted.\n>>> SortThird([1, 2, 3])\n[1, 2, 3]\n>>> SortThird([5, 6, 3, 4, 8, 9, 2])\n[2, 6, 3, 4, 8, 9, 5]\n", "func_title": "func SortThird(l []int) []int ", "prompt_text_chinese": "这个函数接受一个列表l并返回一个列表l'，使得l'在不能被3整除的下标处与l相同，而它在能被3整除的下标处的值等于l的相应下标处的值，但已排序。"}
{"task_id": "Go/34", "prompt": "import (\n    \"sort\"\n)\n\n// Return sorted Unique elements in a list\n// >>> Unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n// [0, 2, 3, 5, 9, 123]\nfunc Unique(l []int) []int {\n", "import": "import (\n    \"sort\"\n)", "docstring": "// Return sorted Unique elements in a list\n// >>> Unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n// [0, 2, 3, 5, 9, 123]\n", "declaration": "\nfunc Unique(l []int) []int {\n", "canonical_solution": "    set := make(map[int]interface{})\n\tfor _, i := range l {\n\t\tset[i]=nil\n\t}\n\tl = make([]int,0)\n\tfor i, _ := range set {\n\t\tl = append(l, i)\n\t}\n\tsort.Ints(l)\n\treturn l\n}\n\n", "test": "func TestUnique(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{0, 2, 3, 5, 9, 123}, Unique([]int{5, 3,5, 2, 3, 3, 9, 0, 123}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestUnique(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{0, 2, 3, 5, 9, 123}, Unique([]int{5, 3,5, 2, 3, 3, 9, 0, 123}))\n}\n", "prompt_text": "Return sorted Unique elements in a list", "prompt_explain": "Return sorted Unique elements in a list\n>>> Unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n[0, 2, 3, 5, 9, 123]\n", "func_title": "func Unique(l []int) []int ", "prompt_text_chinese": "返回列表中排序的唯一元素"}
{"task_id": "Go/35", "prompt": "\n// Return maximum element in the list.\n// >>> MaxElement([1, 2, 3])\n// 3\n// >>> MaxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n// 123\nfunc MaxElement(l []int) int {\n", "import": "", "docstring": "// Return maximum element in the list.\n// >>> MaxElement([1, 2, 3])\n// 3\n// >>> MaxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n// 123\n", "declaration": "\nfunc MaxElement(l []int) int {\n", "canonical_solution": "    max := l[0]\n\tfor _, x := range l {\n\t\tif x > max {\n\t\t\tmax = x\n\t\t}\n\t}\n\treturn max\n}\n\n", "test": "func TestMaxElement(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(3, MaxElement([]int{1, 2, 3}))\n    assert.Equal(124, MaxElement([]int{5, 3, -5, 2, -3, 3, 9,0, 124, 1, -10}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestMaxElement(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(3, MaxElement([]int{1, 2, 3}))\n    assert.Equal(123, MaxElement([]int{5, 3, -5, 2, -3, 3, 9,0, 123, 1, -10}))\n}\n", "prompt_text": "Return maximum element in the list.", "prompt_explain": "Return maximum element in the list.\n>>> MaxElement([1, 2, 3])\n3\n>>> MaxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n123\n", "func_title": "func MaxElement(l []int) int ", "prompt_text_chinese": "返回列表中最大的元素。"}
{"task_id": "Go/36", "prompt": "import (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> FizzBuzz(50)\n// 0\n// >>> FizzBuzz(78)\n// 2\n// >>> FizzBuzz(79)\n// 3\nfunc FizzBuzz(n int) int {\n", "import": "import (\n\t\"strconv\"\n\t\"strings\"\n)", "docstring": "// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> FizzBuzz(50)\n// 0\n// >>> FizzBuzz(78)\n// 2\n// >>> FizzBuzz(79)\n// 3\n", "declaration": "\nfunc FizzBuzz(n int) int {\n", "canonical_solution": "    ns := make([]int, 0)\n\tfor i := 0; i < n; i++ {\n\t\tif i%11 == 0 || i%13 == 0 {\n\t\t\tns = append(ns, i)\n\t\t}\n\t}\n\ttemp := make([]string, 0)\n\tfor _, i := range ns {\n\t\ttemp = append(temp, strconv.Itoa(i))\n\t}\n\tjoin := strings.Join(temp, \"\")\n\tans := 0\n\tfor _, c := range join {\n\t\tif c == '7' {\n\t\t\tans++\n\t\t}\n\t}\n\treturn ans\n}\n\n", "test": "func TestFizzBuzz(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(0, FizzBuzz(50))\n    assert.Equal(2, FizzBuzz(78))\n    assert.Equal(3, FizzBuzz(79))\n    assert.Equal(3, FizzBuzz(100))\n    assert.Equal(6, FizzBuzz(200))\n    assert.Equal(192, FizzBuzz(4000))\n    assert.Equal(639, FizzBuzz(10000))\n    assert.Equal(8026, FizzBuzz(100000))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestFizzBuzz(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(0, FizzBuzz(50))\n    assert.Equal(2, FizzBuzz(78))\n    assert.Equal(3, FizzBuzz(79))\n}\n", "prompt_text": "Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.", "prompt_explain": "Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n>>> FizzBuzz(50)\n0\n>>> FizzBuzz(78)\n2\n>>> FizzBuzz(79)\n3\n", "func_title": "func FizzBuzz(n int) int ", "prompt_text_chinese": "返回数字7在小于n且能被11或13整除的整数中出现的次数。"}
{"task_id": "Go/37", "prompt": "import (\n\t\"sort\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> SortEven([1, 2, 3])\n// [1, 2, 3]\n// >>> SortEven([5, 6, 3, 4])\n// [3, 6, 5, 4]\nfunc SortEven(l []int) []int {\n", "import": "import (\n\t\"sort\"\n)", "docstring": "// This function takes a list l and returns a list l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> SortEven([1, 2, 3])\n// [1, 2, 3]\n// >>> SortEven([5, 6, 3, 4])\n// [3, 6, 5, 4]\n", "declaration": "\nfunc SortEven(l []int) []int {\n", "canonical_solution": "    evens := make([]int, 0)\n\tfor i := 0; i < len(l); i += 2 {\n\t\tevens = append(evens, l[i])\n\t}\n\tsort.Ints(evens)\n\tj := 0\n\tfor i := 0; i < len(l); i += 2 {\n\t\tl[i] = evens[j]\n\t\tj++\n\t}\n\treturn l\n}\n\n", "test": "func TestSortEven(t *testing.T) {\n\tassert := assert.New(t)\n\tsame := func(src []int, target []int) bool {\n\t\tfor i := 0; i < len(src); i++ {\n\t\t\tif src[i] != target[i] {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\tassert.Equal(true, same([]int{1, 2, 3}, SortEven([]int{1, 2, 3})))\n\tassert.Equal(true, same([]int{-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123}, SortEven([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})))\n\tassert.Equal(true, same([]int{-12, 8, 3, 4, 5, 2, 12, 11, 23, -10}, SortEven([]int{5, 8, -12, 4, 23, 2, 3, 11, 12, -10})))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSortEven(t *testing.T) {\n\tassert := assert.New(t)\n\tsame := func(src []int, target []int) bool {\n\t\tfor i := 0; i < len(src); i++ {\n\t\t\tif src[i] != target[i] {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\tassert.Equal(true, same([]int{1, 2, 3}, SortEven([]int{1, 2, 3})))\n\tassert.Equal(true, same([]int{3,6,5,4}, SortEven([]int{5,6,3,4})))\n}\n", "prompt_text": "This function takes a list l and returns a list l' such that l' is identical to l in the odd indicies, while its values at the even indicies are equal to the values of the even indicies of l, but sorted.", "prompt_explain": "This function takes a list l and returns a list l' such that\nl' is identical to l in the odd indicies, while its values at the even indicies are equal\nto the values of the even indicies of l, but sorted.\n>>> SortEven([1, 2, 3])\n[1, 2, 3]\n>>> SortEven([5, 6, 3, 4])\n[3, 6, 5, 4]\n", "func_title": "func SortEven(l []int) []int ", "prompt_text_chinese": "这个函数接受一个列表l并返回一个列表l'，使得l'在奇数下标处与l相同，而它在偶数下标处的值等于l的偶数下标处的值，但已排序。"}
{"task_id": "Go/38", "prompt": "import (\n    \"math\"\n    \"strings\"\n    \"time\"\n)\n\n// returns encoded string by cycling groups of three characters.\nfunc EncodeCyclic(s string) string {\n    groups := make([]string, 0)\n    for i := 0; i < ((len(s) + 2) / 3); i++ {\n        groups = append(groups, s[3*i:int(math.Min(float64(3*i+3), float64(len(s))))])\n    }\n    newGroups := make([]string, 0)\n    for _, group := range groups {\n        runes := []rune(group)\n        if len(group) == 3 {\n            newGroups = append(newGroups, string(append(runes[1:], runes[0])))\n        } else {\n            newGroups = append(newGroups, group)\n        }\n    }\n    return strings.Join(newGroups, \"\")\n}\n\n// takes as input string encoded with EncodeCyclic function. Returns decoded string.\nfunc DecodeCyclic(s string) string {\n", "import": "import (\n    \"math\"\n    \"strings\"\n    \"time\"\n)\n", "docstring": "// returns encoded string by cycling groups of three characters.\n// takes as input string encoded with EncodeCyclic function. Returns decoded string.\n", "declaration": "\nfunc DecodeCyclic(s string) string {\n", "canonical_solution": "    return EncodeCyclic(EncodeCyclic(s))\n}\n\n", "test": "func TestDecodeCyclic(t *testing.T) {\n    assert := assert.New(t)\n    randInt := func(min, max int) int {\n        rng := rand.New(rand.NewSource(time.Now().UnixNano()))\n        if min >= max || min == 0 || max == 0 {\n            return max\n        }\n        return rng.Intn(max-min) + min\n    }\n    for i := 0; i <100 ; i++ {\n        runes := make([]rune, 0)\n        for j := 0; j < randInt(10,20); j++ {\n            runes = append(runes, int32(randInt('a','z')))\n        }\n        encoded_str := EncodeCyclic(string(runes))\n        assert.Equal(string(runes), DecodeCyclic(encoded_str))\n    }\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"math/rand\"\n    \"math\"\n    \"time\"\n    \"strings\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "", "prompt_text": "", "prompt_explain": "returns encoded string by cycling groups of three characters.\ntakes as input string encoded with EncodeCyclic function. Returns decoded string.\n", "func_title": "func DecodeCyclic(s string) string ", "prompt_text_chinese": "以三个字符为一组循环返回编码后的字符串。作为输入字符串，使用EncodeCyclic函数编码。返回解码后的字符串。"}
{"task_id": "Go/39", "prompt": "import (\n\t\"math\"\n)\n\n// PrimeFib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> PrimeFib(1)\n// 2\n// >>> PrimeFib(2)\n// 3\n// >>> PrimeFib(3)\n// 5\n// >>> PrimeFib(4)\n// 13\n// >>> PrimeFib(5)\n// 89\nfunc PrimeFib(n int) int {\n", "import": "import (\n\t\"math\"\n)", "docstring": "// PrimeFib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> PrimeFib(1)\n// 2\n// >>> PrimeFib(2)\n// 3\n// >>> PrimeFib(3)\n// 5\n// >>> PrimeFib(4)\n// 13\n// >>> PrimeFib(5)\n// 89\n", "declaration": "\nfunc PrimeFib(n int) int {\n", "canonical_solution": "    isPrime := func(p int) bool {\n\t\tif p < 2 {\n\t\t\treturn false\n\t\t}\n\t\tfor i := 2; i < int(math.Min(math.Sqrt(float64(p))+1, float64(p-1))); i++ {\n\t\t\tif p%i == 0 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\tf := []int{0, 1}\n\tfor {\n\t\tf = append(f, f[len(f)-1]+f[len(f)-2])\n\t\tif isPrime(f[len(f)-1]) {\n\t\t\tn -= 1\n\t\t}\n\t\tif n == 0 {\n\t\t\treturn f[len(f)-1]\n\t\t}\n\t}\n}\n\n", "test": "func TestPrimeFib(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(2, PrimeFib(1))\n    assert.Equal(3, PrimeFib(2))\n    assert.Equal(5, PrimeFib(3))\n    assert.Equal(13, PrimeFib(4))\n    assert.Equal(89, PrimeFib(5))\n    assert.Equal(233, PrimeFib(6))\n    assert.Equal(1597, PrimeFib(7))\n    assert.Equal(28657, PrimeFib(8))\n    assert.Equal(514229, PrimeFib(9))\n    assert.Equal(433494437, PrimeFib(10))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestPrimeFib(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(2, PrimeFib(1))\n    assert.Equal(3, PrimeFib(2))\n    assert.Equal(5, PrimeFib(3))\n    assert.Equal(13, PrimeFib(4))\n    assert.Equal(89, PrimeFib(5))\n}\n", "prompt_text": "PrimeFib returns n-th number that is a Fibonacci number and it's also prime.", "prompt_explain": "PrimeFib returns n-th number that is a Fibonacci number and it's also prime.\n>>> PrimeFib(1)\n2\n>>> PrimeFib(2)\n3\n>>> PrimeFib(3)\n5\n>>> PrimeFib(4)\n13\n>>> PrimeFib(5)\n89\n", "func_title": "func PrimeFib(n int) int ", "prompt_text_chinese": "PrimeFib返回第n个斐波那契数，也是素数。"}
{"task_id": "Go/40", "prompt": "\n// TriplesSumToZero takes a list of integers as an input.\n// it returns true if there are three distinct elements in the list that\n// sum to zero, and false otherwise.\n// \n// >>> TriplesSumToZero([1, 3, 5, 0])\n// false\n// >>> TriplesSumToZero([1, 3, -2, 1])\n// true\n// >>> TriplesSumToZero([1, 2, 3, 7])\n// false\n// >>> TriplesSumToZero([2, 4, -5, 3, 9, 7])\n// true\n// >>> TriplesSumToZero([1])\n// false\nfunc TriplesSumToZero(l []int) bool {\n", "import": "", "docstring": "// TriplesSumToZero takes a list of integers as an input.\n// it returns true if there are three distinct elements in the list that\n// sum to zero, and false otherwise.\n// \n// >>> TriplesSumToZero([1, 3, 5, 0])\n// false\n// >>> TriplesSumToZero([1, 3, -2, 1])\n// true\n// >>> TriplesSumToZero([1, 2, 3, 7])\n// false\n// >>> TriplesSumToZero([2, 4, -5, 3, 9, 7])\n// true\n// >>> TriplesSumToZero([1])\n// false\n", "declaration": "\nfunc TriplesSumToZero(l []int) bool {\n", "canonical_solution": "    for i := 0; i < len(l) - 2; i++ {\n\t\tfor j := i + 1; j < len(l) - 1; j++ {\n\t\t\tfor k := j + 1; k < len(l); k++ {\n\t\t\t\tif l[i] + l[j] + l[k] == 0 {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\n", "test": "func TestTriplesSumToZero(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(false, TriplesSumToZero([]int{1, 3, 5, 0}))\n    assert.Equal(false, TriplesSumToZero([]int{1, 3, 5, -1}))\n    assert.Equal(true, TriplesSumToZero([]int{1, 3, -2, 1}))\n    assert.Equal(false, TriplesSumToZero([]int{1, 2, 3, 7}))\n    assert.Equal(false, TriplesSumToZero([]int{1, 2, 5, 7}))\n    assert.Equal(true, TriplesSumToZero([]int{2, 4, -5, 3, 9, 7}))\n    assert.Equal(false, TriplesSumToZero([]int{1}))\n    assert.Equal(false, TriplesSumToZero([]int{1, 3, 5, -100}))\n    assert.Equal(false, TriplesSumToZero([]int{100, 3, 5, -100}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestTriplesSumToZero(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(false, TriplesSumToZero([]int{1, 3, 5, 0}))\n    assert.Equal(true, TriplesSumToZero([]int{1, 3, -2, 1}))\n    assert.Equal(false, TriplesSumToZero([]int{1, 2, 3, 7}))\n    assert.Equal(true, TriplesSumToZero([]int{2, 4, -5, 3, 9, 7}))\n}\n", "prompt_text": "TriplesSumToZero takes a list of integers as an input. it returns true if there are three distinct elements in the list that sum to zero, and false otherwise. ", "prompt_explain": "TriplesSumToZero takes a list of integers as an input.\nit returns true if there are three distinct elements in the list that\nsum to zero, and false otherwise.\n\n>>> TriplesSumToZero([1, 3, 5, 0])\nfalse\n>>> TriplesSumToZero([1, 3, -2, 1])\ntrue\n>>> TriplesSumToZero([1, 2, 3, 7])\nfalse\n>>> TriplesSumToZero([2, 4, -5, 3, 9, 7])\ntrue\n>>> TriplesSumToZero([1])\nfalse\n", "func_title": "func TriplesSumToZero(l []int) bool ", "prompt_text_chinese": "TriplesSumToZero接受一个整数列表作为输入。如果列表中有三个不同的元素之和为0，则返回true，否则返回false。"}
{"task_id": "Go/41", "prompt": "\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// \n// This function outputs the number of such collisions.\nfunc CarRaceCollision(n int) int {\n", "import": "", "docstring": "// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// \n// This function outputs the number of such collisions.\n", "declaration": "\nfunc CarRaceCollision(n int) int {\n", "canonical_solution": "\treturn n * n\n}\n\n", "test": "func TestCarRaceCollision(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(4, CarRaceCollision(2))\n    assert.Equal(9, CarRaceCollision(3))\n    assert.Equal(16, CarRaceCollision(4))\n    assert.Equal(64, CarRaceCollision(8))\n    assert.Equal(100, CarRaceCollision(10))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "", "prompt_text": "", "prompt_explain": "Imagine a road that's a perfectly straight infinitely long line.\nn cars are driving left to right;  simultaneously, a different set of n cars\nare driving right to left.   The two sets of cars start out being very far from\neach other.  All cars move in the same speed.  Two cars are said to collide\nwhen a car that's moving left to right hits a car that's moving right to left.\nHowever, the cars are infinitely sturdy and strong; as a result, they continue moving\nin their trajectory as if they did not collide.\n\nThis function outputs the number of such collisions.\n", "func_title": "func CarRaceCollision(n int) int ", "prompt_text_chinese": "想象一条无限长的直线。N辆车从左向右行驶;同时，另一组n辆车从右向左行驶。两组车一开始相距很远。所有的汽车都以相同的速度行驶。当一辆从左向右行驶的汽车撞上一辆从右向左行驶的汽车时，两辆汽车就会相撞。然而，汽车是无限坚固和强大;结果，它们继续沿着自己的轨道运动，就好像它们没有碰撞一样。这个函数输出这种碰撞的数量。"}
{"task_id": "Go/42", "prompt": "\n// Return list with elements incremented by 1.\n// >>> IncrList([1, 2, 3])\n// [2, 3, 4]\n// >>> IncrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc IncrList(l []int) []int {\n", "import": "", "docstring": "// Return list with elements incremented by 1.\n// >>> IncrList([1, 2, 3])\n// [2, 3, 4]\n// >>> IncrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n// [6, 4, 6, 3, 4, 4, 10, 1, 124]\n", "declaration": "\nfunc IncrList(l []int) []int {\n", "canonical_solution": "    n := len(l)\n\tfor i := 0; i < n; i++ {\n\t\tl[i]++\n\t}\n\treturn l\n}\n\n", "test": "func TestIncrList(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{}, IncrList([]int{}))\n    assert.Equal([]int{4, 3, 2}, IncrList([]int{3, 2, 1}))\n    assert.Equal([]int{6, 3, 6, 3, 4, 4, 10, 1, 124}, IncrList([]int{5, 2, 5, 2, 3, 3, 9, 0, 123}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestIncrList(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{2, 3, 4}, IncrList([]int{1, 2, 3}))\n    assert.Equal([]int{6, 3, 6, 3, 4, 4, 10, 1, 124}, IncrList([]int{5, 2, 5, 2, 3, 3, 9, 0, 123}))\n}\n", "prompt_text": "Return list with elements incremented by 1.", "prompt_explain": "Return list with elements incremented by 1.\n>>> IncrList([1, 2, 3])\n[2, 3, 4]\n>>> IncrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n[6, 4, 6, 3, 4, 4, 10, 1, 124]\n", "func_title": "func IncrList(l []int) []int ", "prompt_text_chinese": "返回元素加1的列表。"}
{"task_id": "Go/43", "prompt": "\n// PairsSumToZero takes a list of integers as an input.\n// it returns true if there are two distinct elements in the list that\n// sum to zero, and false otherwise.\n// >>> PairsSumToZero([1, 3, 5, 0])\n// false\n// >>> PairsSumToZero([1, 3, -2, 1])\n// false\n// >>> PairsSumToZero([1, 2, 3, 7])\n// false\n// >>> PairsSumToZero([2, 4, -5, 3, 5, 7])\n// true\n// >>> PairsSumToZero([1])\n// false\nfunc PairsSumToZero(l []int) bool {\n", "import": "", "docstring": "// PairsSumToZero takes a list of integers as an input.\n// it returns true if there are two distinct elements in the list that\n// sum to zero, and false otherwise.\n// >>> PairsSumToZero([1, 3, 5, 0])\n// false\n// >>> PairsSumToZero([1, 3, -2, 1])\n// false\n// >>> PairsSumToZero([1, 2, 3, 7])\n// false\n// >>> PairsSumToZero([2, 4, -5, 3, 5, 7])\n// true\n// >>> PairsSumToZero([1])\n// false\n", "declaration": "\nfunc PairsSumToZero(l []int) bool {\n", "canonical_solution": "    seen := map[int]bool{}\n\tfor i := 0; i < len(l); i++ {\n\t\tfor j := i + 1; j < len(l); j++ {\n\t\t\tif l[i] + l[j] == 0 {\n\t\t\t\tif _, ok := seen[l[i]]; !ok {\n\t\t\t\t\tseen[l[i]] = true\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t\tif _, ok := seen[l[j]]; !ok {\n\t\t\t\t\tseen[l[j]] = true\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\n", "test": "func TestPairsSumToZero(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(false, PairsSumToZero([]int{1, 3, 5, 0}))\n    assert.Equal(false, PairsSumToZero([]int{1, 3, -2, 1}))\n    assert.Equal(false, PairsSumToZero([]int{1, 2, 3, 7}))\n    assert.Equal(true, PairsSumToZero([]int{2, 4, -5, 3, 5, 7}))\n    assert.Equal(false, PairsSumToZero([]int{1}))\n    assert.Equal(true, PairsSumToZero([]int{-3, 9, -1, 3, 2, 30}))\n    assert.Equal(true, PairsSumToZero([]int{-3, 9, -1, 3, 2, 31}))\n    assert.Equal(false, PairsSumToZero([]int{-3, 9, -1, 4, 2, 30}))\n    assert.Equal(false, PairsSumToZero([]int{-3, 9, -1, 4, 2, 31}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestPairsSumToZero(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(false, PairsSumToZero([]int{1, 3, 5, 0}))\n    assert.Equal(false, PairsSumToZero([]int{1, 3, -2, 1}))\n    assert.Equal(false, PairsSumToZero([]int{1, 2, 3, 7}))\n    assert.Equal(true, PairsSumToZero([]int{2, 4, -5, 3, 5, 7}))\n}\n", "prompt_text": "PairsSumToZero takes a list of integers as an input. it returns true if there are two distinct elements in the list that sum to zero, and false otherwise.", "prompt_explain": "PairsSumToZero takes a list of integers as an input.\nit returns true if there are two distinct elements in the list that\nsum to zero, and false otherwise.\n>>> PairsSumToZero([1, 3, 5, 0])\nfalse\n>>> PairsSumToZero([1, 3, -2, 1])\nfalse\n>>> PairsSumToZero([1, 2, 3, 7])\nfalse\n>>> PairsSumToZero([2, 4, -5, 3, 5, 7])\ntrue\n>>> PairsSumToZero([1])\nfalse\n", "func_title": "func PairsSumToZero(l []int) bool ", "prompt_text_chinese": "PairsSumToZero接受一个整数列表作为输入。如果列表中有两个不同的元素之和为0，则返回true，否则返回false。"}
{"task_id": "Go/44", "prompt": "import (\n    \"strconv\"\n)\n\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> ChangeBase(8, 3)\n// '22'\n// >>> ChangeBase(8, 2)\n// '1000'\n// >>> ChangeBase(7, 2)\n// '111'\nfunc ChangeBase(x int, base int) string {\n", "import": "import (\n    \"strconv\"\n)\n", "docstring": "// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> ChangeBase(8, 3)\n// '22'\n// >>> ChangeBase(8, 2)\n// '1000'\n// >>> ChangeBase(7, 2)\n// '111'\n", "declaration": "\nfunc ChangeBase(x int, base int) string {\n", "canonical_solution": "    if x >= base {\n        return ChangeBase(x/base, base) + ChangeBase(x%base, base)\n    }\n    return strconv.Itoa(x)\n}\n\n", "test": "func TestChangeBase(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"22\", ChangeBase(8, 3))\n    assert.Equal(\"100\", ChangeBase(9, 3))\n    assert.Equal(\"11101010\", ChangeBase(234, 2))\n    assert.Equal(\"10000\", ChangeBase(16, 2))\n    assert.Equal(\"1000\", ChangeBase(8, 2))\n    assert.Equal(\"111\", ChangeBase(7, 2))\n    for i := 2; i < 8; i++ {\n        assert.Equal(strconv.Itoa(i), ChangeBase(i, i+1))\n    }\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestChangeBase(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"22\", ChangeBase(8, 3))\n    assert.Equal(\"1000\", ChangeBase(8, 2))\n    assert.Equal(\"111\", ChangeBase(7, 2))\n}\n", "prompt_text": "Change numerical base of input number x to base. return string representation after the conversion. base numbers are less than 10.", "prompt_explain": "Change numerical base of input number x to base.\nreturn string representation after the conversion.\nbase numbers are less than 10.\n>>> ChangeBase(8, 3)\n'22'\n>>> ChangeBase(8, 2)\n'1000'\n>>> ChangeBase(7, 2)\n'111'\n", "func_title": "func ChangeBase(x int, base int) string ", "prompt_text_chinese": "将输入数字x的基数改为基数。转换后返回字符串表示形式。基数小于10。"}
{"task_id": "Go/45", "prompt": "\n// Given length of a side and high return area for a triangle.\n// >>> TriangleArea(5, 3)\n// 7.5\nfunc TriangleArea(a float64, h float64) float64 {\n", "import": "", "docstring": "// Given length of a side and high return area for a triangle.\n// >>> TriangleArea(5, 3)\n// 7.5\n", "declaration": "\nfunc TriangleArea(a float64, h float64) float64 {\n", "canonical_solution": "    return a * h / 2\n}\n\n", "test": "func TestTriangleArea(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(7.5, TriangleArea(5, 3))\n    assert.Equal(2.0, TriangleArea(2, 2))\n    assert.Equal(40.0, TriangleArea(10, 8))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestTriangleArea(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(7.5, TriangleArea(5, 3))\n}\n", "prompt_text": "Given length of a side and high return area for a triangle.", "prompt_explain": "Given length of a side and high return area for a triangle.\n>>> TriangleArea(5, 3)\n7.5\n", "func_title": "func TriangleArea(a float64, h float64) float64 ", "prompt_text_chinese": "给定三角形的边长和高返回面积"}
{"task_id": "Go/46", "prompt": "\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// Fib4(0) -> 0\n// Fib4(1) -> 0\n// Fib4(2) -> 2\n// Fib4(3) -> 0\n// Fib4(n) -> Fib4(n-1) + Fib4(n-2) + Fib4(n-3) + Fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the Fib4 number sequence.  Do not use recursion.\n// >>> Fib4(5)\n// 4\n// >>> Fib4(6)\n// 8\n// >>> Fib4(7)\n// 14\nfunc Fib4(n int) int {\n", "import": "", "docstring": "// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// Fib4(0) -> 0\n// Fib4(1) -> 0\n// Fib4(2) -> 2\n// Fib4(3) -> 0\n// Fib4(n) -> Fib4(n-1) + Fib4(n-2) + Fib4(n-3) + Fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the Fib4 number sequence.  Do not use recursion.\n// >>> Fib4(5)\n// 4\n// >>> Fib4(6)\n// 8\n// >>> Fib4(7)\n// 14\n", "declaration": "\nfunc Fib4(n int) int {\n", "canonical_solution": "    switch n {\n\tcase 0:\n\t\treturn 0\n\tcase 1:\n\t\treturn 0\n\tcase 2:\n\t\treturn 2\n\tcase 3:\n\t\treturn 0\n\tdefault:\n\t\treturn Fib4(n-1) + Fib4(n-2) + Fib4(n-3) + Fib4(n-4)\n\t}\n}\n\n", "test": "func TestFib4(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(4, Fib4(5))\n    assert.Equal(28, Fib4(8))\n    assert.Equal(104, Fib4(10))\n    assert.Equal(386, Fib4(12))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestFib4(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(4, Fib4(5))\n    assert.Equal(8, Fib4(6))\n    assert.Equal(14, Fib4(7))\n}\n", "prompt_text": "The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows: Fib4(0) -> 0 Fib4(1) -> 0 Fib4(2) -> 2 Fib4(3) -> 0 Fib4(n) -> Fib4(n-1) + Fib4(n-2) + Fib4(n-3) + Fib4(n-4). Please write a function to efficiently compute the n-th element of the Fib4 number sequence.  Do not use recursion.", "prompt_explain": "The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\nFib4(0) -> 0\nFib4(1) -> 0\nFib4(2) -> 2\nFib4(3) -> 0\nFib4(n) -> Fib4(n-1) + Fib4(n-2) + Fib4(n-3) + Fib4(n-4).\nPlease write a function to efficiently compute the n-th element of the Fib4 number sequence.  Do not use recursion.\n>>> Fib4(5)\n4\n>>> Fib4(6)\n8\n>>> Fib4(7)\n14\n", "func_title": "func Fib4(n int) int ", "prompt_text_chinese": "Fib4数列是一个类似于斐波那契数列的数列，定义如下:Fib4(0) -> 0  Fib4(1) -> 0  Fib4(2) -> 2  Fib4(3) -> 0  Fib4(n) -> Fib4(n-1) + Fib4(n-2) + Fib4(n-3) + Fib4(n-4).请编写一个函数来有效地计算Fib4数列的第n个元素。不要使用递归。"}
{"task_id": "Go/47", "prompt": "import (\n\t\"sort\"\n)\n\n// Return Median of elements in the list l.\n// >>> Median([3, 1, 2, 4, 5])\n// 3.0\n// >>> Median([-10, 4, 6, 1000, 10, 20])\n// 15.0\nfunc Median(l []int) float64 {\n", "import": "import (\n\t\"sort\"\n)", "docstring": "// Return Median of elements in the list l.\n// >>> Median([3, 1, 2, 4, 5])\n// 3\n// >>> Median([-10, 4, 6, 1000, 10, 20])\n// 15.0\n", "declaration": "\nfunc Median(l []int) float64 {\n", "canonical_solution": "    sort.Ints(l)\n\tif len(l)%2==1{\n\t\treturn float64(l[len(l)/2])\n\t}else{\n\t\treturn float64(l[len(l)/2-1]+l[len(l)/2])/2.0\n\t}\n}\n\n", "test": "func TestMedian(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(3.0, Median([]int{3, 1, 2, 4, 5}))\n\tassert.Equal(8.0, Median([]int{-10, 4, 6, 1000, 10, 20}))\n\tassert.Equal(5.0, Median([]int{5}))\n\tassert.Equal(5.5, Median([]int{6, 5}))\n\tassert.Equal(7.0, Median([]int{8, 1, 3, 9, 9, 2, 7}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestMedian(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(3.0, Median([]int{3, 1, 2, 4, 5}))\n\tassert.Equal(8.0, Median([]int{-10, 4, 6, 1000, 10, 20}))\n}\n", "prompt_text": "Return Median of elements in the list l.", "prompt_explain": "Return Median of elements in the list l.\n>>> Median([3, 1, 2, 4, 5])\n3\n>>> Median([-10, 4, 6, 1000, 10, 20])\n15.0\n", "func_title": "func Median(l []int) float64 ", "prompt_text_chinese": "返回列表l中元素的中值"}
{"task_id": "Go/48", "prompt": "\n// Checks if given string is a palindrome\n// >>> IsPalindrome('')\n// true\n// >>> IsPalindrome('aba')\n// true\n// >>> IsPalindrome('aaaaa')\n// true\n// >>> IsPalindrome('zbcd')\n// false\nfunc IsPalindrome(text string) bool {\n", "import": "", "docstring": "// Checks if given string is a palindrome\n// >>> IsPalindrome('')\n// true\n// >>> IsPalindrome('aba')\n// true\n// >>> IsPalindrome('aaaaa')\n// true\n// >>> IsPalindrome('zbcd')\n// false\n", "declaration": "\nfunc IsPalindrome(text string) bool {\n", "canonical_solution": "    runes := []rune(text)\n    result := make([]rune, 0)\n    for i := len(runes) - 1; i >= 0; i-- {\n        result = append(result, runes[i])\n    }\n    return text == string(result)\n}\n\n", "test": "func TestIsPalindrome(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, IsPalindrome(\"\"))\n    assert.Equal(true, IsPalindrome(\"aba\"))\n    assert.Equal(true, IsPalindrome(\"aaaaa\"))\n    assert.Equal(false, IsPalindrome(\"zbcd\"))\n    assert.Equal(true, IsPalindrome(\"xywyx\"))\n    assert.Equal(false, IsPalindrome(\"xywyz\"))\n    assert.Equal(false, IsPalindrome(\"xywzx\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestIsPalindrome(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, IsPalindrome(\"\"))\n    assert.Equal(true, IsPalindrome(\"aba\"))\n    assert.Equal(true, IsPalindrome(\"aaaaa\"))\n    assert.Equal(false, IsPalindrome(\"zbcd\"))\n}\n", "prompt_text": "Checks if given string is a palindrome", "prompt_explain": "Checks if given string is a palindrome\n>>> IsPalindrome('')\ntrue\n>>> IsPalindrome('aba')\ntrue\n>>> IsPalindrome('aaaaa')\ntrue\n>>> IsPalindrome('zbcd')\nfalse\n", "func_title": "func IsPalindrome(text string) bool ", "prompt_text_chinese": "检查给定的字符串是否为回文"}
{"task_id": "Go/49", "prompt": "\n// Return 2^n modulo p (be aware of numerics).\n// >>> Modp(3, 5)\n// 3\n// >>> Modp(1101, 101)\n// 2\n// >>> Modp(0, 101)\n// 1\n// >>> Modp(3, 11)\n// 8\n// >>> Modp(100, 101)\n// 1\nfunc Modp(n int,p int) int {\n", "import": "", "docstring": "// Return 2^n modulo p (be aware of numerics).\n// >>> Modp(3, 5)\n// 3\n// >>> Modp(1101, 101)\n// 2\n// >>> Modp(0, 101)\n// 1\n// >>> Modp(3, 11)\n// 8\n// >>> Modp(100, 101)\n// 1\n", "declaration": "\nfunc Modp(n int,p int) int {\n", "canonical_solution": "    ret := 1\n    for i:= 0; i < n; i++ {\n\t\tret = (2 * ret) % p\n\t}\n    return ret\n}\n\n", "test": "func TestModp(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(3, Modp(3, 5))\n    assert.Equal(2, Modp(1101, 101))\n    assert.Equal(1, Modp(0, 101))\n    assert.Equal(8, Modp(3, 11))\n    assert.Equal(1, Modp(100, 101))\n    assert.Equal(4, Modp(30, 5))\n    assert.Equal(3, Modp(31, 5))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestModp(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(3, Modp(3, 5))\n    assert.Equal(2, Modp(1101, 101))\n    assert.Equal(1, Modp(0, 101))\n    assert.Equal(8, Modp(3, 11))\n    assert.Equal(1, Modp(100, 101))\n}\n", "prompt_text": "Return 2^n modulo p (be aware of numerics).", "prompt_explain": "Return 2^n modulo p (be aware of numerics).\n>>> Modp(3, 5)\n3\n>>> Modp(1101, 101)\n2\n>>> Modp(0, 101)\n1\n>>> Modp(3, 11)\n8\n>>> Modp(100, 101)\n1\n", "func_title": "func Modp(n int,p int) int ", "prompt_text_chinese": "返回2^n模p(注意数字)"}
{"task_id": "Go/50", "prompt": "// returns encoded string by shifting every character by 5 in the alphabet.\nfunc EncodeShift(s string) string {\n    runes := []rune(s)\n    newRunes := make([]rune, 0)\n    for _, ch := range runes {\n        newRunes = append(newRunes, (ch+5-'a')%26+'a')\n    }\n    return string(runes)\n}\n\n// takes as input string encoded with EncodeShift function. Returns decoded string.\nfunc DecodeShift(s string) string {\n", "import": "", "docstring": "// returns encoded string by shifting every character by 5 in the alphabet.\n// takes as input string encoded with encode_shift function. Returns decoded string.\n", "declaration": "\nfunc DecodeShift(s string) string {\n", "canonical_solution": "    runes := []rune(s)\n    newRunes := make([]rune, 0)\n    for _, ch := range runes {\n        newRunes = append(newRunes, (ch-5-'a')%26+'a')\n    }\n    return string(runes)\n}\n\n", "test": "func TestDecodeShift(t *testing.T) {\n    assert := assert.New(t)\n    randInt := func(min, max int) int {\n        rng := rand.New(rand.NewSource(time.Now().UnixNano()))\n        if min >= max || min == 0 || max == 0 {\n            return max\n        }\n        return rng.Intn(max-min) + min\n    }\n    for i := 0; i <100 ; i++ {\n        runes := make([]rune, 0)\n        for j := 0; j < randInt(10,20); j++ {\n            runes = append(runes, int32(randInt('a','z')))\n        }\n        encoded_str := EncodeShift(string(runes))\n        assert.Equal(DecodeShift(encoded_str), string(runes))\n    }\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"math/rand\"\n    \"time\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "", "prompt_text": "", "prompt_explain": "returns encoded string by shifting every character by 5 in the alphabet.\ntakes as input string encoded with encode_shift function. Returns decoded string.\n", "func_title": "func DecodeShift(s string) string ", "prompt_text_chinese": "通过将字母表中的每个字符移动5来返回编码后的字符串。接受用encode_shift函数编码的输入字符串。返回解码后的字符串"}
{"task_id": "Go/51", "prompt": "import (\n    \"regexp\"\n)\n\n// RemoveVowels is a function that takes string and returns string without vowels.\n// >>> RemoveVowels('')\n// ''\n// >>> RemoveVowels(\"abcdef\\nghijklm\")\n// 'bcdf\\nghjklm'\n// >>> RemoveVowels('abcdef')\n// 'bcdf'\n// >>> RemoveVowels('aaaaa')\n// ''\n// >>> RemoveVowels('aaBAA')\n// 'B'\n// >>> RemoveVowels('zbcd')\n// 'zbcd'\nfunc RemoveVowels(text string) string {\n", "import": "import (\n    \"regexp\"\n)", "docstring": "// RemoveVowels is a function that takes string and returns string without vowels.\n// >>> RemoveVowels('')\n// ''\n// >>> RemoveVowels(\"abcdef\\nghijklm\")\n// 'bcdf\\nghjklm'\n// >>> RemoveVowels('abcdef')\n// 'bcdf'\n// >>> RemoveVowels('aaaaa')\n// ''\n// >>> RemoveVowels('aaBAA')\n// 'B'\n// >>> RemoveVowels('zbcd')\n// 'zbcd'\n", "declaration": "\nfunc RemoveVowels(text string) string {\n    ", "canonical_solution": "    var re = regexp.MustCompile(\"[aeiouAEIOU]\")\n\ttext = re.ReplaceAllString(text, \"\")\n\treturn text\n}\n\n", "test": "func TestRemoveVowels(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"\", RemoveVowels(\"\"))\n    assert.Equal(\"bcdf\\nghjklm\", RemoveVowels(\"abcdef\\nghijklm\"))\n    assert.Equal(\"fdcb\", RemoveVowels(\"fedcba\"))\n    assert.Equal(\"\", RemoveVowels(\"eeeee\"))\n    assert.Equal(\"cB\", RemoveVowels(\"acBAA\"))\n    assert.Equal(\"cB\", RemoveVowels(\"EcBOO\"))\n    assert.Equal(\"ybcd\", RemoveVowels(\"ybcd\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestRemoveVowels(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"\", RemoveVowels(\"\"))\n    assert.Equal(\"bcdf\\nghjklm\", RemoveVowels(\"abcdef\\nghijklm\"))\n    assert.Equal(\"bcdf\", RemoveVowels(\"abcdef\"))\n    assert.Equal(\"\", RemoveVowels(\"aaaaa\"))\n    assert.Equal(\"B\", RemoveVowels(\"aaBAA\"))\n    assert.Equal(\"zbcd\", RemoveVowels(\"zbcd\"))\n}\n", "prompt_text": "RemoveVowels is a function that takes string and returns string without vowels.", "prompt_explain": "RemoveVowels is a function that takes string and returns string without vowels.\n>>> RemoveVowels('')\n''\n>>> RemoveVowels(\"abcdef\\nghijklm\")\n'bcdf\\nghjklm'\n>>> RemoveVowels('abcdef')\n'bcdf'\n>>> RemoveVowels('aaaaa')\n''\n>>> RemoveVowels('aaBAA')\n'B'\n>>> RemoveVowels('zbcd')\n'zbcd'\n", "func_title": "func RemoveVowels(text string) string ", "prompt_text_chinese": "RemoveVowels是一个接受字符串并返回不带元音的字符串的函数"}
{"task_id": "Go/52", "prompt": "\n// Return true if all numbers in the list l are below threshold t.\n// >>> BelowThreshold([1, 2, 4, 10], 100)\n// true\n// >>> BelowThreshold([1, 20, 4, 10], 5)\n// false\nfunc BelowThreshold(l []int,t int) bool {\n", "import": "", "docstring": "// Return true if all numbers in the list l are below threshold t.\n// >>> BelowThreshold([1, 2, 4, 10], 100)\n// true\n// >>> BelowThreshold([1, 20, 4, 10], 5)\n// false\n", "declaration": "\nfunc BelowThreshold(l []int,t int) bool {\n", "canonical_solution": "    for _, n := range l {\n\t\tif n >= t {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n", "test": "func TestBelowThreshold(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, BelowThreshold([]int{1, 2, 4, 10}, 100))\n    assert.Equal(false, BelowThreshold([]int{1, 20, 4, 10}, 5))\n    assert.Equal(true, BelowThreshold([]int{1, 20, 4, 10}, 21))\n    assert.Equal(true, BelowThreshold([]int{1, 20, 4, 10}, 22))\n    assert.Equal(true, BelowThreshold([]int{1, 8, 4, 10}, 11))\n    assert.Equal(false, BelowThreshold([]int{1, 8, 4, 10}, 10))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestBelowThreshold(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, BelowThreshold([]int{1, 2, 4, 10}, 100))\n    assert.Equal(false, BelowThreshold([]int{1, 20, 4, 10}, 5))\n}\n", "prompt_text": "Return true if all numbers in the list l are below threshold t.", "prompt_explain": "Return true if all numbers in the list l are below threshold t.\n>>> BelowThreshold([1, 2, 4, 10], 100)\ntrue\n>>> BelowThreshold([1, 20, 4, 10], 5)\nfalse\n", "func_title": "func BelowThreshold(l []int,t int) bool ", "prompt_text_chinese": "如果列表l中的所有数字都低于阈值t，则返回true。"}
{"task_id": "Go/53", "prompt": "\n// Add two numbers x and y\n// >>> Add(2, 3)\n// 5\n// >>> Add(5, 7)\n// 12\nfunc Add(x int, y int) int {\n", "import": "", "docstring": "// Add two numbers x and y\n// >>> Add(2, 3)\n// 5\n// >>> Add(5, 7)\n// 12\n", "declaration": "\nfunc Add(x int, y int) int {\n", "canonical_solution": "    return x + y\n}\n\n", "test": "func TestAdd(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(1, Add(0, 1))\n    assert.Equal(1, Add(1, 0))\n    assert.Equal(5, Add(2, 3))\n    assert.Equal(12, Add(5, 7))\n    assert.Equal(12, Add(7, 5))\n    for i := 0; i < 100; i++ {\n        x := rand.Int31n(1000)\n        y := rand.Int31n(1000)\n        assert.Equal(int(x+y), Add(int(x), int(y)))\n    }\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"math/rand\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestAdd(t *testing.T) {\n   assert := assert.New(t)\n   assert.Equal(5, Add(2, 3+rand.Intn(1000)*0))\n    assert.Equal(12, Add(5, 7))\n}\n", "prompt_text": "Add two numbers x and y", "prompt_explain": "Add two numbers x and y\n>>> Add(2, 3)\n5\n>>> Add(5, 7)\n12\n", "func_title": "func Add(x int, y int) int ", "prompt_text_chinese": "把x和y两个数相加"}
{"task_id": "Go/54", "prompt": "\n// Check if two words have the same characters.\n// >>> SameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n// true\n// >>> SameChars('abcd', 'dddddddabc')\n// true\n// >>> SameChars('dddddddabc', 'abcd')\n// true\n// >>> SameChars('eabcd', 'dddddddabc')\n// false\n// >>> SameChars('abcd', 'dddddddabce')\n// false\n// >>> SameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n// false\nfunc SameChars(s0 string, s1 string) bool {\n", "import": "", "docstring": "// Check if two words have the same characters.\n// >>> SameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n// true\n// >>> SameChars('abcd', 'dddddddabc')\n// true\n// >>> SameChars('dddddddabc', 'abcd')\n// true\n// >>> SameChars('eabcd', 'dddddddabc')\n// false\n// >>> SameChars('abcd', 'dddddddabce')\n// false\n// >>> SameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n// false\n", "declaration": "\nfunc SameChars(s0 string, s1 string) bool {\n", "canonical_solution": "    set0 := make(map[int32]interface{})\n\tset1 := make(map[int32]interface{})\n\tfor _, i := range s0 {\n\t\tset0[i] = nil\n\t}\n\tfor _, i := range s1 {\n\t\tset1[i] = nil\n\t}\n\tfor i, _ := range set0 {\n\t\tif _,ok:=set1[i];!ok{\n\t\t\treturn false\n\t\t}\n\t}\n\tfor i, _ := range set1 {\n\t\tif _,ok:=set0[i];!ok{\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n", "test": "func TestSameChars(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, SameChars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\"))\n    assert.Equal(true, SameChars(\"abcd\", \"dddddddabc\"))\n    assert.Equal(true, SameChars(\"dddddddabc\", \"abcd\"))\n    assert.Equal(false, SameChars(\"eabcd\", \"dddddddabc\"))\n    assert.Equal(false, SameChars(\"abcd\", \"dddddddabcf\"))\n    assert.Equal(false, SameChars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"))\n    assert.Equal(false, SameChars(\"aabb\", \"aaccc\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSameChars(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, SameChars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\"))\n    assert.Equal(true, SameChars(\"abcd\", \"dddddddabc\"))\n    assert.Equal(true, SameChars(\"dddddddabc\", \"abcd\"))\n    assert.Equal(false, SameChars(\"eabcd\", \"dddddddabc\"))\n    assert.Equal(false, SameChars(\"abcd\", \"dddddddabcf\"))\n    assert.Equal(false, SameChars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"))\n}\n", "prompt_text": "Check if two words have the same characters.", "prompt_explain": "Check if two words have the same characters.\n>>> SameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\ntrue\n>>> SameChars('abcd', 'dddddddabc')\ntrue\n>>> SameChars('dddddddabc', 'abcd')\ntrue\n>>> SameChars('eabcd', 'dddddddabc')\nfalse\n>>> SameChars('abcd', 'dddddddabce')\nfalse\n>>> SameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\nfalse\n", "func_title": "func SameChars(s0 string, s1 string) bool ", "prompt_text_chinese": "检查两个单词是否有相同的字符"}
{"task_id": "Go/55", "prompt": "\n// Return n-th Fibonacci number.\n// >>> Fib(10)\n// 55\n// >>> Fib(1)\n// 1\n// >>> Fib(8)\n// 21\nfunc Fib(n int) int {\n", "import": "", "docstring": "// Return n-th Fibonacci number.\n// >>> Fib(10)\n// 55\n// >>> Fib(1)\n// 1\n// >>> Fib(8)\n// 21\n", "declaration": "\nfunc Fib(n int) int {\n", "canonical_solution": "    if n <= 1 {\n\t\treturn n\n\t}\n\treturn Fib(n-1) + Fib(n-2)\n}\n\n", "test": "func TestFib(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(55, Fib(10))\n    assert.Equal(1, Fib(1))\n    assert.Equal(21, Fib(8))\n    assert.Equal(89, Fib(11))\n    assert.Equal(144, Fib(12))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestFib(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(55, Fib(10))\n    assert.Equal(1, Fib(1))\n    assert.Equal(21, Fib(8))\n}\n", "prompt_text": "Return n-th Fibonacci number.", "prompt_explain": "Return n-th Fibonacci number.\n>>> Fib(10)\n55\n>>> Fib(1)\n1\n>>> Fib(8)\n21\n", "func_title": "func Fib(n int) int ", "prompt_text_chinese": "返回第n个斐波那契数"}
{"task_id": "Go/56", "prompt": "\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// \n// >>> CorrectBracketing(\"<\")\n// false\n// >>> CorrectBracketing(\"<>\")\n// true\n// >>> CorrectBracketing(\"<<><>>\")\n// true\n// >>> CorrectBracketing(\"><<>\")\n// false\nfunc CorrectBracketing(brackets string) bool {\n", "import": "", "docstring": "// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// \n// >>> CorrectBracketing(\"<\")\n// false\n// >>> CorrectBracketing(\"<>\")\n// true\n// >>> CorrectBracketing(\"<<><>>\")\n// true\n// >>> CorrectBracketing(\"><<>\")\n// false\n", "declaration": "\nfunc CorrectBracketing(brackets string) bool {\n", "canonical_solution": "    l := len(brackets)\n\tcount := 0\n\tfor index := 0; index < l; index++ {\n\t\tif brackets[index] == '<' {\n\t\t\tcount++\n\t\t} else if brackets[index] == '>' {\n\t\t\tcount--\n\t\t}\n\t\tif count < 0 {\n\t\t\treturn false\n\t\t}\n\t}\n    if count == 0 {\n        return true\n    } else {\n        return false\n    }\n}\n\n", "test": "func TestCorrectBracketing(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, CorrectBracketing(\"<>\"))\n    assert.Equal(true, CorrectBracketing(\"<<><>>\"))\n    assert.Equal(true, CorrectBracketing(\"<><><<><>><>\"))\n    assert.Equal(true, CorrectBracketing(\"<><><<<><><>><>><<><><<>>>\"))\n    assert.Equal(false, CorrectBracketing(\"<<<><>>>>\"))\n    assert.Equal(false, CorrectBracketing(\"><<>\"))\n    assert.Equal(false, CorrectBracketing(\"<\"))\n    assert.Equal(false, CorrectBracketing(\"<<<<\"))\n    assert.Equal(false, CorrectBracketing(\">\"))\n    assert.Equal(false, CorrectBracketing(\"<<>\"))\n    assert.Equal(false, CorrectBracketing(\"<><><<><>><>><<>\"))\n    assert.Equal(false, CorrectBracketing(\"<><><<><>><>>><>\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestCorrectBracketing(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, CorrectBracketing(\"<>\"))\n    assert.Equal(true, CorrectBracketing(\"<<><>>\"))\n    assert.Equal(false, CorrectBracketing(\"><<>\"))\n    assert.Equal(false, CorrectBracketing(\"<\"))\n}\n", "prompt_text": "brackets is a string of \"<\" and \">\". return true if every opening bracket has a corresponding closing bracket. ", "prompt_explain": "brackets is a string of \"<\" and \">\".\nreturn true if every opening bracket has a corresponding closing bracket.\n\n>>> CorrectBracketing(\"<\")\nfalse\n>>> CorrectBracketing(\"<>\")\ntrue\n>>> CorrectBracketing(\"<<><>>\")\ntrue\n>>> CorrectBracketing(\"><<>\")\nfalse\n", "func_title": "func CorrectBracketing(brackets string) bool ", "prompt_text_chinese": "括号是由\"<\"和\">\"组成的字符串。如果每个左括号都有对应的右括号，则返回true。"}
{"task_id": "Go/57", "prompt": "\n// Return true is list elements are Monotonically increasing or decreasing.\n// >>> Monotonic([1, 2, 4, 20])\n// true\n// >>> Monotonic([1, 20, 4, 10])\n// false\n// >>> Monotonic([4, 1, 0, -10])\n// true\nfunc Monotonic(l []int) bool {\n", "import": "", "docstring": "// Return true is list elements are Monotonically increasing or decreasing.\n// >>> Monotonic([1, 2, 4, 20])\n// true\n// >>> Monotonic([1, 20, 4, 10])\n// false\n// >>> Monotonic([4, 1, 0, -10])\n// true\n", "declaration": "\nfunc Monotonic(l []int) bool {\n", "canonical_solution": "    flag := true\n\tif len(l) > 1 {\n\t\tfor i := 0; i < len(l)-1; i++ {\n\t\t\tif l[i] != l[i+1] {\n\t\t\t\tflag = l[i] > l[i+1]\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t} else {\n\t\treturn false\n\t}\n\tfor i := 0; i < len(l)-1; i++ {\n\t\tif flag != (l[i] >= l[i+1]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n", "test": "func TestMonotonic(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, Monotonic([]int{1, 2, 4, 10}))\n    assert.Equal(true, Monotonic([]int{1, 2, 4, 20}))\n    assert.Equal(false, Monotonic([]int{1, 20, 4, 10}))\n    assert.Equal(true, Monotonic([]int{4, 1, 0, -10}))\n    assert.Equal(true, Monotonic([]int{4, 1, 1, 0}))\n    assert.Equal(false, Monotonic([]int{1, 2, 3, 2, 5, 60}))\n    assert.Equal(true, Monotonic([]int{1, 2, 3, 4, 5, 60}))\n    assert.Equal(true, Monotonic([]int{9, 9, 9, 9}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestMonotonic(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, Monotonic([]int{1, 2, 4, 10}))\n    assert.Equal(false, Monotonic([]int{1, 20, 4, 10}))\n    assert.Equal(true, Monotonic([]int{4, 1, 0, -10}))\n}\n", "prompt_text": "Return true is list elements are Monotonically increasing or decreasing.", "prompt_explain": "Return true is list elements are Monotonically increasing or decreasing.\n>>> Monotonic([1, 2, 4, 20])\ntrue\n>>> Monotonic([1, 20, 4, 10])\nfalse\n>>> Monotonic([4, 1, 0, -10])\ntrue\n", "func_title": "func Monotonic(l []int) bool ", "prompt_text_chinese": "当列表元素是单调递增或递减时返回true"}
{"task_id": "Go/58", "prompt": "import (\n    \"sort\"\n)\n\n// Return sorted unique Common elements for two lists.\n// >>> Common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> Common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nfunc Common(l1 []int,l2 []int) []int {\n", "import": "import (\n    \"sort\"\n)", "docstring": "// Return sorted unique Common elements for two lists.\n// >>> Common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> Common([5, 3, 2, 8], [3, 2])\n// [2, 3]\n", "declaration": "\nfunc Common(l1 []int,l2 []int) []int {\n", "canonical_solution": "    m := make(map[int]bool)\n\tfor _, e1 := range l1 {\n\t\tif m[e1] {\n\t\t\tcontinue\n\t\t}\n\t\tfor _, e2 := range l2 {\n\t\t\tif e1 == e2 {\n\t\t\t\tm[e1] = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\tres := make([]int, 0, len(m))\n\tfor k, _ := range m {\n\t\tres = append(res, k)\n\t}\n\tsort.Ints(res)\n\treturn res\n}\n\n", "test": "func TestCommon(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{1, 5, 653}, Common([]int{1, 4, 3, 34, 653, 2, 5}, []int{5, 7, 1, 5, 9, 653, 121}))\n    assert.Equal([]int{2, 3}, Common([]int{5, 3, 2, 8}, []int{3, 2}))\n    assert.Equal([]int{2, 3, 4}, Common([]int{4, 3, 2, 8}, []int{3, 2, 4}))\n    assert.Equal([]int{}, Common([]int{4, 3, 2, 8}, []int{}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestCommon(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{1, 5, 653}, Common([]int{1, 4, 3, 34, 653, 2, 5}, []int{5, 7, 1, 5, 9, 653, 121}))\n    assert.Equal([]int{2, 3}, Common([]int{5, 3, 2, 8}, []int{3, 2}))\n}\n", "prompt_text": "Return sorted unique Common elements for two lists.", "prompt_explain": "Return sorted unique Common elements for two lists.\n>>> Common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n[1, 5, 653]\n>>> Common([5, 3, 2, 8], [3, 2])\n[2, 3]\n", "func_title": "func Common(l1 []int,l2 []int) []int ", "prompt_text_chinese": "为两个列表返回排序的唯一Common元素"}
{"task_id": "Go/59", "prompt": "\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> LargestPrimeFactor(13195)\n// 29\n// >>> LargestPrimeFactor(2048)\n// 2\nfunc LargestPrimeFactor(n int) int {\n", "import": "", "docstring": "// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> LargestPrimeFactor(13195)\n// 29\n// >>> LargestPrimeFactor(2048)\n// 2\n", "declaration": "\nfunc LargestPrimeFactor(n int) int {\n", "canonical_solution": "    isPrime := func(n int) bool {\n        for i := 2; i < int(math.Pow(float64(n), 0.5)+1); i++ {\n            if n%i == 0 {\n                return false\n            }\n        }\n        return true\n    }\n\n    largest := 1\n    for j := 2; j < n + 1; j++ {\n\t\tif n % j == 0 && isPrime(j) {\n\t\t\tif j > largest {\n\t\t\t\tlargest = j\n\t\t\t}\n\t\t}\n\t}\n    return largest\n}\n\n", "test": "func TestLargestPrimeFactor(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(5, LargestPrimeFactor(15))\n    assert.Equal(3, LargestPrimeFactor(27))\n    assert.Equal(7, LargestPrimeFactor(63))\n    assert.Equal(11, LargestPrimeFactor(330))\n    assert.Equal(29, LargestPrimeFactor(13195))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestLargestPrimeFactor(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(2, LargestPrimeFactor(2048))\n    assert.Equal(29, LargestPrimeFactor(13195))\n}\n", "prompt_text": "Return the largest prime factor of n. Assume n > 1 and is not a prime.", "prompt_explain": "Return the largest prime factor of n. Assume n > 1 and is not a prime.\n>>> LargestPrimeFactor(13195)\n29\n>>> LargestPrimeFactor(2048)\n2\n", "func_title": "func LargestPrimeFactor(n int) int ", "prompt_text_chinese": "返回n的最大素数因子。假设n > 1不是素数"}
{"task_id": "Go/60", "prompt": "\n// SumToN is a function that sums numbers from 1 to n.\n// >>> SumToN(30)\n// 465\n// >>> SumToN(100)\n// 5050\n// >>> SumToN(5)\n// 15\n// >>> SumToN(10)\n// 55\n// >>> SumToN(1)\n// 1\nfunc SumToN(n int) int {\n", "import": "", "docstring": "// SumToN is a function that sums numbers from 1 to n.\n// >>> SumToN(30)\n// 465\n// >>> SumToN(100)\n// 5050\n// >>> SumToN(5)\n// 15\n// >>> SumToN(10)\n// 55\n// >>> SumToN(1)\n// 1\n", "declaration": "\nfunc SumToN(n int) int {\n", "canonical_solution": "    if n <= 0 {\n\t\treturn 0\n\t} else {\n\t\treturn n + SumToN(n - 1)\n\t}\n}\n\n", "test": "func TestSumToN(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(1, SumToN(1))\n    assert.Equal(21, SumToN(6))\n    assert.Equal(66, SumToN(11))\n    assert.Equal(465, SumToN(30))\n    assert.Equal(5050, SumToN(100))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSumToN(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(1, SumToN(1))\n    assert.Equal(15, SumToN(5))\n    assert.Equal(55, SumToN(10))\n    assert.Equal(465, SumToN(30))\n    assert.Equal(5050, SumToN(100))\n}\n", "prompt_text": "SumToN is a function that sums numbers from 1 to n.", "prompt_explain": "SumToN is a function that sums numbers from 1 to n.\n>>> SumToN(30)\n465\n>>> SumToN(100)\n5050\n>>> SumToN(5)\n15\n>>> SumToN(10)\n55\n>>> SumToN(1)\n1\n", "func_title": "func SumToN(n int) int ", "prompt_text_chinese": "SumToN是一个对从1到n的数求和的函数。"}
{"task_id": "Go/61", "prompt": "import (\n    \"strings\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// \n// >>> CorrectBracketing(\"(\")\n// false\n// >>> CorrectBracketing(\"()\")\n// true\n// >>> CorrectBracketing(\"(()())\")\n// true\n// >>> CorrectBracketing(\")(()\")\n// false\nfunc CorrectBracketing(brackets string) bool {\n", "import": "import (\n    \"strings\"\n)", "docstring": "// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// \n// >>> CorrectBracketing(\"(\")\n// false\n// >>> CorrectBracketing(\"()\")\n// true\n// >>> CorrectBracketing(\"(()())\")\n// true\n// >>> CorrectBracketing(\")(()\")\n// false\n", "declaration": "\nfunc CorrectBracketing(brackets string) bool {\n", "canonical_solution": "    brackets = strings.Replace(brackets, \"(\", \" ( \", -1)\n\tbrackets = strings.Replace(brackets, \")\", \") \", -1)\n\topen := 0\n\tfor _, b := range brackets {\n\t\tif b == '(' {\n\t\t\topen++\n\t\t} else if b == ')' {\n\t\t\topen--\n\t\t}\n\t\tif open < 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn open == 0\n}\n\n", "test": "func TestCorrectBracketing(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, CorrectBracketing(\"()\"))\n    assert.Equal(true, CorrectBracketing(\"(()())\"))\n    assert.Equal(true, CorrectBracketing(\"()()(()())()\"))\n    assert.Equal(true, CorrectBracketing(\"()()((()()())())(()()(()))\"))\n    assert.Equal(false, CorrectBracketing(\"((()())))\"))\n    assert.Equal(false, CorrectBracketing(\")(()\"))\n    assert.Equal(false, CorrectBracketing(\"(\"))\n    assert.Equal(false, CorrectBracketing(\"((((\"))\n    assert.Equal(false, CorrectBracketing(\")\"))\n    assert.Equal(false, CorrectBracketing(\"(()\"))\n    assert.Equal(false, CorrectBracketing(\"()()(()())())(()\"))\n    assert.Equal(false, CorrectBracketing(\"()()(()())()))()\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestCorrectBracketing(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, CorrectBracketing(\"()\"))\n    assert.Equal(true, CorrectBracketing(\"(()())\"))\n    assert.Equal(false, CorrectBracketing(\")(()\"))\n    assert.Equal(false, CorrectBracketing(\"(\"))\n}\n", "prompt_text": "brackets is a string of \"(\" and \")\". return true if every opening bracket has a corresponding closing bracket. ", "prompt_explain": "brackets is a string of \"(\" and \")\".\nreturn true if every opening bracket has a corresponding closing bracket.\n\n>>> CorrectBracketing(\"(\")\nfalse\n>>> CorrectBracketing(\"()\")\ntrue\n>>> CorrectBracketing(\"(()())\")\ntrue\n>>> CorrectBracketing(\")(()\")\nfalse\n", "func_title": "func CorrectBracketing(brackets string) bool ", "prompt_text_chinese": "括号是由\"(\"和\")\"组成的字符串。如果每个左括号都有对应的右括号，则返回true。"}
{"task_id": "Go/62", "prompt": "\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return Derivative of this polynomial in the same form.\n// >>> Derivative([3, 1, 2, 4, 5])\n// [1, 4, 12, 20]\n// >>> Derivative([1, 2, 3])\n// [2, 6]\nfunc Derivative(xs []int) []int {\n", "import": "", "docstring": "// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return Derivative of this polynomial in the same form.\n// >>> Derivative([3, 1, 2, 4, 5])\n// [1, 4, 12, 20]\n// >>> Derivative([1, 2, 3])\n// [2, 6]\n", "declaration": "\nfunc Derivative(xs []int) []int {\n", "canonical_solution": "    l := len(xs)\n\ty := make([]int, l - 1)\n\tfor i := 0; i < l - 1; i++ {\n\t\ty[i] = xs[i + 1] * (i + 1)\n\t}\n\treturn y\n}\n\n", "test": "func TestDerivative(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{1, 4, 12, 20}, Derivative([]int{3, 1, 2, 4, 5}))\n    assert.Equal([]int{2, 6}, Derivative([]int{1, 2, 3}))\n    assert.Equal([]int{2, 2}, Derivative([]int{3, 2, 1}))\n    assert.Equal([]int{2, 2, 0, 16}, Derivative([]int{3, 2, 1,0, 4}))\n    assert.Equal([]int{}, Derivative([]int{1}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestDerivative(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{1, 4, 12, 20}, Derivative([]int{3, 1, 2, 4, 5}))\n    assert.Equal([]int{2, 6}, Derivative([]int{1, 2, 3}))\n}\n", "prompt_text": "xs represent coefficients of a polynomial. xs[0] + xs[1] * x + xs[2] * x^2 + .... Return Derivative of this polynomial in the same form.", "prompt_explain": "xs represent coefficients of a polynomial.\nxs[0] + xs[1] * x + xs[2] * x^2 + ....\nReturn Derivative of this polynomial in the same form.\n>>> Derivative([3, 1, 2, 4, 5])\n[1, 4, 12, 20]\n>>> Derivative([1, 2, 3])\n[2, 6]\n", "func_title": "func Derivative(xs []int) []int ", "prompt_text_chinese": "x表示多项式的系数。Xs [0] + Xs [1] * x + Xs [2] * x^2 + ....以相同形式返回这个多项式的导数"}
{"task_id": "Go/63", "prompt": "\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// Fibfib(0) == 0\n// Fibfib(1) == 0\n// Fibfib(2) == 1\n// Fibfib(n) == Fibfib(n-1) + Fibfib(n-2) + Fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the Fibfib number sequence.\n// >>> Fibfib(1)\n// 0\n// >>> Fibfib(5)\n// 4\n// >>> Fibfib(8)\n// 24\nfunc Fibfib(n int) int {\n", "import": "", "docstring": "// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// Fibfib(0) == 0\n// Fibfib(1) == 0\n// Fibfib(2) == 1\n// Fibfib(n) == Fibfib(n-1) + Fibfib(n-2) + Fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the Fibfib number sequence.\n// >>> Fibfib(1)\n// 0\n// >>> Fibfib(5)\n// 4\n// >>> Fibfib(8)\n// 24\n", "declaration": "\nfunc Fibfib(n int) int {\n", "canonical_solution": "    if n <= 0 {\n\t\treturn 0\n\t}\n    switch n {\n\tcase 0:\n\t\treturn 0\n\tcase 1:\n\t\treturn 0\n\tcase 2:\n\t\treturn 1\n\tdefault:\n\t\treturn Fibfib(n-1) + Fibfib(n-2) + Fibfib(n-3)\n\t}\n}\n\n", "test": "func TestFibfib(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(1, Fibfib(2))\n    assert.Equal(0, Fibfib(1))\n    assert.Equal(4, Fibfib(5))\n    assert.Equal(24, Fibfib(8))\n    assert.Equal(81, Fibfib(10))\n    assert.Equal(274, Fibfib(12))\n    assert.Equal(927, Fibfib(14))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestFibfib(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(0, Fibfib(1))\n    assert.Equal(4, Fibfib(5))\n    assert.Equal(24, Fibfib(8))\n}\n", "prompt_text": "The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows: Fibfib(0) == 0 Fibfib(1) == 0 Fibfib(2) == 1 Fibfib(n) == Fibfib(n-1) + Fibfib(n-2) + Fibfib(n-3). Please write a function to efficiently compute the n-th element of the Fibfib number sequence.", "prompt_explain": "The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\nFibfib(0) == 0\nFibfib(1) == 0\nFibfib(2) == 1\nFibfib(n) == Fibfib(n-1) + Fibfib(n-2) + Fibfib(n-3).\nPlease write a function to efficiently compute the n-th element of the Fibfib number sequence.\n>>> Fibfib(1)\n0\n>>> Fibfib(5)\n4\n>>> Fibfib(8)\n24\n", "func_title": "func Fibfib(n int) int ", "prompt_text_chinese": "FibFib数列是一个类似于fibonacci数列的数列，定义如下:Fibfib(0) == 0  Fibfib(1) == 0  Fibfib(2) == 1  Fibfib(n) == Fibfib(n-1) + Fibfib(n-2) + Fibfib(n-3).请编写一个函数来有效地计算Fibfib数列的第n个元素。"}
{"task_id": "Go/64", "prompt": "import (\n    \"strings\"\n)\n\n// Write a function VowelsCount which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// \n// Example:\n// >>> VowelsCount(\"abcde\")\n// 2\n// >>> VowelsCount(\"ACEDY\")\n// 3\nfunc VowelsCount(s string) int {\n", "import": "import (\n    \"strings\"\n)", "docstring": "// Write a function VowelsCount which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// \n// Example:\n// >>> VowelsCount(\"abcde\")\n// 2\n// >>> VowelsCount(\"ACEDY\")\n// 3\n", "declaration": "\nfunc VowelsCount(s string) int {\n", "canonical_solution": "    s = strings.ToLower(s)\n\tvowels := map[int32]interface{}{'a': nil, 'e': nil, 'i': nil, 'o': nil, 'u': nil}\n\tcount := 0\n\tfor _, i := range s {\n\t\tif _, ok := vowels[i]; ok {\n\t\t\tcount++\n\t\t}\n\t}\n\tif (s[len(s)-1]) == 'y' {\n\t\tcount++\n\t}\n\treturn count\n}\n\n", "test": "func TestVowelsCount(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(2, VowelsCount(\"abcde\"))\n    assert.Equal(3, VowelsCount(\"Alone\"))\n    assert.Equal(2, VowelsCount(\"key\"))\n    assert.Equal(1, VowelsCount(\"bye\"))\n    assert.Equal(2, VowelsCount(\"keY\"))\n    assert.Equal(1, VowelsCount(\"bYe\"))\n    assert.Equal(3, VowelsCount(\"ACEDY\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestVowelsCount(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(2, VowelsCount(\"abcde\"))\n    assert.Equal(3, VowelsCount(\"ACEDY\"))\n}\n", "prompt_text": "Write a function VowelsCount which takes a string representing a word as input and returns the number of vowels in the string. Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a vowel, but only when it is at the end of the given word.  Example:", "prompt_explain": "Write a function VowelsCount which takes a string representing\na word as input and returns the number of vowels in the string.\nVowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\nvowel, but only when it is at the end of the given word.\n\nExample:\n>>> VowelsCount(\"abcde\")\n2\n>>> VowelsCount(\"ACEDY\")\n3\n", "func_title": "func VowelsCount(s string) int ", "prompt_text_chinese": "写一个函数VowelsCount，它接受一个表示单词的字符串作为输入，并返回字符串中元音的数量。这种情况下的元音是'a'， 'e'， 'i'， 'o'， 'u'。在这里，“y”也是一个元音，但只有当它位于给定单词的末尾时。"}
{"task_id": "Go/65", "prompt": "\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> CircularShift(12, 1)\n// \"21\"\n// >>> CircularShift(12, 2)\n// \"12\"\nfunc CircularShift(x int,shift int) string {\n", "import": "import (\n    \"strconv\"\n)", "docstring": "// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> CircularShift(12, 1)\n// \"21\"\n// >>> CircularShift(12, 2)\n// \"12\"\n", "declaration": "\nfunc CircularShift(x int, shift int) string {\n", "canonical_solution": "    s := strconv.Itoa(x)\n\tif shift > len(s) {\n\t\trunes := make([]rune, 0)\n\t\tfor i := len(s)-1; i >= 0; i-- {\n\t\t\trunes = append(runes, rune(s[i]))\n\t\t}\n\t\treturn string(runes)\n\t}else{\n\t\treturn s[len(s)-shift:]+s[:len(s)-shift]\n\t}\n}\n\n", "test": "func TestCircularShift(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"001\", CircularShift(100, 2))\n    assert.Equal(\"12\", CircularShift(12, 2))\n    assert.Equal(\"79\", CircularShift(97, 8))\n    assert.Equal(\"21\", CircularShift(12, 1))\n    assert.Equal(\"11\", CircularShift(11, 101))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestCircularShift(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"12\", CircularShift(12, 2))\n    assert.Equal(\"21\", CircularShift(12, 1))\n}\n", "prompt_text": "Circular shift the digits of the integer x, shift the digits right by shift and return the result as a string. If shift > number of digits, return digits reversed.", "prompt_explain": "Circular shift the digits of the integer x, shift the digits right by shift\nand return the result as a string.\nIf shift > number of digits, return digits reversed.\n>>> CircularShift(12, 1)\n\"21\"\n>>> CircularShift(12, 2)\n\"12\"\n", "func_title": "func CircularShift(x int, shift int) string ", "prompt_text_chinese": "对整数x的数字进行循环移位，将数字逐shift右移，并将结果作为字符串返回。如果shift >位数，则返回颠倒的数字。"}
{"task_id": "Go/66", "prompt": "\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// \n// Examples:\n// Digitsum(\"\") => 0\n// Digitsum(\"abAB\") => 131\n// Digitsum(\"abcCd\") => 67\n// Digitsum(\"helloE\") => 69\n// Digitsum(\"woArBld\") => 131\n// Digitsum(\"aAaaaXa\") => 153\nfunc Digitsum(x string) int {\n", "import": "", "docstring": "// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// \n// Examples:\n// Digitsum(\"\") => 0\n// Digitsum(\"abAB\") => 131\n// Digitsum(\"abcCd\") => 67\n// Digitsum(\"helloE\") => 69\n// Digitsum(\"woArBld\") => 131\n// Digitsum(\"aAaaaXa\") => 153\n", "declaration": "\nfunc Digitsum(x string) int {\n", "canonical_solution": "    if len(x) == 0 {\n\t\treturn 0\n\t}\n\tresult := 0\n\tfor _, i := range x {\n\t\tif 'A' <= i && i <= 'Z' {\n\t\t\tresult += int(i)\n\t\t}\n\t}\n\treturn result\n}\n\n", "test": "func TestDigitSum(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(0, Digitsum(\"\"))\n    assert.Equal(131, Digitsum(\"abAB\"))\n    assert.Equal(67, Digitsum(\"abcCd\"))\n    assert.Equal(69, Digitsum(\"helloE\"))\n    assert.Equal(131, Digitsum(\"woArBld\"))\n    assert.Equal(153, Digitsum(\"aAaaaXa\"))\n    assert.Equal(151, Digitsum(\" How are yOu?\"))\n    assert.Equal(327, Digitsum(\"You arE Very Smart\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestDigitSum(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(0, Digitsum(\"\"))\n    assert.Equal(131, Digitsum(\"abAB\"))\n    assert.Equal(67, Digitsum(\"abcCd\"))\n    assert.Equal(69, Digitsum(\"helloE\"))\n    assert.Equal(131, Digitsum(\"woArBld\"))\n    assert.Equal(153, Digitsum(\"aAaaaXa\"))\n}\n", "prompt_text": "", "prompt_explain": "Task\nWrite a function that takes a string as input and returns the sum of the upper characters only'\nASCII codes.\n\nExamples:\nDigitsum(\"\") => 0\nDigitsum(\"abAB\") => 131\nDigitsum(\"abcCd\") => 67\nDigitsum(\"helloE\") => 69\nDigitsum(\"woArBld\") => 131\nDigitsum(\"aAaaaXa\") => 153\n", "func_title": "func Digitsum(x string) int ", "prompt_text_chinese": "编写一个函数，该函数接受字符串作为输入，并返回上面字符的和，只返回ASCII码"}
{"task_id": "Go/67", "prompt": "import (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// In this task, you will be given a string that represents a number of apples and oranges\n// that are distributed in a basket of fruit this basket contains\n// apples, oranges, and mango fruits. Given the string that represents the total number of\n// the oranges and apples and an integer that represent the total number of the fruits\n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// FruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n// FruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n// FruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n// FruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\nfunc FruitDistribution(s string,n int) int {\n", "import": "import (\n\t\"strconv\"\n\t\"strings\"\n)", "docstring": "// In this task, you will be given a string that represents a number of apples and oranges\n// that are distributed in a basket of fruit this basket contains\n// apples, oranges, and mango fruits. Given the string that represents the total number of\n// the oranges and apples and an integer that represent the total number of the fruits\n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// FruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n// FruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n// FruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n// FruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n", "declaration": "\nfunc FruitDistribution(s string,n int) int {\n", "canonical_solution": "    split := strings.Split(s, \" \")\n\tfor _, i := range split {\n\t\tatoi, err := strconv.Atoi(i)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tn = n - atoi\n\t}\n\treturn n\n}\n\n", "test": "func TestFruitDistribution(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(8, FruitDistribution(\"5 apples and 6 oranges\", 19))\n    assert.Equal(10, FruitDistribution(\"5 apples and 6 oranges\", 21))\n    assert.Equal(2, FruitDistribution(\"0 apples and 1 oranges\", 3))\n    assert.Equal(2, FruitDistribution(\"1 apples and 0 oranges\", 3))\n    assert.Equal(95, FruitDistribution(\"2 apples and 3 oranges\", 100))\n    assert.Equal(0, FruitDistribution(\"2 apples and 3 oranges\", 5))\n    assert.Equal(19, FruitDistribution(\"1 apples and 100 oranges\", 120))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestFruitDistribution(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(8, FruitDistribution(\"5 apples and 6 oranges\", 19))\n    assert.Equal(2, FruitDistribution(\"0 apples and 1 oranges\", 3))\n    assert.Equal(95, FruitDistribution(\"2 apples and 3 oranges\", 100))\n    assert.Equal(19, FruitDistribution(\"1 apples and 100 oranges\", 120))\n}\n", "prompt_text": "", "prompt_explain": "In this task, you will be given a string that represents a number of apples and oranges\nthat are distributed in a basket of fruit this basket contains\napples, oranges, and mango fruits. Given the string that represents the total number of\nthe oranges and apples and an integer that represent the total number of the fruits\nin the basket return the number of the mango fruits in the basket.\nfor examble:\nFruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\nFruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\nFruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\nFruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n", "func_title": "func FruitDistribution(s string,n int) int ", "prompt_text_chinese": "在这个任务中，你会得到一个字符串，它代表了苹果和橘子的数量，这些苹果和橘子分布在一个水果篮子里，这个篮子里有苹果、橘子和芒果。给定一个表示橘子和苹果总数的字符串和一个表示篮子中水果总数的整数，返回篮子中芒果水果的数量。"}
{"task_id": "Go/68", "prompt": "import (\n    \"math\"\n)\n\n// Given an array representing a branch of a tree that has non-negative integer nodes\n// your task is to Pluck one of the nodes and return it.\n// The Plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// \n// The Plucked node should be returned in a list, [ smalest_value, its index ],\n// If there are no even values or the given array is empty, return [].\n// \n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// \n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// \n// Example 3:\n// Input: []\n// Output: []\n// \n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// \n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc Pluck(arr []int) []int {\n", "import": "import (\n    \"math\"\n)", "docstring": "// Given an array representing a branch of a tree that has non-negative integer nodes\n// your task is to Pluck one of the nodes and return it.\n// The Plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// \n// The Plucked node should be returned in a list, [ smalest_value, its index ],\n// If there are no even values or the given array is empty, return [].\n// \n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// \n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// \n// Example 3:\n// Input: []\n// Output: []\n// \n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// \n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n", "declaration": "\nfunc Pluck(arr []int) []int {\n", "canonical_solution": "    result := make([]int, 0)\n\tif len(arr) == 0 {\n\t\treturn result\n\t}\n\tevens := make([]int, 0)\n\tmin := math.MaxInt64\n\tminIndex := 0\n\tfor i, x := range arr {\n\t\tif x%2 == 0 {\n\t\t\tevens = append(evens, x)\n\t\t\tif x < min {\n\t\t\t\tmin = x\n\t\t\t\tminIndex = i\n\t\t\t}\n\t\t}\n\t}\n\tif len(evens) == 0 {\n\t\treturn result\n\t}\n\tresult = []int{min, minIndex}\n\treturn result\n}\n\n", "test": "func TestPluck(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{2, 1}, Pluck([]int{4,2,3}))\n    assert.Equal([]int{2, 1}, Pluck([]int{1,2,3}))\n    assert.Equal([]int{}, Pluck([]int{}))\n    assert.Equal([]int{0, 1}, Pluck([]int{5, 0, 3, 0, 4, 2}))\n    assert.Equal([]int{0, 3}, Pluck([]int{1, 2, 3, 0, 5, 3}))\n    assert.Equal([]int{4, 1}, Pluck([]int{5, 4, 8, 4 ,8}))\n    assert.Equal([]int{6, 1}, Pluck([]int{7, 6, 7, 1}))\n    assert.Equal([]int{}, Pluck([]int{7, 9, 7, 1}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestPluck(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{2, 1}, Pluck([]int{4,2,3}))\n    assert.Equal([]int{2, 1}, Pluck([]int{1,2,3}))\n    assert.Equal([]int{}, Pluck([]int{}))\n    assert.Equal([]int{0, 1}, Pluck([]int{5, 0, 3, 0, 4, 2}))\n}\n", "prompt_text": "", "prompt_explain": "Given an array representing a branch of a tree that has non-negative integer nodes\nyour task is to Pluck one of the nodes and return it.\nThe Plucked node should be the node with the smallest even value.\nIf multiple nodes with the same smallest even value are found return the node that has smallest index.\n\nThe Plucked node should be returned in a list, [ smalest_value, its index ],\nIf there are no even values or the given array is empty, return [].\n\nExample 1:\nInput: [4,2,3]\nOutput: [2, 1]\nExplanation: 2 has the smallest even value, and 2 has the smallest index.\n\nExample 2:\nInput: [1,2,3]\nOutput: [2, 1]\nExplanation: 2 has the smallest even value, and 2 has the smallest index.\n\nExample 3:\nInput: []\nOutput: []\n\nExample 4:\nInput: [5, 0, 3, 0, 4, 2]\nOutput: [0, 1]\nExplanation: 0 is the smallest value, but  there are two zeros,\nso we will choose the first zero, which has the smallest index.\n\nConstraints:\n* 1 <= nodes.length <= 10000\n* 0 <= node.value\n", "func_title": "func Pluck(arr []int) []int ", "prompt_text_chinese": "给定一个表示具有非负整数节点的树的分支的数组，您的任务是提取其中一个节点并返回它。被拔节点应该是偶数值最小的节点。如果找到多个具有相同最小偶数值的节点，则返回索引最小的节点。被选中的节点应该以列表[smallest_value，其索引]的形式返回，如果没有偶数值或给定数组为空，则返回[]"}
{"task_id": "Go/69", "prompt": "\n// You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n// zero, and has a frequency greater than or equal to the value of the integer itself.\n// The frequency of an integer is the number of times it appears in the list.\n// If no such a value exist, return -1.\n// Examples:\n// Search([4, 1, 2, 2, 3, 1]) == 2\n// Search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n// Search([5, 5, 4, 4, 4]) == -1\nfunc Search(lst []int) int {\n", "import": "", "docstring": "// You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n// zero, and has a frequency greater than or equal to the value of the integer itself.\n// The frequency of an integer is the number of times it appears in the list.\n// If no such a value exist, return -1.\n// Examples:\n// Search([4, 1, 2, 2, 3, 1]) == 2\n// Search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n// Search([5, 5, 4, 4, 4]) == -1\n", "declaration": "\nfunc Search(lst []int) int {\n", "canonical_solution": "    countMap := make(map[int]int)\n\tfor _, i := range lst {\n\t\tif count, ok := countMap[i]; ok {\n\t\t\tcountMap[i] = count + 1\n\t\t} else {\n\t\t\tcountMap[i] = 1\n\t\t}\n\t}\n\tmax := -1\n\tfor i, count := range countMap {\n\t\tif count >= i && count > max {\n\t\t\tmax = i\n\t\t}\n\t}\n\treturn max\n}\n\n", "test": "func TestSearch(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(1, Search([]int{5, 5, 5, 5, 1}))\n    assert.Equal(4, Search([]int{4, 1, 4, 1, 4, 4}))\n    assert.Equal(-1, Search([]int{3, 3}))\n    assert.Equal(8, Search([]int{8, 8, 8, 8, 8, 8, 8, 8}))\n    assert.Equal(2, Search([]int{2, 3, 3, 2, 2}))\n    assert.Equal(1, Search([]int{2, 7, 8, 8, 4, 8, 7, 3, 9, 6,5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1}))\n    assert.Equal(2, Search([]int{3, 2, 8, 2}))\n    assert.Equal(1, Search([]int{6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10}))\n    assert.Equal(-1, Search([]int{8, 8, 3, 6, 5, 6, 4}))\n    assert.Equal(1, Search([]int{6, 9, 6, 7, 1, 4, 7, 1, 8, 8,9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9}))\n    assert.Equal(1, Search([]int{1, 9, 10, 1, 3}))\n    assert.Equal(5, Search([]int{6, 9, 7, 5, 8, 7, 5, 3, 7, 5,10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10}))\n    assert.Equal(1, Search([]int{1}))\n    assert.Equal(4, Search([]int{8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5}))\n    assert.Equal(2, Search([]int{2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10}))\n    assert.Equal(1, Search([]int{1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3}))\n    assert.Equal(4, Search([]int{9, 2, 4, 1, 5, 1, 5, 2, 5, 7,7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4}))\n    assert.Equal(4, Search([]int{2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7}))\n    assert.Equal(2, Search([]int{9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1}))\n    assert.Equal(-1, Search([]int{5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8}))\n    assert.Equal(-1, Search([]int{10}))\n    assert.Equal(2, Search([]int{9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2}))\n    assert.Equal(1, Search([]int{5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8}))\n    assert.Equal(1, Search([]int{7, 9, 9, 9, 3, 4, 1, 5, 9, 1,2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6}))\n    assert.Equal(-1, Search([]int{3, 10, 10, 9, 2}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSearch(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(2, Search([]int{4, 1, 2, 2, 3, 1}))\n    assert.Equal(3, Search([]int{1, 2, 2, 3, 3, 3, 4, 4, 4}))\n    assert.Equal(-1, Search([]int{5, 5, 4, 4, 4}))\n}\n", "prompt_text": "", "prompt_explain": "You are given a non-empty list of positive integers. Return the greatest integer that is greater than\nzero, and has a frequency greater than or equal to the value of the integer itself.\nThe frequency of an integer is the number of times it appears in the list.\nIf no such a value exist, return -1.\nExamples:\nSearch([4, 1, 2, 2, 3, 1]) == 2\nSearch([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\nSearch([5, 5, 4, 4, 4]) == -1\n", "func_title": "func Search(lst []int) int ", "prompt_text_chinese": "给你一个非空的正整数列表。返回大于零的最大整数，并且频率大于或等于整数本身的值。整数出现的频率是指它在列表中出现的次数。如果不存在，则返回-1。"}
{"task_id": "Go/70", "prompt": "import (\n    \"sort\"\n)\n\n// Given list of integers, return list in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// \n// Examples:\n// StrangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n// StrangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n// StrangeSortList([]) == []\nfunc StrangeSortList(lst []int) []int {\n", "import": "import (\n    \"sort\"\n)", "docstring": "// Given list of integers, return list in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// \n// Examples:\n// StrangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n// StrangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n// StrangeSortList([]) == []\n", "declaration": "\nfunc StrangeSortList(lst []int) []int {\n", "canonical_solution": "    sort.Ints(lst)\n\tresult := make([]int, 0)\n\tfor i := 0; i < len(lst)/2; i++ {\n\t\tresult = append(result, lst[i])\n\t\tresult = append(result, lst[len(lst)-i-1])\n\t}\n\tif len(lst)%2 != 0 {\n\t\tresult = append(result, lst[len(lst)/2])\n\t}\n\treturn result\n}\n\n", "test": "func TestStrangeSortList(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{1, 4, 2, 3}, StrangeSortList([]int{1,2, 3, 4}))\n    assert.Equal([]int{5, 9, 6, 8, 7}, StrangeSortList([]int{5, 6, 7, 8, 9}))\n    assert.Equal([]int{1, 5, 2, 4, 3}, StrangeSortList([]int{1, 2, 3, 4, 5}))\n    assert.Equal([]int{1, 9, 5, 8, 6, 7}, StrangeSortList([]int{5, 6, 7, 8, 9, 1}))\n    assert.Equal([]int{5, 5, 5, 5}, StrangeSortList([]int{5,5, 5, 5}))\n    assert.Equal([]int{}, StrangeSortList([]int{}))\n    assert.Equal([]int{1, 8, 2, 7, 3, 6, 4, 5}, StrangeSortList([]int{1,2,3,4,5,6,7,8}))\n    assert.Equal([]int{-5, 5, -5, 5, 0, 2, 2, 2}, StrangeSortList([]int{0,2,2,2,5,5,-5,-5}))\n    assert.Equal([]int{111111}, StrangeSortList([]int{111111}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestStrangeSortList(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{1, 4, 2, 3}, StrangeSortList([]int{1,2, 3, 4}))\n    assert.Equal([]int{5, 5, 5, 5}, StrangeSortList([]int{5,5, 5, 5}))\n    assert.Equal([]int{}, StrangeSortList([]int{}))\n}\n", "prompt_text": "", "prompt_explain": "Given list of integers, return list in strange order.\nStrange sorting, is when you start with the minimum value,\nthen maximum of the remaining integers, then minimum and so on.\n\nExamples:\nStrangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\nStrangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\nStrangeSortList([]) == []\n", "func_title": "func StrangeSortList(lst []int) []int ", "prompt_text_chinese": "给定整数列表，以奇怪的顺序返回列表。奇怪排序，就是从最小值开始，然后是剩余整数中的最大值，然后是最小值，以此类推"}
{"task_id": "Go/71", "prompt": "import (\n    \"math\"\n)\n\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater\n// than the third side.\n// Example:\n// TriangleArea(3, 4, 5) == 6.00\n// TriangleArea(1, 2, 10) == -1\nfunc TriangleArea(a float64, b float64, c float64) interface{} {\n", "import": "import (\n    \"math\"\n)", "docstring": "// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater\n// than the third side.\n// Example:\n// TriangleArea(3, 4, 5) == 6.00\n// TriangleArea(1, 2, 10) == -1\n", "declaration": "\nfunc TriangleArea(a float64, b float64, c float64) interface{} {\n", "canonical_solution": "    if a+b <= c || a+c <= b || b+c <= a {\n\t\treturn -1\n\t}\n\ts := (a + b + c) / 2\n\tarea := math.Pow(s * (s - a) * (s - b) * (s - c), 0.5)\n\tarea = math.Round(area*100)/100\n\treturn area\n}\n\n", "test": "func TestTriangleArea(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(6.00, TriangleArea(3, 4, 5))\n    assert.Equal(-1, TriangleArea(1, 2, 10))\n    assert.Equal(8.18, TriangleArea(4, 8, 5))\n    assert.Equal(1.73, TriangleArea(2, 2, 2))\n    assert.Equal(-1, TriangleArea(1, 2, 3))\n    assert.Equal(16.25, TriangleArea(10, 5, 7))\n    assert.Equal(-1, TriangleArea(2, 6, 3))\n    assert.Equal(0.43, TriangleArea(1, 1, 1))\n    assert.Equal(-1, TriangleArea(2, 2, 10))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestTriangleArea(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(6.00, TriangleArea(3, 4, 5))\n    assert.Equal(-1, TriangleArea(1, 2, 10))\n}\n", "prompt_text": "", "prompt_explain": "Given the lengths of the three sides of a triangle. Return the area of\nthe triangle rounded to 2 decimal points if the three sides form a valid triangle.\nOtherwise return -1\nThree sides make a valid triangle when the sum of any two sides is greater\nthan the third side.\nExample:\nTriangleArea(3, 4, 5) == 6.00\nTriangleArea(1, 2, 10) == -1\n", "func_title": "func TriangleArea(a float64, b float64, c float64) interface{} ", "prompt_text_chinese": "已知三角形三条边的长度。如果三角形的三条边组成一个有效的三角形，则返回三角形的面积四舍五入到小数点后两位。否则返回-1当任意两条边之和大于第三条边时，三条边构成有效三角形"}
{"task_id": "Go/72", "prompt": "\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n// \n// Example:\n// WillItFly([1, 2], 5) ➞ false\n// 1+2 is less than the maximum possible weight, but it's unbalanced.\n// \n// WillItFly([3, 2, 3], 1) ➞ false\n// it's balanced, but 3+2+3 is more than the maximum possible weight.\n// \n// WillItFly([3, 2, 3], 9) ➞ true\n// 3+2+3 is less than the maximum possible weight, and it's balanced.\n// \n// WillItFly([3], 5) ➞ true\n// 3 is less than the maximum possible weight, and it's balanced.\nfunc WillItFly(q []int,w int) bool {\n", "import": "", "docstring": "// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n// \n// Example:\n// WillItFly([1, 2], 5) ➞ false\n// 1+2 is less than the maximum possible weight, but it's unbalanced.\n// \n// WillItFly([3, 2, 3], 1) ➞ false\n// it's balanced, but 3+2+3 is more than the maximum possible weight.\n// \n// WillItFly([3, 2, 3], 9) ➞ true\n// 3+2+3 is less than the maximum possible weight, and it's balanced.\n// \n// WillItFly([3], 5) ➞ true\n// 3 is less than the maximum possible weight, and it's balanced.\n", "declaration": "\nfunc WillItFly(q []int,w int) bool {\n", "canonical_solution": "    sum := 0\n\tfor i := 0; i < len(q); i++ {\n\t\tsum += q[i]\n\t}\n\tif sum <= w && isPalindrome(q) {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc isPalindrome(arr []int) bool {\n\tfor i := 0; i < (len(arr) / 2); i++ {\n\t\tif arr[i] != arr[len(arr) - i - 1] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n", "test": "func TestWillItFly(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, WillItFly([]int{3, 2, 3}, 9))\n    assert.Equal(false, WillItFly([]int{1, 2}, 5))\n    assert.Equal(true, WillItFly([]int{3}, 5))\n    assert.Equal(false, WillItFly([]int{3, 2, 3}, 1))\n    assert.Equal(false, WillItFly([]int{1, 2, 3}, 6))\n    assert.Equal(true, WillItFly([]int{5}, 5))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestWillItFly(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, WillItFly([]int{3, 2, 3}, 9))\n    assert.Equal(false, WillItFly([]int{1, 2}, 5))\n    assert.Equal(true, WillItFly([]int{3}, 5))\n    assert.Equal(false, WillItFly([]int{3, 2, 3}, 1))\n}\n", "prompt_text": "", "prompt_explain": "Write a function that returns true if the object q will fly, and false otherwise.\nThe object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\nExample:\nWillItFly([1, 2], 5) ➞ false\n1+2 is less than the maximum possible weight, but it's unbalanced.\n\nWillItFly([3, 2, 3], 1) ➞ false\nit's balanced, but 3+2+3 is more than the maximum possible weight.\n\nWillItFly([3, 2, 3], 9) ➞ true\n3+2+3 is less than the maximum possible weight, and it's balanced.\n\nWillItFly([3], 5) ➞ true\n3 is less than the maximum possible weight, and it's balanced.\n", "func_title": "func WillItFly(q []int,w int) bool ", "prompt_text_chinese": "编写一个函数，如果对象q将飞，则返回true，否则返回false。如果对象q是平衡的(它是一个回文列表)，并且其元素的和小于或等于最大可能的权值w，则对象q将飞起来"}
{"task_id": "Go/73", "prompt": "\n// Given an array arr of integers, find the minimum number of elements that\n// need to be changed to make the array palindromic. A palindromic array is an array that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// \n// For example:\n// SmallestChange([1,2,3,5,4,7,9,6]) == 4\n// SmallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n// SmallestChange([1, 2, 3, 2, 1]) == 0\nfunc SmallestChange(arr []int) int {\n", "import": "", "docstring": "// Given an array arr of integers, find the minimum number of elements that\n// need to be changed to make the array palindromic. A palindromic array is an array that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// \n// For example:\n// SmallestChange([1,2,3,5,4,7,9,6]) == 4\n// SmallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n// SmallestChange([1, 2, 3, 2, 1]) == 0\n", "declaration": "\nfunc SmallestChange(arr []int) int {\n", "canonical_solution": "    count := 0\n\tfor i := 0; i < len(arr) - 1; i++ {\n        a := arr[len(arr) - i - 1]\n\t\tif arr[i] != a {\n\t\t\tarr[i] = a\n            count++\n\t\t}\n\t}\n\treturn count\n}\n\n", "test": "func TestSmallestChange(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(4, SmallestChange([]int{1,2,3,5,4,7,9,6}))\n    assert.Equal(1, SmallestChange([]int{1, 2, 3, 4, 3, 2, 2}))\n    assert.Equal(1, SmallestChange([]int{1, 4, 2}))\n    assert.Equal(1, SmallestChange([]int{1, 4, 4, 2}))\n    assert.Equal(0, SmallestChange([]int{1, 2, 3, 2, 1}))\n    assert.Equal(0, SmallestChange([]int{3, 1, 1, 3}))\n    assert.Equal(0, SmallestChange([]int{1}))\n    assert.Equal(1, SmallestChange([]int{0, 1}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSmallestChange(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(4, SmallestChange([]int{1,2,3,5,4,7,9,6}))\n    assert.Equal(1, SmallestChange([]int{1, 2, 3, 4, 3, 2, 2}))\n    assert.Equal(0, SmallestChange([]int{1, 2, 3, 2, 1}))\n    assert.Equal(0, SmallestChange([]int{3, 1, 1, 3}))\n}\n", "prompt_text": "", "prompt_explain": "Given an array arr of integers, find the minimum number of elements that\nneed to be changed to make the array palindromic. A palindromic array is an array that\nis read the same backwards and forwards. In one change, you can change one element to any other element.\n\nFor example:\nSmallestChange([1,2,3,5,4,7,9,6]) == 4\nSmallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\nSmallestChange([1, 2, 3, 2, 1]) == 0\n", "func_title": "func SmallestChange(arr []int) int ", "prompt_text_chinese": "给定一个整数数组arr，找出为了使数组回文而需要更改的最小元素数。回文数组是前后读取相同的数组。在一次更改中，您可以将一个元素更改为任何其他元素"}
{"task_id": "Go/74", "prompt": "\n// Write a function that accepts two lists of strings and returns the list that has\n// total number of chars in the all strings of the list less than the other list.\n// \n// if the two lists have the same number of chars, return the first list.\n// \n// Examples\n// TotalMatch([], []) ➞ []\n// TotalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n// TotalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n// TotalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n// TotalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\nfunc TotalMatch(lst1 []string,lst2 []string) []string {\n", "import": "", "docstring": "// Write a function that accepts two lists of strings and returns the list that has\n// total number of chars in the all strings of the list less than the other list.\n// \n// if the two lists have the same number of chars, return the first list.\n// \n// Examples\n// TotalMatch([], []) ➞ []\n// TotalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n// TotalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n// TotalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n// TotalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n", "declaration": "\nfunc TotalMatch(lst1 []string,lst2 []string) []string {\n", "canonical_solution": "    var numchar1 = 0\n\tvar numchar2 = 0\n\tfor _, item := range lst1 {\n\t\tnumchar1 += len(item)\n\t}\n\tfor _, item := range lst2 {\n\t\tnumchar2 += len(item)\n\t}\n\tif numchar1 <= numchar2 {\n\t\treturn lst1\n\t} else {\n\t\treturn lst2\n\t}\n}\n\n", "test": "func TestTotalMatch(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]string{}, TotalMatch([]string{}, []string{}))\n    assert.Equal([]string{\"hi\", \"hi\"}, TotalMatch([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"}))\n    assert.Equal([]string{\"hi\", \"admin\"}, TotalMatch([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}))\n    assert.Equal([]string{\"4\"}, TotalMatch([]string{\"4\"},[]string{\"1\", \"2\", \"3\", \"4\", \"5\"}))\n    assert.Equal([]string{\"hI\", \"Hi\"}, TotalMatch([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}))\n    assert.Equal([]string{\"hI\", \"hi\", \"hi\"}, TotalMatch([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}))\n    assert.Equal([]string{\"hi\", \"admin\"}, TotalMatch([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}))\n    assert.Equal([]string{}, TotalMatch([]string{}, []string{\"this\"}))\n    assert.Equal([]string{}, TotalMatch([]string{\"this\"}, []string{}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestTotalMatch(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]string{}, TotalMatch([]string{}, []string{}))\n    assert.Equal([]string{\"hi\", \"admin\"}, TotalMatch([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}))\n    assert.Equal([]string{\"4\"}, TotalMatch([]string{\"4\"},[]string{\"1\", \"2\", \"3\", \"4\", \"5\"}))\n    assert.Equal([]string{\"hI\", \"Hi\"}, TotalMatch([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}))\n    assert.Equal([]string{\"hI\", \"hi\", \"hi\"}, TotalMatch([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}))\n}\n", "prompt_text": "", "prompt_explain": "Write a function that accepts two lists of strings and returns the list that has\ntotal number of chars in the all strings of the list less than the other list.\n\nif the two lists have the same number of chars, return the first list.\n\nExamples\nTotalMatch([], []) ➞ []\nTotalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\nTotalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\nTotalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\nTotalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n", "func_title": "func TotalMatch(lst1 []string,lst2 []string) []string ", "prompt_text_chinese": "编写一个函数，接受两个字符串列表，并返回列表中所有字符串的总字符数小于另一个列表的列表。如果两个列表的字符数相同，则返回第一个列表"}
{"task_id": "Go/75", "prompt": "\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100.\n// Example:\n// IsMultiplyPrime(30) == true\n// 30 = 2 * 3 * 5\nfunc IsMultiplyPrime(a int) bool {\n", "import": "", "docstring": "// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100.\n// Example:\n// IsMultiplyPrime(30) == true\n// 30 = 2 * 3 * 5\n", "declaration": "\nfunc IsMultiplyPrime(a int) bool {\n", "canonical_solution": "    isPrime := func(n int) bool {\n        for i := 2; i < int(math.Pow(float64(n), 0.5)+1); i++ {\n            if n%i == 0 {\n                return false\n            }\n        }\n        return true\n    }\n    for i := 2; i < 101; i++ {\n\t\tif !isPrime(i) {\n\t\t\tcontinue\n\t\t}\n\t\tfor j := 2; j < 101; j++ {\n\t\t\tif !isPrime(j) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor k := 2; k < 101; k++ {\n\t\t\t\tif !isPrime(k) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif i*j*k == a {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\n", "test": "func TestIsMultiplyPrime(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(false, IsMultiplyPrime(5))\n    assert.Equal(true, IsMultiplyPrime(30))\n    assert.Equal(true, IsMultiplyPrime(8))\n    assert.Equal(false, IsMultiplyPrime(10))\n    assert.Equal(true, IsMultiplyPrime(125))\n    assert.Equal(true, IsMultiplyPrime(3 * 5 * 7))\n    assert.Equal(false, IsMultiplyPrime(3 * 6 * 7))\n    assert.Equal(false, IsMultiplyPrime(9 * 9 * 9))\n    assert.Equal(false, IsMultiplyPrime(11 * 9 * 9))\n    assert.Equal(true, IsMultiplyPrime(11 * 13 * 7))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestIsMultiplyPrime(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, IsMultiplyPrime(30))\n}\n", "prompt_text": "", "prompt_explain": "Write a function that returns true if the given number is the multiplication of 3 prime numbers\nand false otherwise.\nKnowing that (a) is less then 100.\nExample:\nIsMultiplyPrime(30) == true\n30 = 2 * 3 * 5\n", "func_title": "func IsMultiplyPrime(a int) bool ", "prompt_text_chinese": "写一个函数，如果给定的数字是3个质数的乘法，则返回true，否则返回false。知道a小于100"}
{"task_id": "Go/76", "prompt": "\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// IsSimplePower(1, 4) => true\n// IsSimplePower(2, 2) => true\n// IsSimplePower(8, 2) => true\n// IsSimplePower(3, 2) => false\n// IsSimplePower(3, 1) => false\n// IsSimplePower(5, 3) => false\nfunc IsSimplePower(x int,n int) bool {\n", "import": "", "docstring": "// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// IsSimplePower(1, 4) => true\n// IsSimplePower(2, 2) => true\n// IsSimplePower(8, 2) => true\n// IsSimplePower(3, 2) => false\n// IsSimplePower(3, 1) => false\n// IsSimplePower(5, 3) => false\n", "declaration": "\nfunc IsSimplePower(x int,n int) bool {\n", "canonical_solution": "    if x == 1 {\n\t\treturn true\n\t}\n\tif n==1 {\n\t\treturn false\n\t}\n\tif x % n != 0 {\n\t\treturn false\n\t}\n\treturn IsSimplePower(x / n, n)\n}\n\n", "test": "func TestIsSimplePower(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, IsSimplePower(1, 4))\n    assert.Equal(true, IsSimplePower(2, 2))\n    assert.Equal(true, IsSimplePower(8, 2))\n    assert.Equal(false, IsSimplePower(3, 2))\n    assert.Equal(false, IsSimplePower(3, 1))\n    assert.Equal(false, IsSimplePower(5, 3))\n    assert.Equal(true, IsSimplePower(16, 2))\n    assert.Equal(false, IsSimplePower(143214, 16))\n    assert.Equal(true, IsSimplePower(4, 2))\n    assert.Equal(true, IsSimplePower(9, 3))\n    assert.Equal(true, IsSimplePower(16, 4))\n    assert.Equal(false, IsSimplePower(24, 2))\n    assert.Equal(false, IsSimplePower(128, 4))\n    assert.Equal(false, IsSimplePower(12, 6))\n    assert.Equal(true, IsSimplePower(1, 1))\n    assert.Equal(true, IsSimplePower(1, 12))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestIsSimplePower(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, IsSimplePower(1, 4))\n    assert.Equal(true, IsSimplePower(2, 2))\n    assert.Equal(true, IsSimplePower(8, 2))\n    assert.Equal(false, IsSimplePower(3, 2))\n    assert.Equal(false, IsSimplePower(3, 1))\n    assert.Equal(false, IsSimplePower(5, 3))\n}\n", "prompt_text": "", "prompt_explain": "Your task is to write a function that returns true if a number x is a simple\npower of n and false in other cases.\nx is a simple power of n if n**int=x\nFor example:\nIsSimplePower(1, 4) => true\nIsSimplePower(2, 2) => true\nIsSimplePower(8, 2) => true\nIsSimplePower(3, 2) => false\nIsSimplePower(3, 1) => false\nIsSimplePower(5, 3) => false\n", "func_title": "func IsSimplePower(x int,n int) bool ", "prompt_text_chinese": "你的任务是编写一个函数，如果一个数字x是n的简单幂则返回true，其他情况则返回false。如果n**int= X, X是n的简单幂"}
{"task_id": "Go/77", "prompt": "import (\n    \"math\"\n)\n\n// Write a function that takes an integer a and returns true\n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// Iscube(1) ==> true\n// Iscube(2) ==> false\n// Iscube(-1) ==> true\n// Iscube(64) ==> true\n// Iscube(0) ==> true\n// Iscube(180) ==> false\nfunc Iscube(a int) bool {\n", "import": "import (\n    \"math\"\n)", "docstring": "// Write a function that takes an integer a and returns true\n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// Iscube(1) ==> true\n// Iscube(2) ==> false\n// Iscube(-1) ==> true\n// Iscube(64) ==> true\n// Iscube(0) ==> true\n// Iscube(180) ==> false\n", "declaration": "\nfunc Iscube(a int) bool {\n", "canonical_solution": "    abs := math.Abs(float64(a))\n\treturn int(math.Pow(math.Round(math.Pow(abs, 1.0/3.0)), 3.0)) == int(abs)\n}\n\n", "test": "func TestIscube(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, Iscube(1))\n    assert.Equal(false, Iscube(2))\n    assert.Equal(true, Iscube(-1))\n    assert.Equal(true, Iscube(64))\n    assert.Equal(false, Iscube(180))\n    assert.Equal(true, Iscube(1000))\n    assert.Equal(true, Iscube(0))\n    assert.Equal(false, Iscube(1729))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestIscube(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, Iscube(1))\n    assert.Equal(false, Iscube(2))\n    assert.Equal(true, Iscube(-1))\n    assert.Equal(true, Iscube(64))\n    assert.Equal(false, Iscube(180))\n    assert.Equal(true, Iscube(0))\n}\n", "prompt_text": "", "prompt_explain": "Write a function that takes an integer a and returns true\nif this ingeger is a cube of some integer number.\nNote: you may assume the input is always valid.\nExamples:\nIscube(1) ==> true\nIscube(2) ==> false\nIscube(-1) ==> true\nIscube(64) ==> true\nIscube(0) ==> true\nIscube(180) ==> false\n", "func_title": "func Iscube(a int) bool ", "prompt_text_chinese": "编写一个函数，该函数接受一个整数a，如果这个整数是某个整数的立方体，则返回true。注意:你可以假设输入总是有效的。"}
{"task_id": "Go/78", "prompt": "\n// You have been tasked to write a function that receives\n// a hexadecimal number as a string and counts the number of hexadecimal\n// digits that are primes (prime number, or a prime, is a natural number\n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7,\n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string,\n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output should be 2.\nfunc HexKey(num string) int {\n", "import": "", "docstring": "// You have been tasked to write a function that receives\n// a hexadecimal number as a string and counts the number of hexadecimal\n// digits that are primes (prime number, or a prime, is a natural number\n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7,\n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string,\n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output should be 2.\n", "declaration": "\nfunc HexKey(num string) int {\n", "canonical_solution": "    primes := map[int32]interface{}{'2': nil, '3': nil, '5': nil, '7': nil, 'B': nil, 'D': nil}\n\ttotal := 0\n\tfor _, c := range num {\n\t\tif _, ok := primes[c]; ok {\n\t\t\ttotal++\n\t\t}\n\t}\n\treturn total\n}\n\n", "test": "func TestHexKey(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(1, HexKey(\"AB\"))\n    assert.Equal(2, HexKey(\"1077E\"))\n    assert.Equal(4, HexKey(\"ABED1A33\"))\n    assert.Equal(2, HexKey(\"2020\"))\n    assert.Equal(6, HexKey(\"123456789ABCDEF0\"))\n    assert.Equal(12, HexKey(\"112233445566778899AABBCCDDEEFF00\"))\n    assert.Equal(0, HexKey(\"\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestHexKey(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(1, HexKey(\"AB\"))\n    assert.Equal(2, HexKey(\"1077E\"))\n    assert.Equal(4, HexKey(\"ABED1A33\"))\n    assert.Equal(2, HexKey(\"2020\"))\n    assert.Equal(6, HexKey(\"123456789ABCDEF0\"))\n}\n", "prompt_text": "", "prompt_explain": "You have been tasked to write a function that receives\na hexadecimal number as a string and counts the number of hexadecimal\ndigits that are primes (prime number, or a prime, is a natural number\ngreater than 1 that is not a product of two smaller natural numbers).\nHexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\nPrime numbers are 2, 3, 5, 7, 11, 13, 17,...\nSo you have to determine a number of the following digits: 2, 3, 5, 7,\nB (=decimal 11), D (=decimal 13).\nNote: you may assume the input is always correct or empty string,\nand symbols A,B,C,D,E,F are always uppercase.\nExamples:\nFor num = \"AB\" the output should be 1.\nFor num = \"1077E\" the output should be 2.\nFor num = \"ABED1A33\" the output should be 4.\nFor num = \"123456789ABCDEF0\" the output should be 6.\nFor num = \"2020\" the output should be 2.\n", "func_title": "func HexKey(num string) int ", "prompt_text_chinese": "您的任务是编写一个函数，该函数接收一个十六进制数作为字符串，并计算作为质数的十六进制数字的数目(质数或素数是大于1的自然数，而不是两个较小自然数的乘积)。十六进制数字为0,1,2,3,4,5,6,7,8,9,A, B, C, D, E, f，素数为2,3,5,7,11,13,17，…因此，您必须确定以下数字中的一个数:2,3,5,7,B(=十进制11)，D(=十进制13)。注意:您可以假设输入始终是正确的或空字符串，符号A,B,C,D,E,F始终是大写的。"}
{"task_id": "Go/79", "prompt": "import (\n\t\"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// \n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// \n// Examples:\n// DecimalToBinary(15)   # returns \"db1111db\"\n// DecimalToBinary(32)   # returns \"db100000db\"\nfunc DecimalToBinary(decimal int) string {\n", "import": "import (\n\t\"fmt\"\n)", "docstring": "// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// \n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// \n// Examples:\n// DecimalToBinary(15)   # returns \"db1111db\"\n// DecimalToBinary(32)   # returns \"db100000db\"\n", "declaration": "\nfunc DecimalToBinary(decimal int) string {\n", "canonical_solution": "    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\n", "test": "func TestDecimalToBinary(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"db0db\", DecimalToBinary(0))\n    assert.Equal(\"db100000db\", DecimalToBinary(32))\n    assert.Equal(\"db1100111db\", DecimalToBinary(103))\n    assert.Equal(\"db1111db\", DecimalToBinary(15))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestDecimalToBinary(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"db100000db\", DecimalToBinary(32))\n    assert.Equal(\"db1111db\", DecimalToBinary(15))\n}\n", "prompt_text": "", "prompt_explain": "You will be given a number in decimal form and your task is to convert it to\nbinary format. The function should return a string, with each character representing a binary\nnumber. Each character in the string will be '0' or '1'.\n\nThere will be an extra couple of characters 'db' at the beginning and at the end of the string.\nThe extra characters are there to help with the format.\n\nExamples:\nDecimalToBinary(15)   # returns \"db1111db\"\nDecimalToBinary(32)   # returns \"db100000db\"\n", "func_title": "func DecimalToBinary(decimal int) string ", "prompt_text_chinese": "你会得到一个十进制形式的数字，你的任务是把它转换成二进制格式。该函数应返回一个字符串，每个字符表示一个二进制数。字符串中的每个字符都是'0'或'1'。在字符串的开头和结尾会有两个额外的字符'db'。额外的字符是用来帮助格式化的。"}
{"task_id": "Go/80", "prompt": "\n// You are given a string s.\n// Your task is to check if the string is happy or not.\n// A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// IsHappy(a) => false\n// IsHappy(aa) => false\n// IsHappy(abcd) => true\n// IsHappy(aabb) => false\n// IsHappy(adb) => true\n// IsHappy(xyy) => false\nfunc IsHappy(s string) bool {\n", "import": "", "docstring": "// You are given a string s.\n// Your task is to check if the string is happy or not.\n// A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// IsHappy(a) => false\n// IsHappy(aa) => false\n// IsHappy(abcd) => true\n// IsHappy(aabb) => false\n// IsHappy(adb) => true\n// IsHappy(xyy) => false\n", "declaration": "\nfunc IsHappy(s string) bool {\n", "canonical_solution": "    if len(s) < 3 {\n        return false\n    }\n    for i := 0; i < len(s)-2; i++ {\n        if s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2] {\n            return false\n        }\n    }\n    return true\n}\n\n", "test": "func TestIsHappy(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(false, IsHappy(\"a\"), \"a\")\n    assert.Equal(false, IsHappy(\"aa\"), \"aa\")\n    assert.Equal(true, IsHappy(\"abcd\"), \"abcd\")\n    assert.Equal(false, IsHappy(\"aabb\"), \"aabb\")\n    assert.Equal(true, IsHappy(\"adb\"), \"adb\")\n    assert.Equal(false, IsHappy(\"xyy\"), \"xyy\")\n    assert.Equal(true, IsHappy(\"iopaxpoi\"), \"iopaxpoi\")\n    assert.Equal(false, IsHappy(\"iopaxioi\"), \"iopaxioi\")\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestIsHappy(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(false, IsHappy(\"a\"), \"a\")\n    assert.Equal(false, IsHappy(\"aa\"), \"aa\")\n    assert.Equal(true, IsHappy(\"abcd\"), \"abcd\")\n    assert.Equal(false, IsHappy(\"aabb\"), \"aabb\")\n    assert.Equal(true, IsHappy(\"adb\"), \"adb\")\n    assert.Equal(false, IsHappy(\"xyy\"), \"xyy\")\n}\n", "prompt_text": "", "prompt_explain": "You are given a string s.\nYour task is to check if the string is happy or not.\nA string is happy if its length is at least 3 and every 3 consecutive letters are distinct\nFor example:\nIsHappy(a) => false\nIsHappy(aa) => false\nIsHappy(abcd) => true\nIsHappy(aabb) => false\nIsHappy(adb) => true\nIsHappy(xyy) => false\n", "func_title": "func IsHappy(s string) bool ", "prompt_text_chinese": "给你一个字符串s。你的任务是检查这个字符串是否快乐。如果一个字符串的长度至少为3，并且每3个连续的字母都是不同的，则该字符串是有效的"}
{"task_id": "Go/81", "prompt": "\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a list of GPAs for some students and you have to write\n// a function that can output a list of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A\n// > 3.3                A-\n// > 3.0                B+\n// > 2.7                B\n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+\n// > 0.7                D\n// > 0.0                D-\n// 0.0                E\n// \n// \n// Example:\n// grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\nfunc NumericalLetterGrade(grades []float64) []string {\n", "import": "", "docstring": "// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a list of GPAs for some students and you have to write\n// a function that can output a list of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A\n// > 3.3                A-\n// > 3.0                B+\n// > 2.7                B\n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+\n// > 0.7                D\n// > 0.0                D-\n// 0.0                E\n// \n// \n// Example:\n// grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\n", "declaration": "\nfunc NumericalLetterGrade(grades []float64) []string {\n", "canonical_solution": "letter_grade := make([]string, 0, len(grades))\n    for _, gpa := range grades {\n        switch {\n        case gpa == 4.0:\n            letter_grade = append(letter_grade, \"A+\")\n        case gpa > 3.7:\n            letter_grade = append(letter_grade, \"A\")\n        case gpa > 3.3:\n            letter_grade = append(letter_grade, \"A-\")\n        case gpa > 3.0:\n            letter_grade = append(letter_grade, \"B+\")\n        case gpa > 2.7:\n            letter_grade = append(letter_grade, \"B\")\n        case gpa > 2.3:\n            letter_grade = append(letter_grade, \"B-\")\n        case gpa > 2.0:\n            letter_grade = append(letter_grade, \"C+\")\n        case gpa > 1.7:\n            letter_grade = append(letter_grade, \"C\")\n        case gpa > 1.3:\n            letter_grade = append(letter_grade, \"C-\")\n        case gpa > 1.0:\n            letter_grade = append(letter_grade, \"D+\")\n        case gpa > 0.7:\n            letter_grade = append(letter_grade, \"D\")\n        case gpa > 0.0:\n            letter_grade = append(letter_grade, \"D-\")\n        default:\n            letter_grade = append(letter_grade, \"E\")\n        }\n\n    }\n    return letter_grade\n}\n\n", "test": "func TestNumericalLetterGrade(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]string{\"A+\", \"B\", \"C-\", \"C\", \"A-\"}, NumericalLetterGrade([]float64{4.0, 3, 1.7, 2, 3.5}))\n    assert.Equal([]string{\"D+\"}, NumericalLetterGrade([]float64{1.2}))\n    assert.Equal([]string{\"D-\"}, NumericalLetterGrade([]float64{0.5}))\n    assert.Equal([]string{\"E\"}, NumericalLetterGrade([]float64{0.0}))\n    assert.Equal([]string{\"D\", \"D-\", \"C-\", \"B\", \"B+\"}, NumericalLetterGrade([]float64{1, 0.3, 1.5, 2.8, 3.3}))\n    assert.Equal([]string{\"E\", \"D-\"}, NumericalLetterGrade([]float64{0, 0.7}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestNumericalLetterGrade(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]string{\"A+\", \"B\", \"C-\", \"C\", \"A-\"}, NumericalLetterGrade([]float64{4.0, 3, 1.7, 2, 3.5}))\n}\n", "prompt_text": "", "prompt_explain": "It is the last week of the semester and the teacher has to give the grades\nto students. The teacher has been making her own algorithm for grading.\nThe only problem is, she has lost the code she used for grading.\nShe has given you a list of GPAs for some students and you have to write\na function that can output a list of letter grades using the following table:\nGPA       |    Letter grade\n4.0                A+\n> 3.7                A\n> 3.3                A-\n> 3.0                B+\n> 2.7                B\n> 2.3                B-\n> 2.0                C+\n> 1.7                C\n> 1.3                C-\n> 1.0                D+\n> 0.7                D\n> 0.0                D-\n0.0                E\n\n\nExample:\ngrade_equation([4.0, 3, 1.7, 2, 3.5]) ==> [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\n", "func_title": "func NumericalLetterGrade(grades []float64) []string ", "prompt_text_chinese": "这是学期的最后一周，老师要给学生打分。老师一直在制定她自己的评分算法。唯一的问题是，她把评分用的代码弄丢了。她给了你一些学生的GPA列表，你必须写一个函数，可以输出一个字母等级列表，使用下面的表:\n GPA |字母等级4.0 a +\n > 3.7 a > 3.3 a -\n > 3.0 B+\n > 2.7 B > 2.3 B-\n > 2.0 C+\n > 1.7 C > 1.3 C-\n > 1.0 D+\n > 0.7 D > 0.0 D-\n 0.0E"}
{"task_id": "Go/82", "prompt": "\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// PrimeLength('Hello') == true\n// PrimeLength('abcdcba') == true\n// PrimeLength('kittens') == true\n// PrimeLength('orange') == false\nfunc PrimeLength(s string) bool {\n", "import": "", "docstring": "// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// PrimeLength('Hello') == true\n// PrimeLength('abcdcba') == true\n// PrimeLength('kittens') == true\n// PrimeLength('orange') == false\n", "declaration": "\nfunc PrimeLength(s string) bool {\n", "canonical_solution": "    l := len(s)\n    if l == 0 || l == 1 {\n        return false\n    }\n    for i := 2; i < l; i++ {\n        if l%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\n", "test": "func TestPrimeLength(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, PrimeLength(\"Hello\"))\n    assert.Equal(true, PrimeLength(\"abcdcba\"))\n    assert.Equal(true, PrimeLength(\"kittens\"))\n    assert.Equal(false, PrimeLength(\"orange\"))\n    assert.Equal(true, PrimeLength(\"wow\"))\n    assert.Equal(true, PrimeLength(\"world\"))\n    assert.Equal(true, PrimeLength(\"MadaM\"))\n    assert.Equal(true, PrimeLength(\"Wow\"))\n    assert.Equal(false, PrimeLength(\"\"))\n    assert.Equal(true, PrimeLength(\"HI\"))\n    assert.Equal(true, PrimeLength(\"go\"))\n    assert.Equal(false, PrimeLength(\"gogo\"))\n    assert.Equal(false, PrimeLength(\"aaaaaaaaaaaaaaa\"))\n    assert.Equal(true, PrimeLength(\"Madam\"))\n    assert.Equal(false, PrimeLength(\"M\"))\n    assert.Equal(false, PrimeLength(\"0\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestPrimeLength(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, PrimeLength(\"Hello\"))\n    assert.Equal(true, PrimeLength(\"abcdcba\"))\n    assert.Equal(true, PrimeLength(\"kittens\"))\n    assert.Equal(false, PrimeLength(\"orange\"))\n}\n", "prompt_text": "", "prompt_explain": "Write a function that takes a string and returns true if the string\nlength is a prime number or false otherwise\nExamples\nPrimeLength('Hello') == true\nPrimeLength('abcdcba') == true\nPrimeLength('kittens') == true\nPrimeLength('orange') == false\n", "func_title": "func PrimeLength(s string) bool ", "prompt_text_chinese": "编写一个函数，该函数接受一个字符串，如果字符串长度为质数则返回true，否则返回false"}
{"task_id": "Go/83", "prompt": "import (\n    \"math\"\n)\n\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nfunc StartsOneEnds(n int) int {\n", "import": "import (\n    \"math\"\n)\n", "docstring": "// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\n", "declaration": "\nfunc StartsOneEnds(n int) int {\n", "canonical_solution": "    if n == 1 {\n        return 1\n    }\n    return 18 * int(math.Pow(10, float64(n-2)))\n}\n\n", "test": "func TestStartsOneEnds(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(1, StartsOneEnds(1))\n    assert.Equal(18, StartsOneEnds(2))\n    assert.Equal(180, StartsOneEnds(3))\n    assert.Equal(1800, StartsOneEnds(4))\n    assert.Equal(18000, StartsOneEnds(5))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "", "prompt_text": "", "prompt_explain": "Given a positive integer n, return the count of the numbers of n-digit\npositive integers that start or end with 1.\n", "func_title": "func StartsOneEnds(n int) int ", "prompt_text_chinese": "给定一个正整数n，返回以1开始或以1结束的n位正整数的个数的计数。"}
{"task_id": "Go/84", "prompt": "import (\n    \"fmt\"\n    \"strconv\"\n)\n\n// Given a positive integer N, return the total sum of its digits in binary.\n// \n// Example\n// For N = 1000, the sum of digits will be 1 the output should be \"1\".\n// For N = 150, the sum of digits will be 6 the output should be \"110\".\n// For N = 147, the sum of digits will be 12 the output should be \"1100\".\n// \n// Variables:\n// @N integer\n// Constraints: 0 ≤ N ≤ 10000.\n// Output:\n// a string of binary number\nfunc Solve(N int) string {\n", "import": "import (\n    \"fmt\"\n    \"strconv\"\n)\n", "docstring": "// Given a positive integer N, return the total sum of its digits in binary.\n// \n// Example\n// For N = 1000, the sum of digits will be 1 the output should be \"1\".\n// For N = 150, the sum of digits will be 6 the output should be \"110\".\n// For N = 147, the sum of digits will be 12 the output should be \"1100\".\n// \n// Variables:\n// @N integer\n// Constraints: 0 ≤ N ≤ 10000.\n// Output:\n// a string of binary number\n", "declaration": "\nfunc Solve(N int) string {\n", "canonical_solution": "    sum := 0\n    for _, c := range strconv.Itoa(N) {\n        sum += int(c - '0')\n    }\n    return fmt.Sprintf(\"%b\", sum)\n}\n\n", "test": "func TestSolve(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"1\", Solve(1000), \"Error\")\n    assert.Equal(\"110\", Solve(150), \"Error\")\n    assert.Equal(\"1100\", Solve(147), \"Error\")\n    assert.Equal(\"1001\", Solve(333), \"Error\")\n    assert.Equal(\"10010\", Solve(963), \"Error\")\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "", "prompt_text": "", "prompt_explain": "Given a positive integer N, return the total sum of its digits in binary.\n\nExample\nFor N = 1000, the sum of digits will be 1 the output should be \"1\".\nFor N = 150, the sum of digits will be 6 the output should be \"110\".\nFor N = 147, the sum of digits will be 12 the output should be \"1100\".\n\nVariables:\n@N integer\nConstraints: 0 ≤ N ≤ 10000.\nOutput:\na string of binary number\n", "func_title": "func Solve(N int) string ", "prompt_text_chinese": "给定一个正整数N，返回其二进制数字的总和。"}
{"task_id": "Go/85", "prompt": "\n// Given a non-empty list of integers lst. Add the even elements that are at odd indices..\n// \n// Examples:\n// Add([4, 2, 6, 7]) ==> 2\nfunc Add(lst []int) int {\n", "import": "", "docstring": "// Given a non-empty list of integers lst. Add the even elements that are at odd indices..\n// \n// Examples:\n// Add([4, 2, 6, 7]) ==> 2\n", "declaration": "\nfunc Add(lst []int) int {\n", "canonical_solution": "    sum := 0\n    for i := 1; i < len(lst); i += 2 {\n        if lst[i]%2 == 0 {\n            sum += lst[i]\n        }\n    }\n    return sum\n}\n\n", "test": "func TestAdd(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(88, Add([]int{4, 88}))\n    assert.Equal(122, Add([]int{4, 5, 6, 7, 2, 122}))\n    assert.Equal(0, Add([]int{4, 0, 6, 7}))\n    assert.Equal(12, Add([]int{4, 4, 6, 8}))\n}\n    \n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestAdd(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(2, Add([]int{4, 2, 6, 7}))\n}\n", "prompt_text": "", "prompt_explain": "Given a non-empty list of integers lst. Add the even elements that are at odd indices..\n\nExamples:\nAdd([4, 2, 6, 7]) ==> 2\n", "func_title": "func Add(lst []int) int ", "prompt_text_chinese": "给定一个非空的整数列表lst。将奇数下标处的偶数元素相加。"}
{"task_id": "Go/86", "prompt": "import (\n    \"sort\"\n    \"strings\"\n)\n\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// \n// For example:\n// AntiShuffle('Hi') returns 'Hi'\n// AntiShuffle('hello') returns 'ehllo'\n// AntiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\nfunc AntiShuffle(s string) string {\n", "import": "import (\n    \"sort\"\n    \"strings\"\n)\n", "docstring": "// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// \n// For example:\n// AntiShuffle('Hi') returns 'Hi'\n// AntiShuffle('hello') returns 'ehllo'\n// AntiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n", "declaration": "\nfunc AntiShuffle(s string) string {\n", "canonical_solution": "    strs := make([]string, 0)\n    for _, i := range strings.Fields(s) {\n        word := []rune(i)\n        sort.Slice(word, func(i, j int) bool {\n            return word[i] < word[j]\n        })\n        strs = append(strs, string(word))\n    }\n    return strings.Join(strs, \" \")\n}\n\n", "test": "func TestAntiShuffle(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"Hi\", AntiShuffle(\"Hi\"))\n    assert.Equal(\"ehllo\", AntiShuffle(\"hello\"))\n    assert.Equal(\"bemnru\", AntiShuffle(\"number\"))\n    assert.Equal(\"abcd\", AntiShuffle(\"abcd\"))\n    assert.Equal(\"Hello !!!Wdlor\", AntiShuffle(\"Hello World!!!\"))\n    assert.Equal(\"\", AntiShuffle(\"\"))\n    assert.Equal(\".Hi My aemn is Meirst .Rboot How aer ?ouy\", AntiShuffle(\"Hi. My name is Mister Robot. How are you?\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestAntiShuffle(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"Hi\", AntiShuffle(\"Hi\"))\n    assert.Equal(\"ehllo\", AntiShuffle(\"hello\"))\n    assert.Equal(\"Hello !!!Wdlor\", AntiShuffle(\"Hello World!!!\"))\n}\n", "prompt_text": "", "prompt_explain": "Write a function that takes a string and returns an ordered version of it.\nOrdered version of string, is a string where all words (separated by space)\nare replaced by a new word where all the characters arranged in\nascending order based on ascii value.\nNote: You should keep the order of words and blank spaces in the sentence.\n\nFor example:\nAntiShuffle('Hi') returns 'Hi'\nAntiShuffle('hello') returns 'ehllo'\nAntiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n", "func_title": "func AntiShuffle(s string) string ", "prompt_text_chinese": "编写一个函数，该函数接受一个字符串并返回该字符串的有序版本。字符串的有序版本，是一个字符串，其中所有单词(由空格分隔)都被一个新单词替换，其中所有字符根据ascii值升序排列。注意:你应该保持句子中单词的顺序和空格。"}
{"task_id": "Go/87", "prompt": "import (\n    \"sort\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// \n// Examples:\n// GetRow([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n// [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// GetRow([], 1) == []\n// GetRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc GetRow(lst [][]int, x int) [][2]int {\n", "import": "import (\n    \"sort\"\n)\n", "docstring": "// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// \n// Examples:\n// GetRow([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n// [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// GetRow([], 1) == []\n// GetRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n", "declaration": "\nfunc GetRow(lst [][]int, x int) [][2]int {\n", "canonical_solution": "    coords := make([][2]int, 0)\n    for i, row := range lst {\n        for j, item := range row {\n            if item == x {\n                coords = append(coords, [2]int{i, j})\n            }\n        }\n    }\n    sort.Slice(coords, func(i, j int) bool {\n        if coords[i][0] == coords[j][0] {\n            return coords[i][1] > coords[j][1]\n        }\n        return coords[i][0] < coords[j][0]\n    })\n\n    return coords\n}\n\n", "test": "func TestGetRow(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([][2]int{{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}, GetRow([][]int{\n        {1, 2, 3, 4, 5, 6},\n        {1, 2, 3, 4, 1, 6},\n        {1, 2, 3, 4, 5, 1},\n    }, 1))\n    assert.Equal([][2]int{{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}}, GetRow([][]int{\n        {1, 2, 3, 4, 5, 6},\n        {1, 2, 3, 4, 5, 6},\n        {1, 2, 3, 4, 5, 6},\n        {1, 2, 3, 4, 5, 6},\n        {1, 2, 3, 4, 5, 6},\n        {1, 2, 3, 4, 5, 6},\n    }, 2))\n    assert.Equal([][2]int{{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}}, GetRow([][]int{\n        {1, 2, 3, 4, 5, 6},\n        {1, 2, 3, 4, 5, 6},\n        {1, 1, 3, 4, 5, 6},\n        {1, 2, 1, 4, 5, 6},\n        {1, 2, 3, 1, 5, 6},\n        {1, 2, 3, 4, 1, 6},\n        {1, 2, 3, 4, 5, 1},\n    }, 1))\n    assert.Equal([][2]int{}, GetRow([][]int{{}}, 1))\n    assert.Equal([][2]int{}, GetRow([][]int{{1}}, 2))\n    assert.Equal([][2]int{{2, 2}}, GetRow([][]int{{}, {1}, {1, 2, 3}}, 3))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestGetRow(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([][2]int{{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}, GetRow([][]int{\n        {1, 2, 3, 4, 5, 6},\n        {1, 2, 3, 4, 1, 6},\n        {1, 2, 3, 4, 5, 1},\n    }, 1))\n    assert.Equal([][2]int{}, GetRow([][]int{{}}, 1))\n    assert.Equal([][2]int{{2, 2}}, GetRow([][]int{{}, {1}, {1, 2, 3}}, 3))\n}\n", "prompt_text": "", "prompt_explain": "You are given a 2 dimensional data, as a nested lists,\nwhich is similar to matrix, however, unlike matrices,\neach row may contain a different number of columns.\nGiven lst, and integer x, find integers x in the list,\nand return list of tuples, [(x1, y1), (x2, y2) ...] such that\neach tuple is a coordinate - (row, columns), starting with 0.\nSort coordinates initially by rows in ascending order.\nAlso, sort coordinates of the row by columns in descending order.\n\nExamples:\nGetRow([\n[1,2,3,4,5,6],\n[1,2,3,4,1,6],\n[1,2,3,4,5,1]\n], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nGetRow([], 1) == []\nGetRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n", "func_title": "func GetRow(lst [][]int, x int) [][2]int ", "prompt_text_chinese": "给定一个二维数据，作为一个嵌套列表，它类似于矩阵，但与矩阵不同的是，每行可能包含不同数量的列。给定lst和整数x，在列表中找到整数x，并返回元组列表，[(x1, y1)， (x2, y2)…]这样每个元组都是一个坐标-(行，列)，从0开始。最初按行升序对坐标排序。\n同样，按列降序排序行坐标。"}
{"task_id": "Go/88", "prompt": "import (\n    \"sort\"\n)\n\n// Given an array of non-negative integers, return a copy of the given array after sorting,\n// you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// \n// Note:\n// * don't change the given array.\n// \n// Examples:\n// * SortArray([]) => []\n// * SortArray([5]) => [5]\n// * SortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n// * SortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\nfunc SortArray(array []int) []int {\n", "import": "import (\n    \"sort\"\n)\n", "docstring": "// Given an array of non-negative integers, return a copy of the given array after sorting,\n// you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// \n// Note:\n// * don't change the given array.\n// \n// Examples:\n// * SortArray([]) => []\n// * SortArray([5]) => [5]\n// * SortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n// * SortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n", "declaration": "\nfunc SortArray(array []int) []int {\n", "canonical_solution": "    arr := make([]int, len(array))\n    copy(arr, array)\n    if len(arr) == 0 {\n        return arr\n    }\n    if (arr[0]+arr[len(arr)-1])%2 == 0 {\n        sort.Slice(arr, func(i, j int) bool {\n            return arr[i] > arr[j]\n        })\n    } else {\n        sort.Slice(arr, func(i, j int) bool {\n            return arr[i] < arr[j]\n        })\n    }\n    return arr\n}\n\n", "test": "func TestSortArray(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{}, SortArray([]int{}), \"Error\")\n    assert.Equal([]int{5}, SortArray([]int{5}), \"Error\")\n    assert.Equal([]int{0, 1, 2, 3, 4, 5}, SortArray([]int{2, 4, 3, 0, 1, 5}), \"Error\")\n    assert.Equal([]int{6, 5, 4, 3, 2, 1, 0}, SortArray([]int{2, 4, 3, 0, 1, 5, 6}), \"Error\")\n    assert.Equal([]int{1, 2}, SortArray([]int{2, 1}), \"Error\")\n    assert.Equal([]int{0, 11, 15, 32, 42, 87}, SortArray([]int{15, 42, 87, 32, 11, 0}), \"Error\")\n    assert.Equal([]int{23, 21, 14, 11}, SortArray([]int{21, 14, 23, 11}), \"Error\")\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSortArray(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{}, SortArray([]int{}), \"Error\")\n    assert.Equal([]int{5}, SortArray([]int{5}), \"Error\")\n    assert.Equal([]int{0, 1, 2, 3, 4, 5}, SortArray([]int{2, 4, 3, 0, 1, 5}), \"Error\")\n    assert.Equal([]int{6, 5, 4, 3, 2, 1, 0}, SortArray([]int{2, 4, 3, 0, 1, 5, 6}), \"Error\")\n}\n", "prompt_text": "", "prompt_explain": "Given an array of non-negative integers, return a copy of the given array after sorting,\nyou will sort the given array in ascending order if the sum( first index value, last index value) is odd,\nor sort it in descending order if the sum( first index value, last index value) is even.\n\nNote:\n* don't change the given array.\n\nExamples:\n* SortArray([]) => []\n* SortArray([5]) => [5]\n* SortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n* SortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n", "func_title": "func SortArray(array []int) []int ", "prompt_text_chinese": "给定一个非负整数数组，在排序后返回给定数组的副本，如果和(第一个索引值，最后一个索引值)是奇数，则按升序排序，如果和(第一个索引值，最后一个索引值)是偶数，则按降序排序。注意:*不要改变给定的数组。"}
{"task_id": "Go/89", "prompt": "import (\n    \"strings\"\n)\n\n// Create a function Encrypt that takes a string as an argument and\n// returns a string Encrypted with the alphabet being rotated.\n// The alphabet should be rotated in a manner such that the letters\n// shift down by two multiplied to two places.\n// For example:\n// Encrypt('hi') returns 'lm'\n// Encrypt('asdfghjkl') returns 'ewhjklnop'\n// Encrypt('gf') returns 'kj'\n// Encrypt('et') returns 'ix'\nfunc Encrypt(s string) string {\n", "import": "import (\n    \"strings\"\n)\n", "docstring": "// Create a function Encrypt that takes a string as an argument and\n// returns a string Encrypted with the alphabet being rotated.\n// The alphabet should be rotated in a manner such that the letters\n// shift down by two multiplied to two places.\n// For example:\n// Encrypt('hi') returns 'lm'\n// Encrypt('asdfghjkl') returns 'ewhjklnop'\n// Encrypt('gf') returns 'kj'\n// Encrypt('et') returns 'ix'\n", "declaration": "\nfunc Encrypt(s string) string {\n", "canonical_solution": "    d := \"abcdefghijklmnopqrstuvwxyz\"\n    out := make([]rune, 0, len(s))\n    for _, c := range s {\n        pos := strings.IndexRune(d, c)\n        if pos != -1 {\n            out = append(out, []rune(d)[(pos+2*2)%26])\n        } else {\n            out = append(out, c)\n        }\n    }\n    return string(out)\n}\n\n", "test": "func TestEncrypt(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"lm\", Encrypt(\"hi\"))\n    assert.Equal(\"ewhjklnop\", Encrypt(\"asdfghjkl\"))\n    assert.Equal(\"kj\", Encrypt(\"gf\"))\n    assert.Equal(\"ix\", Encrypt(\"et\"))\n    assert.Equal(\"jeiajeaijeiak\", Encrypt(\"faewfawefaewg\"))\n    assert.Equal(\"lippsqcjvmirh\", Encrypt(\"hellomyfriend\"))\n    assert.Equal(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\", Encrypt(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"))\n    assert.Equal(\"e\", Encrypt(\"a\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestEncrypt(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"lm\", Encrypt(\"hi\"))\n    assert.Equal(\"ewhjklnop\", Encrypt(\"asdfghjkl\"))\n    assert.Equal(\"kj\", Encrypt(\"gf\"))\n    assert.Equal(\"ix\", Encrypt(\"et\"))\n}\n", "prompt_text": "", "prompt_explain": "Create a function Encrypt that takes a string as an argument and\nreturns a string Encrypted with the alphabet being rotated.\nThe alphabet should be rotated in a manner such that the letters\nshift down by two multiplied to two places.\nFor example:\nEncrypt('hi') returns 'lm'\nEncrypt('asdfghjkl') returns 'ewhjklnop'\nEncrypt('gf') returns 'kj'\nEncrypt('et') returns 'ix'\n", "func_title": "func Encrypt(s string) string ", "prompt_text_chinese": "创建一个函数Encrypt，该函数以字符串作为参数，并返回一个经过旋转的字母加密的字符串。字母表应该以这样的方式旋转，即字母向下移动两个乘到两个位置。"}
{"task_id": "Go/90", "prompt": "import (\n    \"math\"\n    \"sort\"\n)\n\n// You are given a list of integers.\n// Write a function NextSmallest() that returns the 2nd smallest element of the list.\n// Return nil if there is no such element.\n// \n// NextSmallest([1, 2, 3, 4, 5]) == 2\n// NextSmallest([5, 1, 4, 3, 2]) == 2\n// NextSmallest([]) == nil\n// NextSmallest([1, 1]) == nil\nfunc NextSmallest(lst []int) interface{} {\n", "import": "import (\n    \"math\"\n    \"sort\"\n)\n", "docstring": "// You are given a list of integers.\n// Write a function NextSmallest() that returns the 2nd smallest element of the list.\n// Return nil if there is no such element.\n// \n// NextSmallest([1, 2, 3, 4, 5]) == 2\n// NextSmallest([5, 1, 4, 3, 2]) == 2\n// NextSmallest([]) == nil\n// NextSmallest([1, 1]) == nil\n", "declaration": "\nfunc NextSmallest(lst []int) interface{} {\n", "canonical_solution": "    set := make(map[int]struct{})\n    for _, i := range lst {\n        set[i] = struct{}{}\n    }\n    vals := make([]int, 0, len(set))\n    for k := range set {\n        vals = append(vals, k)\n    }\n    sort.Slice(vals, func(i, j int) bool {\n        return vals[i] < vals[j]\n    })\n    if len(vals) < 2 {\n        return nil\n    }\n    return vals[1]\n}\n\n", "test": "func TestNextSmallest(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(2, NextSmallest([]int{1, 2, 3, 4, 5}))\n    assert.Equal(2, NextSmallest([]int{5, 1, 4, 3, 2}))\n    assert.Equal(nil, NextSmallest([]int{}))\n    assert.Equal(nil, NextSmallest([]int{1, 1}))\n    assert.Equal(1, NextSmallest([]int{1,1,1,1,0}))\n    assert.Equal(nil, NextSmallest([]int{1, int(math.Pow(0, 0))}))\n    assert.Equal(-35, NextSmallest([]int{-35, 34, 12, -45}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"math\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestNextSmallest(t *testing.T) {\n  assert := assert.New(t)\n   assert.Equal(2+0*int(math.Pow(0, 0)), NextSmallest([]int{1, 2, 3, 4, 5}))\n    assert.Equal(2, NextSmallest([]int{5, 1, 4, 3, 2}))\n    assert.Equal(nil, NextSmallest([]int{}))\n    assert.Equal(nil, NextSmallest([]int{1, 1}))\n}\n", "prompt_text": "", "prompt_explain": "You are given a list of integers.\nWrite a function NextSmallest() that returns the 2nd smallest element of the list.\nReturn nil if there is no such element.\n\nNextSmallest([1, 2, 3, 4, 5]) == 2\nNextSmallest([5, 1, 4, 3, 2]) == 2\nNextSmallest([]) == nil\nNextSmallest([1, 1]) == nil\n", "func_title": "func NextSmallest(lst []int) interface{} ", "prompt_text_chinese": "给你一个整数列表。编写一个函数nextminimal()，返回列表中第2小的元素。如果没有这样的元素，则返回nil。"}
{"task_id": "Go/91", "prompt": "import (\n    \"regexp\"\n)\n\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// \n// For example:\n// >>> IsBored(\"Hello world\")\n// 0\n// >>> IsBored(\"The sky is blue. The sun is shining. I love this weather\")\n// 1\nfunc IsBored(S string) int {\n", "import": "import (\n    \"regexp\"\n)\n", "docstring": "// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// \n// For example:\n// >>> IsBored(\"Hello world\")\n// 0\n// >>> IsBored(\"The sky is blue. The sun is shining. I love this weather\")\n// 1\n", "declaration": "\nfunc IsBored(S string) int {\n", "canonical_solution": "    r, _ := regexp.Compile(`[.?!]\\s*`)\n    sentences := r.Split(S, -1)\n    sum := 0\n    for _, s := range sentences {\n        if len(s) >= 2 && s[:2] == \"I \" {\n            sum++\n        }\n    }\n    return sum\n}\n\n", "test": "func TestIsBored(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(0, IsBored(\"Hello world\"), \"Test 1\")\n    assert.Equal(0, IsBored(\"Is the sky blue?\"), \"Test 2\")\n    assert.Equal(1, IsBored(\"I love It !\"), \"Test 3\")\n    assert.Equal(0, IsBored(\"bIt\"), \"Test 4\")\n    assert.Equal(2, IsBored(\"I feel good today. I will be productive. will kill It\"), \"Test 5\")\n    assert.Equal(0, IsBored(\"You and I are going for a walk\"), \"Test 6\")\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestIsBored(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(0, IsBored(\"Hello world\"), \"Test 1\")\n    assert.Equal(1, IsBored(\"The sky is blue. The sun is shining. I love this weather\"), \"Test 3\")\n}\n", "prompt_text": "You'll be given a string of words, and your task is to count the number of boredoms. A boredom is a sentence that starts with the word \"I\". Sentences are delimited by '.', '?' or '!'.  For example:", "prompt_explain": "You'll be given a string of words, and your task is to count the number\nof boredoms. A boredom is a sentence that starts with the word \"I\".\nSentences are delimited by '.', '?' or '!'.\n\nFor example:\n>>> IsBored(\"Hello world\")\n0\n>>> IsBored(\"The sky is blue. The sun is shining. I love this weather\")\n1\n", "func_title": "func IsBored(S string) int ", "prompt_text_chinese": "给你一串单词，你的任务是数无聊的东西有多少。无聊是以“I”开头的句子。句子用'分隔。“,”?'或'!'。"}
{"task_id": "Go/92", "prompt": "\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// \n// Examples\n// AnyInt(5, 2, 7) ➞ true\n// \n// AnyInt(3, 2, 2) ➞ false\n// \n// AnyInt(3, -2, 1) ➞ true\n// \n// AnyInt(3.6, -2.2, 2) ➞ false\nfunc AnyInt(x, y, z interface{}) bool {\n", "import": "", "docstring": "// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// \n// Examples\n// AnyInt(5, 2, 7) ➞ true\n// \n// AnyInt(3, 2, 2) ➞ false\n// \n// AnyInt(3, -2, 1) ➞ true\n// \n// AnyInt(3.6, -2.2, 2) ➞ false\n", "declaration": "\nfunc AnyInt(x, y, z interface{}) bool {\n", "canonical_solution": "    xx, ok := x.(int)\n    if !ok {\n        return false\n    }\n    yy, ok := y.(int)\n    if !ok {\n        return false\n    }\n    zz, ok := z.(int)\n    if !ok {\n        return false\n    }\n\n    if (xx+yy == zz) || (xx+zz == yy) || (yy+zz == xx) {\n        return true\n    }\n    return false\n}\n\n", "test": "func TestAnyInt(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, AnyInt(2, 3, 1))\n    assert.Equal(false, AnyInt(2.5, 2, 3))\n    assert.Equal(false, AnyInt(1.5, 5, 3.5))\n    assert.Equal(false, AnyInt(2, 6, 2))\n    assert.Equal(true, AnyInt(4, 2, 2))\n    assert.Equal(false, AnyInt(2.2, 2.2, 2.2))\n    assert.Equal(true, AnyInt(-4, 6, 2))\n    assert.Equal(true, AnyInt(2, 1, 1))\n    assert.Equal(true, AnyInt(3, 4, 7))\n    assert.Equal(false, AnyInt(3.0, 4, 7))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestAnyInt(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, AnyInt(5, 2, 7))\n    assert.Equal(false, AnyInt(3, 2, 2))\n    assert.Equal(true, AnyInt(3, -2, 1))\n    assert.Equal(false, AnyInt(3.6, -2.2, 2))\n}\n", "prompt_text": "", "prompt_explain": "Create a function that takes 3 numbers.\nReturns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\nReturns false in any other cases.\n\nExamples\nAnyInt(5, 2, 7) ➞ true\n\nAnyInt(3, 2, 2) ➞ false\n\nAnyInt(3, -2, 1) ➞ true\n\nAnyInt(3.6, -2.2, 2) ➞ false\n", "func_title": "func AnyInt(x, y, z interface{}) bool ", "prompt_text_chinese": "创建一个带有3个数字的函数。如果其中一个数字等于其他两个数字的和，并且所有数字都是整数，则返回true。在任何其他情况下返回false。"}
{"task_id": "Go/93", "prompt": "import (\n    \"strings\"\n)\n\n// Write a function that takes a message, and Encodes in such a\n// way that it swaps case of all letters, replaces all vowels in\n// the message with the letter that appears 2 places ahead of that\n// vowel in the english alphabet.\n// Assume only letters.\n// \n// Examples:\n// >>> Encode('test')\n// 'TGST'\n// >>> Encode('This is a message')\n// 'tHKS KS C MGSSCGG'\nfunc Encode(message string) string {\n", "import": "import (\n    \"strings\"\n)\n", "docstring": "// Write a function that takes a message, and Encodes in such a\n// way that it swaps case of all letters, replaces all vowels in\n// the message with the letter that appears 2 places ahead of that\n// vowel in the english alphabet.\n// Assume only letters.\n// \n// Examples:\n// >>> Encode('test')\n// 'TGST'\n// >>> Encode('This is a message')\n// 'tHKS KS C MGSSCGG'\n", "declaration": "\nfunc Encode(message string) string {\n", "canonical_solution": "    vowels := \"aeiouAEIOU\"\n    vowels_replace := make(map[rune]rune)\n    for _, c := range vowels {\n        vowels_replace[c] = c + 2\n    }\n    result := make([]rune, 0, len(message))\n    for _, c := range message {\n        if 'a' <= c && c <= 'z' {\n            c += 'A' - 'a'\n        } else if 'A' <= c && c <= 'Z' {\n            c += 'a' - 'A'\n        }\n        if strings.ContainsRune(vowels, c) {\n            result = append(result, vowels_replace[c])\n        } else {\n            result = append(result, c)\n        }\n    }\n    return string(result)\n}\n\n", "test": "func TestEncode(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"tgst\", Encode(\"TEST\"))\n    assert.Equal(\"mWDCSKR\", Encode(\"Mudasir\"))\n    assert.Equal(\"ygs\", Encode(\"YES\"))\n    assert.Equal(\"tHKS KS C MGSSCGG\", Encode(\"This is a message\"))\n    assert.Equal(\"k dQnT kNqW wHcT Tq wRkTg\", Encode(\"I DoNt KnOw WhAt tO WrItE\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestEncode(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"TGST\", Encode(\"test\"))\n    assert.Equal(\"tHKS KS C MGSSCGG\", Encode(\"This is a message\"))\n}\n", "prompt_text": "Write a function that takes a message, and Encodes in such a way that it swaps case of all letters, replaces all vowels in the message with the letter that appears 2 places ahead of that vowel in the english alphabet. Assume only letters.  Examples:", "prompt_explain": "Write a function that takes a message, and Encodes in such a\nway that it swaps case of all letters, replaces all vowels in\nthe message with the letter that appears 2 places ahead of that\nvowel in the english alphabet.\nAssume only letters.\n\nExamples:\n>>> Encode('test')\n'TGST'\n>>> Encode('This is a message')\n'tHKS KS C MGSSCGG'\n", "func_title": "func Encode(message string) string ", "prompt_text_chinese": "编写一个函数，该函数接受一个消息，并以这样一种方式进行编码，即交换所有字母的大小写，将消息中的所有元音替换为在英语字母表中出现在该元音前面2位的字母。假设只有字母。"}
{"task_id": "Go/94", "prompt": "import (\n    \"math\"\n    \"strconv\"\n)\n\n// You are given a list of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// \n// Examples:\n// For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n// For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n// For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n// For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n// For lst = [0,81,12,3,1,21] the output should be 3\n// For lst = [0,8,1,2,1,7] the output should be 7\nfunc Skjkasdkd(lst []int) int {\n", "import": "import (\n    \"math\"\n    \"strconv\"\n)\n", "docstring": "// You are given a list of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// \n// Examples:\n// For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n// For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n// For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n// For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n// For lst = [0,81,12,3,1,21] the output should be 3\n// For lst = [0,8,1,2,1,7] the output should be 7\n", "declaration": "\nfunc Skjkasdkd(lst []int) int {\n", "canonical_solution": "    isPrime := func(n int) bool {\n        for i := 2; i < int(math.Pow(float64(n), 0.5)+1); i++ {\n            if n%i == 0 {\n                return false\n            }\n        }\n        return true\n    }\n    maxx := 0\n    i := 0\n    for i < len(lst) {\n        if lst[i] > maxx && isPrime(lst[i]) {\n            maxx = lst[i]\n        }\n        i++\n    }\n    sum := 0\n    for _, d := range strconv.Itoa(maxx) {\n        sum += int(d - '0')\n    }\n    return sum\n}\n\n", "test": "func TestSkjkasdkd(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(10, Skjkasdkd([]int{0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3}))\n    assert.Equal(25, Skjkasdkd([]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1}))\n    assert.Equal(13, Skjkasdkd([]int{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3}))\n    assert.Equal(11, Skjkasdkd([]int{0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6}))\n    assert.Equal(3, Skjkasdkd([]int{0, 81, 12, 3, 1, 21}))\n    assert.Equal(7, Skjkasdkd([]int{0, 8, 1, 2, 1, 7}))\n    assert.Equal(19, Skjkasdkd([]int{8191}))\n    assert.Equal(19, Skjkasdkd([]int{8191, 123456, 127, 7}))\n    assert.Equal(10, Skjkasdkd([]int{127, 97, 8192}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSkjkasdkd(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(10, Skjkasdkd([]int{0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3}))\n    assert.Equal(25, Skjkasdkd([]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1}))\n    assert.Equal(13, Skjkasdkd([]int{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3}))\n    assert.Equal(11, Skjkasdkd([]int{0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6}))\n    assert.Equal(3, Skjkasdkd([]int{0, 81, 12, 3, 1, 21}))\n    assert.Equal(7, Skjkasdkd([]int{0, 8, 1, 2, 1, 7}))\n}\n", "prompt_text": "", "prompt_explain": "You are given a list of integers.\nYou need to find the largest prime value and return the sum of its digits.\n\nExamples:\nFor lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\nFor lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\nFor lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\nFor lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\nFor lst = [0,81,12,3,1,21] the output should be 3\nFor lst = [0,8,1,2,1,7] the output should be 7\n", "func_title": "func Skjkasdkd(lst []int) int ", "prompt_text_chinese": "给你一个整数列表。您需要找到最大的质数，并返回其数字的和。"}
{"task_id": "Go/95", "prompt": "import (\n    \"strings\"\n)\n\n// Given a dictionary, return true if all keys are strings in lower\n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given dictionary is empty.\n// Examples:\n// CheckDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n// CheckDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n// CheckDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n// CheckDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n// CheckDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\nfunc CheckDictCase(dict map[interface{}]interface{}) bool {\n", "import": "import (\n    \"strings\"\n)\n", "docstring": "// Given a dictionary, return true if all keys are strings in lower\n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given dictionary is empty.\n// Examples:\n// CheckDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n// CheckDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n// CheckDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n// CheckDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n// CheckDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n", "declaration": "\nfunc CheckDictCase(dict map[interface{}]interface{}) bool {\n", "canonical_solution": "    if len(dict) == 0 {\n        return false\n    }\n    state := \"start\"\n    key := \"\"\n    ok := false\n    for k := range dict {\n        if key, ok = k.(string); !ok {\n            state = \"mixed\"\n            break\n        }\n        if state == \"start\" {\n            if key == strings.ToUpper(key) {\n                state = \"upper\"\n            } else if key == strings.ToLower(key) {\n                state = \"lower\"\n            } else {\n                break\n            }\n        } else if (state == \"upper\" && key != strings.ToUpper(key)) || (state == \"lower\" && key != strings.ToLower(key)) {\n            state = \"mixed\"\n            break\n        } else {\n            break\n        }\n    }\n    return state == \"upper\" || state == \"lower\"\n}\n\n", "test": "func TestCheckDictCase(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, CheckDictCase(map[interface{}]interface{}{\"p\": \"pineapple\", \"b\": \"banana\"}))\n    assert.Equal(false, CheckDictCase(map[interface{}]interface{}{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}))\n    assert.Equal(false, CheckDictCase(map[interface{}]interface{}{\"p\": \"pineapple\", 5: \"banana\", \"a\": \"apple\"}))\n    assert.Equal(false, CheckDictCase(map[interface{}]interface{}{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}))\n    assert.Equal(true, CheckDictCase(map[interface{}]interface{}{\"STATE\": \"NC\", \"ZIP\": \"12345\"}))\n    assert.Equal(true, CheckDictCase(map[interface{}]interface{}{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}))\n    assert.Equal(false, CheckDictCase(map[interface{}]interface{}{}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestCheckDictCase(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, CheckDictCase(map[interface{}]interface{}{\"p\": \"pineapple\", \"b\": \"banana\"}))\n    assert.Equal(false, CheckDictCase(map[interface{}]interface{}{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}))\n    assert.Equal(false, CheckDictCase(map[interface{}]interface{}{\"p\": \"pineapple\", 8: \"banana\", \"a\": \"apple\"}))\n    assert.Equal(false, CheckDictCase(map[interface{}]interface{}{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}))\n    assert.Equal(true, CheckDictCase(map[interface{}]interface{}{\"STATE\": \"NC\", \"ZIP\": \"12345\"}))\n}\n", "prompt_text": "", "prompt_explain": "Given a dictionary, return true if all keys are strings in lower\ncase or all keys are strings in upper case, else return false.\nThe function should return false is the given dictionary is empty.\nExamples:\nCheckDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\nCheckDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\nCheckDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\nCheckDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\nCheckDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n", "func_title": "func CheckDictCase(dict map[interface{}]interface{}) bool ", "prompt_text_chinese": "给定一个字典，如果所有键都是小写字符串或所有键都是大写字符串则返回true，否则返回false。如果给定的字典为空，函数应返回false。"}
{"task_id": "Go/96", "prompt": "\n// Implement a function that takes an non-negative integer and returns an array of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// CountUpTo(5) => [2,3]\n// CountUpTo(11) => [2,3,5,7]\n// CountUpTo(0) => []\n// CountUpTo(20) => [2,3,5,7,11,13,17,19]\n// CountUpTo(1) => []\n// CountUpTo(18) => [2,3,5,7,11,13,17]\nfunc CountUpTo(n int) []int {\n", "import": "", "docstring": "// Implement a function that takes an non-negative integer and returns an array of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// CountUpTo(5) => [2,3]\n// CountUpTo(11) => [2,3,5,7]\n// CountUpTo(0) => []\n// CountUpTo(20) => [2,3,5,7,11,13,17,19]\n// CountUpTo(1) => []\n// CountUpTo(18) => [2,3,5,7,11,13,17]\n", "declaration": "\nfunc CountUpTo(n int) []int {\n", "canonical_solution": "    primes := make([]int, 0)\n    for i := 2; i < n; i++ {\n        is_prime := true\n        for j := 2; j < i; j++ {\n            if i%j == 0 {\n                is_prime = false\n                break\n            }\n        }\n        if is_prime {\n            primes = append(primes, i)\n        }\n    }\n    return primes\n}\n\n", "test": "func TestCountUpTo(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{2, 3}, CountUpTo(5))\n    assert.Equal([]int{2, 3, 5}, CountUpTo(6))\n    assert.Equal([]int{2, 3, 5}, CountUpTo(7))\n    assert.Equal([]int{2, 3, 5, 7}, CountUpTo(10))\n    assert.Equal([]int{}, CountUpTo(0))\n    assert.Equal([]int{2, 3, 5, 7, 11, 13, 17, 19}, CountUpTo(22))\n    assert.Equal([]int{}, CountUpTo(1))\n    assert.Equal([]int{2, 3, 5, 7, 11, 13, 17}, CountUpTo(18))\n    assert.Equal([]int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43}, CountUpTo(47))\n    assert.Equal([]int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}, CountUpTo(101))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestCountUpTo(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{2, 3}, CountUpTo(5))\n    assert.Equal([]int{2, 3, 5, 7}, CountUpTo(11))\n    assert.Equal([]int{}, CountUpTo(0))\n    assert.Equal([]int{2, 3, 5, 7, 11, 13, 17, 19}, CountUpTo(20))\n    assert.Equal([]int{}, CountUpTo(1))\n    assert.Equal([]int{2, 3, 5, 7, 11, 13, 17}, CountUpTo(18))\n}\n", "prompt_text": "", "prompt_explain": "Implement a function that takes an non-negative integer and returns an array of the first n\nintegers that are prime numbers and less than n.\nfor example:\nCountUpTo(5) => [2,3]\nCountUpTo(11) => [2,3,5,7]\nCountUpTo(0) => []\nCountUpTo(20) => [2,3,5,7,11,13,17,19]\nCountUpTo(1) => []\nCountUpTo(18) => [2,3,5,7,11,13,17]\n", "func_title": "func CountUpTo(n int) []int ", "prompt_text_chinese": "实现一个函数，该函数接受一个非负整数，并返回一个由前n个小于n的素数组成的数组。"}
{"task_id": "Go/97", "prompt": "import (\n    \"math\"\n)\n\n// Complete the function that takes two integers and returns\n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// Multiply(148, 412) should return 16.\n// Multiply(19, 28) should return 72.\n// Multiply(2020, 1851) should return 0.\n// Multiply(14,-15) should return 20.\nfunc Multiply(a, b int) int {\n", "import": "import (\n    \"math\"\n)\n", "docstring": "// Complete the function that takes two integers and returns\n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// Multiply(148, 412) should return 16.\n// Multiply(19, 28) should return 72.\n// Multiply(2020, 1851) should return 0.\n// Multiply(14,-15) should return 20.\n", "declaration": "\nfunc Multiply(a, b int) int {\n", "canonical_solution": "    return int(math.Abs(float64(a%10)) * math.Abs(float64(b%10)))\n}\n\n", "test": "func TestMultiply(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(16, Multiply(148, 412))\n    assert.Equal(72, Multiply(19, 28))\n    assert.Equal(0, Multiply(2020, 1851))\n    assert.Equal(20, Multiply(14, -15))\n    assert.Equal(42, Multiply(76, 67))\n    assert.Equal(49, Multiply(17, 27))\n    assert.Equal(0, Multiply(0, 1))\n    assert.Equal(0, Multiply(0, 0))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestMultiply(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(16, Multiply(148, 412))\n    assert.Equal(72, Multiply(19, 28))\n    assert.Equal(0, Multiply(2020, 1851))\n    assert.Equal(20, Multiply(14, -15))\n}\n", "prompt_text": "", "prompt_explain": "Complete the function that takes two integers and returns\nthe product of their unit digits.\nAssume the input is always valid.\nExamples:\nMultiply(148, 412) should return 16.\nMultiply(19, 28) should return 72.\nMultiply(2020, 1851) should return 0.\nMultiply(14,-15) should return 20.\n", "func_title": "func Multiply(a, b int) int ", "prompt_text_chinese": "完成接受两个整数并返回其个位数乘积的函数。假设输入总是有效的。示例:乘法(148,412)应该返回16。乘以(19,28)应该返回72。乘以(2020,1851)应该返回0。乘(14，-15)应该返回20。"}
{"task_id": "Go/98", "prompt": "import (\n    \"strings\"\n)\n\n// Given a string s, count the number of uppercase vowels in even indices.\n// \n// For example:\n// CountUpper('aBCdEf') returns 1\n// CountUpper('abcdefg') returns 0\n// CountUpper('dBBE') returns 0\nfunc CountUpper(s string) int {\n", "import": "import (\n    \"strings\"\n)\n", "docstring": "// Given a string s, count the number of uppercase vowels in even indices.\n// \n// For example:\n// CountUpper('aBCdEf') returns 1\n// CountUpper('abcdefg') returns 0\n// CountUpper('dBBE') returns 0\n", "declaration": "\nfunc CountUpper(s string) int {\n", "canonical_solution": "    count := 0\n    runes := []rune(s)\n    for i := 0; i < len(runes); i += 2 {\n        if strings.ContainsRune(\"AEIOU\", runes[i]) {\n            count += 1\n        }\n    }\n    return count\n}\n\n", "test": "func TestCountUpper(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(1, CountUpper(\"aBCdEf\"))\n    assert.Equal(0, CountUpper(\"abcdefg\"))\n    assert.Equal(0, CountUpper(\"dBBE\"))\n    assert.Equal(0, CountUpper(\"B\"))\n    assert.Equal(1, CountUpper(\"U\"))\n    assert.Equal(0, CountUpper(\"\"))\n    assert.Equal(2, CountUpper(\"EEEE\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestCountUpper(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(1, CountUpper(\"aBCdEf\"))\n    assert.Equal(0, CountUpper(\"abcdefg\"))\n    assert.Equal(0, CountUpper(\"dBBE\"))\n}\n", "prompt_text": "", "prompt_explain": "Given a string s, count the number of uppercase vowels in even indices.\n\nFor example:\nCountUpper('aBCdEf') returns 1\nCountUpper('abcdefg') returns 0\nCountUpper('dBBE') returns 0\n", "func_title": "func CountUpper(s string) int ", "prompt_text_chinese": "给定一个字符串s，数偶数下标中大写元音的个数。"}
{"task_id": "Go/99", "prompt": "import (\n    \"math\"\n    \"strconv\"\n    \"strings\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// \n// Examples\n// >>> ClosestInteger(\"10\")\n// 10\n// >>> ClosestInteger(\"15.3\")\n// 15\n// \n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example ClosestInteger(\"14.5\") should\n// return 15 and ClosestInteger(\"-14.5\") should return -15.\nfunc ClosestInteger(value string) int {\n", "import": "import (\n    \"math\"\n    \"strconv\"\n    \"strings\"\n)\n", "docstring": "// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// \n// Examples\n// >>> ClosestInteger(\"10\")\n// 10\n// >>> ClosestInteger(\"15.3\")\n// 15\n// \n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example ClosestInteger(\"14.5\") should\n// return 15 and ClosestInteger(\"-14.5\") should return -15.\n", "declaration": "\nfunc ClosestInteger(value string) int {\n", "canonical_solution": "    if strings.Count(value, \".\") == 1 {\n        // remove trailing zeros\n        for value[len(value)-1] == '0' {\n            value = value[:len(value)-1]\n        }\n    }\n    var res float64\n    num, _ := strconv.ParseFloat(value, 64)\n    if len(value) >= 2 && value[len(value)-2:] == \".5\" {\n        if num > 0 {\n            res = math.Ceil(num)\n        } else {\n            res = math.Floor(num)\n        }\n    } else if len(value) > 0 {\n        res = math.Round(num)\n    } else {\n        res = 0\n    }\n\n    return int(res)\n}\n\n", "test": "func TestClosestInteger(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(10, ClosestInteger(\"10\"))\n    assert.Equal(15, ClosestInteger(\"14.5\"))\n    assert.Equal(-16, ClosestInteger(\"-15.5\"))\n    assert.Equal(15, ClosestInteger(\"15.3\"))\n    assert.Equal(0, ClosestInteger(\"0\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestClosestInteger(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(10, ClosestInteger(\"10\"))\n    assert.Equal(15, ClosestInteger(\"15.3\"))\n}\n", "prompt_text": "Create a function that takes a value (string) representing a number and returns the closest integer to it. If the number is equidistant from two integers, round it away from zero.  Examples", "prompt_explain": "Create a function that takes a value (string) representing a number\nand returns the closest integer to it. If the number is equidistant\nfrom two integers, round it away from zero.\n\nExamples\n>>> ClosestInteger(\"10\")\n10\n>>> ClosestInteger(\"15.3\")\n15\n\nNote:\nRounding away from zero means that if the given number is equidistant\nfrom two integers, the one you should return is the one that is the\nfarthest from zero. For example ClosestInteger(\"14.5\") should\nreturn 15 and ClosestInteger(\"-14.5\") should return -15.\n", "func_title": "func ClosestInteger(value string) int ", "prompt_text_chinese": "创建一个函数，接受一个表示数字的值(字符串)，并返回与之最接近的整数。如果数字与两个整数等距，则将其舍入至零。"}
{"task_id": "Go/100", "prompt": "\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a list, where element at index\n// i represents the number of stones in the level (i+1).\n// \n// Examples:\n// >>> MakeAPile(3)\n// [3, 5, 7]\nfunc MakeAPile(n int) []int {\n", "import": "", "docstring": "// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a list, where element at index\n// i represents the number of stones in the level (i+1).\n// \n// Examples:\n// >>> MakeAPile(3)\n// [3, 5, 7]\n", "declaration": "\nfunc MakeAPile(n int) []int {\n", "canonical_solution": "    result := make([]int, 0, n)\n    for i := 0; i < n; i++ {\n        result = append(result, n+2*i)\n    }\n    return result\n}\n\n", "test": "func TestMakeAPile(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{3, 5, 7}, MakeAPile(3))\n    assert.Equal([]int{4, 6, 8, 10}, MakeAPile(4))\n    assert.Equal([]int{5, 7, 9, 11, 13}, MakeAPile(5))\n    assert.Equal([]int{6, 8, 10, 12, 14, 16}, MakeAPile(6))\n    assert.Equal([]int{8, 10, 12, 14, 16, 18, 20, 22}, MakeAPile(8))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestMakeAPile(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{3, 5, 7}, MakeAPile(3))\n}\n", "prompt_text": "Given a positive integer n, you have to make a pile of n levels of stones. The first level has n stones. The number of stones in the next level is: - the next odd number if n is odd. - the next even number if n is even. Return the number of stones in each level in a list, where element at index i represents the number of stones in the level (i+1).  Examples:", "prompt_explain": "Given a positive integer n, you have to make a pile of n levels of stones.\nThe first level has n stones.\nThe number of stones in the next level is:\n- the next odd number if n is odd.\n- the next even number if n is even.\nReturn the number of stones in each level in a list, where element at index\ni represents the number of stones in the level (i+1).\n\nExamples:\n>>> MakeAPile(3)\n[3, 5, 7]\n", "func_title": "func MakeAPile(n int) []int ", "prompt_text_chinese": "给定正整数n，你要堆n层石头。第一关有n个石头。下一层的石头数量是:-如果n是奇数，则下一个奇数。-如果n是偶数，则下一个偶数。返回列表中每一层的石头数量，其中元素索引i表示该层的石头数量(i+1)。"}
{"task_id": "Go/101", "prompt": "import (\n    \"strings\"\n)\n\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return an array of the words.\n// \n// For example:\n// WordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n// WordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\nfunc WordsString(s string) []string {\n", "import": "import (\n    \"strings\"\n)\n", "docstring": "// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return an array of the words.\n// \n// For example:\n// WordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n// WordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n", "declaration": "\nfunc WordsString(s string) []string {\n", "canonical_solution": "    s_list := make([]rune, 0)\n\n    for _, c := range s {\n        if c == ',' {\n            s_list = append(s_list, ' ')\n        } else {\n            s_list = append(s_list, c)\n        }\n    }\n    return strings.Fields(string(s_list))\n}\n\n", "test": "func TestWordsString(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]string{\"Hi\", \"my\", \"name\", \"is\", \"John\"}, WordsString(\"Hi, my name is John\"))\n    assert.Equal([]string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}, WordsString(\"One, two, three, four, five, six\"))\n    assert.Equal([]string{}, WordsString(\"\"))\n    assert.Equal([]string{\"Hi\", \"my\", \"name\"}, WordsString(\"Hi, my name\"))\n    assert.Equal([]string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}, WordsString(\"One,, two, three, four, five, six,\"))\n    assert.Equal([]string{\"ahmed\", \"gamal\"}, WordsString(\"ahmed     , gamal\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestWordsString(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]string{\"Hi\", \"my\", \"name\", \"is\", \"John\"}, WordsString(\"Hi, my name is John\"))\n    assert.Equal([]string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}, WordsString(\"One, two, three, four, five, six\"))\n}\n", "prompt_text": "", "prompt_explain": "You will be given a string of words separated by commas or spaces. Your task is\nto split the string into words and return an array of the words.\n\nFor example:\nWordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\nWordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n", "func_title": "func WordsString(s string) []string ", "prompt_text_chinese": "你将得到一串由逗号或空格分隔的单词。您的任务是将字符串拆分为单词并返回单词数组。"}
{"task_id": "Go/102", "prompt": "\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If\n// there's no such number, then the function should return -1.\n// \n// For example:\n// ChooseNum(12, 15) = 14\n// ChooseNum(13, 12) = -1\nfunc ChooseNum(x, y int) int {\n", "import": "", "docstring": "// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If\n// there's no such number, then the function should return -1.\n// \n// For example:\n// ChooseNum(12, 15) = 14\n// ChooseNum(13, 12) = -1\n", "declaration": "\nfunc ChooseNum(x, y int) int {\n", "canonical_solution": "    if x > y {\n        return -1\n    }\n    if y % 2 == 0 {\n        return y\n    }\n    if x == y {\n        return -1\n    }\n    return y - 1\n}\n\n", "test": "func TestChooseNum(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(14, ChooseNum(12,15))\n    assert.Equal(-1, ChooseNum(13,12))\n    assert.Equal(12354, ChooseNum(33,12354))\n    assert.Equal(-1, ChooseNum(5234,5233))\n    assert.Equal(28, ChooseNum(6,29))\n    assert.Equal(-1, ChooseNum(27,10))\n    assert.Equal(-1, ChooseNum(7,7))\n    assert.Equal(546, ChooseNum(546,546))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestChooseNum(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(14, ChooseNum(12,15))\n    assert.Equal(-1, ChooseNum(13,12))\n}\n", "prompt_text": "", "prompt_explain": "This function takes two positive numbers x and y and returns the\nbiggest even integer number that is in the range [x, y] inclusive. If\nthere's no such number, then the function should return -1.\n\nFor example:\nChooseNum(12, 15) = 14\nChooseNum(13, 12) = -1\n", "func_title": "func ChooseNum(x, y int) int ", "prompt_text_chinese": "此函数接受两个正数x和y，并返回包含[x, y]的范围内最大的偶数。如果没有这样的数字，那么函数应该返回-1。"}
{"task_id": "Go/103", "prompt": "import (\n    \"fmt\"\n    \"math\"\n)\n\n// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m).\n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// RoundedAvg(1, 5) => \"0b11\"\n// RoundedAvg(7, 5) => -1\n// RoundedAvg(10, 20) => \"0b1111\"\n// RoundedAvg(20, 33) => \"0b11010\"\nfunc RoundedAvg(n, m int) interface{} {\n", "import": "import (\n    \"fmt\"\n    \"math\"\n)\n", "docstring": "// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m).\n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// RoundedAvg(1, 5) => \"0b11\"\n// RoundedAvg(7, 5) => -1\n// RoundedAvg(10, 20) => \"0b1111\"\n// RoundedAvg(20, 33) => \"0b11010\"\n", "declaration": "\nfunc RoundedAvg(n, m int) interface{} {\n", "canonical_solution": "    if m < n {\n        return -1\n    }\n    summation := 0\n    for i := n;i < m+1;i++{\n        summation += i\n    }\n    return fmt.Sprintf(\"0b%b\", int(math.Round(float64(summation)/float64(m - n + 1))))\n}\n\n", "test": "func TestRoundedAvg(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"0b11\", RoundedAvg(1, 5))\n    assert.Equal(\"0b1010\", RoundedAvg(7, 13))\n    assert.Equal(\"0b1111001011\", RoundedAvg(964, 977))\n    assert.Equal(\"0b1111100101\", RoundedAvg(996, 997))\n    assert.Equal(\"0b1011000010\", RoundedAvg(560, 851))\n    assert.Equal(\"0b101101110\", RoundedAvg(185, 546))\n    assert.Equal(\"0b110101101\", RoundedAvg(362, 496))\n    assert.Equal(\"0b1001110010\", RoundedAvg(350, 902))\n    assert.Equal(\"0b11010111\", RoundedAvg(197, 233))\n    assert.Equal(-1, RoundedAvg(7, 5))\n    assert.Equal(-1, RoundedAvg(5, 1))\n    assert.Equal(\"0b101\", RoundedAvg(5, 5))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestRoundedAvg(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"0b11\", RoundedAvg(1, 5))\n    assert.Equal(-1, RoundedAvg(7, 5))\n    assert.Equal(\"0b1111\", RoundedAvg(10, 20))\n    assert.Equal(\"0b11011\", RoundedAvg(20, 33))\n}\n", "prompt_text": "", "prompt_explain": "You are given two positive integers n and m, and your task is to compute the\naverage of the integers from n through m (including n and m).\nRound the answer to the nearest integer and convert that to binary.\nIf n is greater than m, return -1.\nExample:\nRoundedAvg(1, 5) => \"0b11\"\nRoundedAvg(7, 5) => -1\nRoundedAvg(10, 20) => \"0b1111\"\nRoundedAvg(20, 33) => \"0b11010\"\n", "func_title": "func RoundedAvg(n, m int) interface{} ", "prompt_text_chinese": "你有两个正整数n和m，你的任务是计算从n到m的整数的平均值(包括n和m)。四舍五入到最接近的整数并将其转换为二进制。如果n大于m，则返回-1。"}
{"task_id": "Go/104", "prompt": "import (\n    \"sort\"\n    \"strconv\"\n)\n\n// Given a list of positive integers x. return a sorted list of all\n// elements that hasn't any even digit.\n// \n// Note: Returned list should be sorted in increasing order.\n// \n// For example:\n// >>> UniqueDigits([15, 33, 1422, 1])\n// [1, 15, 33]\n// >>> UniqueDigits([152, 323, 1422, 10])\n// []\nfunc UniqueDigits(x []int) []int {\n", "import": "import (\n    \"sort\"\n    \"strconv\"\n)\n", "docstring": "// Given a list of positive integers x. return a sorted list of all\n// elements that hasn't any even digit.\n// \n// Note: Returned list should be sorted in increasing order.\n// \n// For example:\n// >>> UniqueDigits([15, 33, 1422, 1])\n// [1, 15, 33]\n// >>> UniqueDigits([152, 323, 1422, 10])\n// []\n", "declaration": "\nfunc UniqueDigits(x []int) []int {\n", "canonical_solution": "    odd_digit_elements := make([]int, 0)\n    OUTER:\n    for _, i := range x {\n        for _, c := range strconv.Itoa(i) {\n            if (c - '0') % 2 == 0 {\n                continue OUTER\n            }\n        }\n            odd_digit_elements = append(odd_digit_elements, i)\n    }\n    sort.Slice(odd_digit_elements, func(i, j int) bool {\n        return odd_digit_elements[i] < odd_digit_elements[j]\n    })\n    return odd_digit_elements\n}\n\n", "test": "func TestUniqueDigits(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{1, 15, 33}, UniqueDigits([]int{15, 33, 1422, 1}))\n    assert.Equal([]int{}, UniqueDigits([]int{152, 323, 1422, 10}))\n    assert.Equal([]int{111, 151}, UniqueDigits([]int{12345, 2033, 111, 151}))\n    assert.Equal([]int{31, 135}, UniqueDigits([]int{135, 103, 31}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestUniqueDigits(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{1, 15, 33}, UniqueDigits([]int{15, 33, 1422, 1}))\n    assert.Equal([]int{}, UniqueDigits([]int{152, 323, 1422, 10}))\n}\n", "prompt_text": "Given a list of positive integers x. return a sorted list of all elements that hasn't any even digit.  Note: Returned list should be sorted in increasing order.  For example:", "prompt_explain": "Given a list of positive integers x. return a sorted list of all\nelements that hasn't any even digit.\n\nNote: Returned list should be sorted in increasing order.\n\nFor example:\n>>> UniqueDigits([15, 33, 1422, 1])\n[1, 15, 33]\n>>> UniqueDigits([152, 323, 1422, 10])\n[]\n", "func_title": "func UniqueDigits(x []int) []int ", "prompt_text_chinese": "给定一个正整数列表，x返回一个由所有不含偶数的元素组成的有序列表。备注:返回的列表应按递增顺序排序。"}
{"task_id": "Go/105", "prompt": "import (\n    \"sort\"\n)\n\n// Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting array, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// \n// For example:\n// arr = [2, 1, 1, 4, 5, 8, 2, 3]\n// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8]\n// -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n// return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n// \n// If the array is empty, return an empty array:\n// arr = []\n// return []\n// \n// If the array has any strange number ignore it:\n// arr = [1, -1 , 55]\n// -> sort arr -> [-1, 1, 55]\n// -> reverse arr -> [55, 1, -1]\n// return = ['One']\nfunc ByLength(arr []int)[]string {\n", "import": "import (\n    \"sort\"\n)\n", "docstring": "// Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting array, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// \n// For example:\n// arr = [2, 1, 1, 4, 5, 8, 2, 3]\n// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8]\n// -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n// return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n// \n// If the array is empty, return an empty array:\n// arr = []\n// return []\n// \n// If the array has any strange number ignore it:\n// arr = [1, -1 , 55]\n// -> sort arr -> [-1, 1, 55]\n// -> reverse arr -> [55, 1, -1]\n// return = ['One']\n", "declaration": "\nfunc ByLength(arr []int)[]string {\n", "canonical_solution": "    dic := map[int]string{\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sort.Slice(arr, func(i, j int) bool {\n        return arr[i] > arr[j]\n    })\n    new_arr := make([]string, 0)\n    for _, item := range arr {\n        if v, ok := dic[item]; ok {\n            new_arr = append(new_arr, v)\n        }\n    }\n    return new_arr\n}\n\n", "test": "func TestByLength(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"}, ByLength([]int{2, 1, 1, 4, 5, 8, 2, 3}))\n    assert.Equal([]string{}, ByLength([]int{}))\n    assert.Equal([]string{\"One\"}, ByLength([]int{1, -1 , 55}))\n    assert.Equal([]string{\"Three\", \"Two\", \"One\"}, ByLength([]int{1, -1, 3, 2}))\n    assert.Equal([]string{\"Nine\", \"Eight\", \"Four\"}, ByLength([]int{9, 4, 8}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestByLength(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"}, ByLength([]int{2, 1, 1, 4, 5, 8, 2, 3}))\n    assert.Equal([]string{}, ByLength([]int{}))\n    assert.Equal([]string{\"One\"}, ByLength([]int{1, -1 , 55}))\n    assert.Equal([]string{\"Three\", \"Two\", \"One\"}, ByLength([]int{1, -1, 3, 2}))\n    assert.Equal([]string{\"Nine\", \"Eight\", \"Four\"}, ByLength([]int{9, 4, 8}))\n}\n", "prompt_text": "", "prompt_explain": "Given an array of integers, sort the integers that are between 1 and 9 inclusive,\nreverse the resulting array, and then replace each digit by its corresponding name from\n\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\nFor example:\narr = [2, 1, 1, 4, 5, 8, 2, 3]\n-> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8]\n-> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\nreturn [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n\nIf the array is empty, return an empty array:\narr = []\nreturn []\n\nIf the array has any strange number ignore it:\narr = [1, -1 , 55]\n-> sort arr -> [-1, 1, 55]\n-> reverse arr -> [55, 1, -1]\nreturn = ['One']\n", "func_title": "func ByLength(arr []int)[]string ", "prompt_text_chinese": "给定一个整数数组，对1到9之间的整数排序，反转结果数组，然后用“1”、“2”、“3”、“4”、“5”、“6”、“7”、“8”、“9”中的对应名称替换每个数字。"}
{"task_id": "Go/106", "prompt": " \n// Implement the Function F that takes n as a parameter,\n// and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// F(5) == [1, 2, 6, 24, 15]\nfunc F(n int) []int {\n", "import": "", "docstring": "\n// Implement the Function F that takes n as a parameter,\n// and returns a list oF size n, such that the value oF the element at index i is the Factorial oF i iF i is even\n// or the sum oF numbers From 1 to i otherwise.\n// i starts From 1.\n// the Factorial oF i is the multiplication oF the numbers From 1 to i (1 * 2 * ... * i).\n// Example:\n// F(5) == [1, 2, 6, 24, 15]\n", "declaration": "\nfunc F(n int) []int {\n", "canonical_solution": "    ret := make([]int, 0, 5)\n    for i:=1;i<n+1;i++{\n        if i%2 == 0 {\n            x := 1\n            for j:=1;j<i+1;j++{\n                x*=j\n            }\n            ret = append(ret, x)\n        }else {\n            x := 0\n            for j:=1;j<i+1;j++{\n                x+=j\n            }\n            ret = append(ret, x)\n        }\n    }\n    return ret\n}\n\n", "test": "func TestF(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{1, 2, 6, 24, 15}, F(5))\n    assert.Equal([]int{1, 2, 6, 24, 15, 720, 28}, F(7))\n    assert.Equal([]int{1}, F(1))\n    assert.Equal([]int{1,2,6}, F(3))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestF(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{1, 2, 6, 24, 15}, F(5))\n}\n", "prompt_text": "", "prompt_explain": "\nImplement the Function F that takes n as a parameter,\nand returns a list oF size n, such that the value oF the element at index i is the Factorial oF i iF i is even\nor the sum oF numbers From 1 to i otherwise.\ni starts From 1.\nthe Factorial oF i is the multiplication oF the numbers From 1 to i (1 * 2 * ... * i).\nExample:\nF(5) == [1, 2, 6, 24, 15]\n", "func_title": "func F(n int) []int ", "prompt_text_chinese": "实现函数F，以n为参数，返回一个大小为n的列表，这样，如果i是偶数，则索引i处的元素的值为i的阶乘，否则为从1到i的数字的和。i从1开始。i的阶乘是从1到i的数的乘法(1 * 2 *…*我)。"}
{"task_id": "Go/107", "prompt": "import (\n    \"strconv\"\n)\n\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// \n// Example 1:\n// \n// Input: 3\n// Output: (1, 2)\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// \n// Example 2:\n// \n// Input: 12\n// Output: (4, 6)\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// \n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nfunc EvenOddPalindrome(n int) [2]int {\n", "import": "import (\n    \"strconv\"\n)\n", "docstring": "// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// \n// Example 1:\n// \n// Input: 3\n// Output: (1, 2)\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// \n// Example 2:\n// \n// Input: 12\n// Output: (4, 6)\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// \n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\n", "declaration": "\nfunc EvenOddPalindrome(n int) [2]int {\n", "canonical_solution": "    is_palindrome := func (n int) bool {\n        s := strconv.Itoa(n)\n        for i := 0;i < len(s)>>1;i++ {\n            if s[i] != s[len(s)-i-1] {\n                return false\n            }\n        }\n        return true\n    }\n\n    even_palindrome_count := 0\n    odd_palindrome_count := 0\n\n    for i :=1;i<n+1;i++ {\n        if i%2 == 1 && is_palindrome(i){\n                odd_palindrome_count ++\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count ++\n        }\n    }\n    return [2]int{even_palindrome_count, odd_palindrome_count}\n}\n\n", "test": "func TestEvenOddPalindrome(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([2]int{8,13}, EvenOddPalindrome(123))\n    assert.Equal([2]int{4,6}, EvenOddPalindrome(12))\n    assert.Equal([2]int{1,2}, EvenOddPalindrome(3))\n    assert.Equal([2]int{6,8}, EvenOddPalindrome(63))\n    assert.Equal([2]int{5,6}, EvenOddPalindrome(25))\n    assert.Equal([2]int{4,6}, EvenOddPalindrome(19))\n    assert.Equal([2]int{4,5}, EvenOddPalindrome(9))\n    assert.Equal([2]int{0,1}, EvenOddPalindrome(1))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestEvenOddPalindrome(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([2]int{4,6}, EvenOddPalindrome(12))\n    assert.Equal([2]int{1,2}, EvenOddPalindrome(3))\n}\n", "prompt_text": "", "prompt_explain": "Given a positive integer n, return a tuple that has the number of even and odd\ninteger palindromes that fall within the range(1, n), inclusive.\n\nExample 1:\n\nInput: 3\nOutput: (1, 2)\nExplanation:\nInteger palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\nExample 2:\n\nInput: 12\nOutput: (4, 6)\nExplanation:\nInteger palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\nNote:\n1. 1 <= n <= 10^3\n2. returned tuple has the number of even and odd integer palindromes respectively.\n", "func_title": "func EvenOddPalindrome(n int) [2]int ", "prompt_text_chinese": "给定一个正整数n，返回一个元组，其中包含(1,n)范围内的偶数和奇数整数回文。"}
{"task_id": "Go/108", "prompt": "import (\n    \"math\"\n    \"strconv\"\n)\n\n// Write a function CountNums which takes an array of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> CountNums([]) == 0\n// >>> CountNums([-1, 11, -11]) == 1\n// >>> CountNums([1, 1, 2]) == 3\nfunc CountNums(arr []int) int {\n", "import": "import (\n    \"math\"\n    \"strconv\"\n)\n", "docstring": "// Write a function CountNums which takes an array of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> CountNums([]) == 0\n// >>> CountNums([-1, 11, -11]) == 1\n// >>> CountNums([1, 1, 2]) == 3\n", "declaration": "\nfunc CountNums(arr []int) int {\n", "canonical_solution": "    digits_sum:= func (n int) int {\n        neg := 1\n        if n < 0 {\n             n, neg = -1 * n, -1 \n        }\n        r := make([]int,0)\n        for _, c := range strconv.Itoa(n) {\n            r = append(r, int(c-'0'))\n        }\n        r[0] *= neg\n        sum := 0\n        for _, i := range r {\n            sum += i\n        }\n        return sum\n    }\n    count := 0\n    for _, i := range arr {\n        x := digits_sum(i)\n        if x > 0 {\n            count++\n        }\n    }\n    return count\n}\n\n", "test": "func TestCountNums(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(0, CountNums([]int{}))\n    assert.Equal(0, CountNums([]int{-1, -2, 0}))\n    assert.Equal(6, CountNums([]int{1, 1, 2, -2, 3, 4, 5}))\n    assert.Equal(5, CountNums([]int{1, 6, 9, -6, 0, 1, 5}))\n    assert.Equal(4, CountNums([]int{1, 100, 98, -7, 1, -1}))\n    assert.Equal(5, CountNums([]int{12, 23, 34, -45, -56, 0}))\n    assert.Equal(1, CountNums([]int{-0, int(math.Pow(1, 0))}))\n    assert.Equal(1, CountNums([]int{1}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"math\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestCountNums(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(0+0*int(math.Pow(0, 0)), CountNums([]int{}))\n    assert.Equal(1, CountNums([]int{-1, 11, -11}))\n    assert.Equal(3, CountNums([]int{1, 1, 2}))\n}\n", "prompt_text": "Write a function CountNums which takes an array of integers and returns the number of elements which has a sum of digits > 0. If a number is negative, then its first signed digit will be negative: e.g. -123 has signed digits -1, 2, and 3.", "prompt_explain": "Write a function CountNums which takes an array of integers and returns\nthe number of elements which has a sum of digits > 0.\nIf a number is negative, then its first signed digit will be negative:\ne.g. -123 has signed digits -1, 2, and 3.\n>>> CountNums([]) == 0\n>>> CountNums([-1, 11, -11]) == 1\n>>> CountNums([1, 1, 2]) == 3\n", "func_title": "func CountNums(arr []int) int ", "prompt_text_chinese": "编写一个函数CountNums，该函数接受一个整数数组，并返回具有数字> 0和的元素数。如果一个数字是负的，那么它的第一个有符号的数字将是负的:例如-123有符号的数字-1、2和3。"}
{"task_id": "Go/109", "prompt": "import (\n    \"math\"\n    \"sort\"\n)\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will be randomly ordered. Your task is to determine if\n// it is possible to get an array sorted in non-decreasing order by performing\n// the following operation on the given array:\n// You are allowed to perform right shift operation any number of times.\n// \n// One right shift operation means shifting all elements of the array by one\n// position in the right direction. The last element of the array will be moved to\n// the starting position in the array i.e. 0th index.\n// \n// If it is possible to obtain the sorted array by performing the above operation\n// then return true else return false.\n// If the given array is empty then return true.\n// \n// Note: The given list is guaranteed to have unique elements.\n// \n// For Example:\n// \n// MoveOneBall([3, 4, 5, 1, 2])==>true\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given array.\n// MoveOneBall([3, 5, 4, 1, 2])==>false\n// Explanation:It is not possible to get non-decreasing order for the given\n// array by performing any number of right shift operations.\nfunc MoveOneBall(arr []int) bool {\n", "import": "import (\n    \"math\"\n    \"sort\"\n)\n", "docstring": "// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will be randomly ordered. Your task is to determine if\n// it is possible to get an array sorted in non-decreasing order by performing\n// the following operation on the given array:\n// You are allowed to perform right shift operation any number of times.\n// \n// One right shift operation means shifting all elements of the array by one\n// position in the right direction. The last element of the array will be moved to\n// the starting position in the array i.e. 0th index.\n// \n// If it is possible to obtain the sorted array by performing the above operation\n// then return true else return false.\n// If the given array is empty then return true.\n// \n// Note: The given list is guaranteed to have unique elements.\n// \n// For Example:\n// \n// MoveOneBall([3, 4, 5, 1, 2])==>true\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given array.\n// MoveOneBall([3, 5, 4, 1, 2])==>false\n// Explanation:It is not possible to get non-decreasing order for the given\n// array by performing any number of right shift operations.\n", "declaration": "\nfunc MoveOneBall(arr []int) bool {\n", "canonical_solution": "    if len(arr)==0 {\n      return true\n    }\n    sorted_array := make([]int, len(arr))\n    copy(sorted_array, arr)\n    sort.Slice(sorted_array, func(i, j int) bool {\n        return sorted_array[i] < sorted_array[j]\n    })    \n    min_value := math.MaxInt\n    min_index := -1\n    for i, x := range arr {\n        if i < min_value {\n            min_index, min_value = i, x\n        }\n    }\n    my_arr := make([]int, len(arr[min_index:]))\n    copy(my_arr, arr[min_index:])\n    my_arr = append(my_arr, arr[0:min_index]...)\n    for i :=0;i<len(arr);i++ {\n      if my_arr[i]!=sorted_array[i]{\n        return false\n      }\n    }\n    return true\n}\n\n", "test": "func TestMoveOneBall(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, MoveOneBall([]int{3, 4, 5, 1, 2}))\n    assert.Equal(true, MoveOneBall([]int{3, 5, 10, 1, 2}))\n    assert.Equal(false, MoveOneBall([]int{4, 3, 1, 2}))\n    assert.Equal(false, MoveOneBall([]int{3, 5, 4, 1, 2}))\n    assert.Equal(true, MoveOneBall([]int{}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestMoveOneBall(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, MoveOneBall([]int{3, 4, 5, 1, 2}))\n    assert.Equal(false, MoveOneBall([]int{3, 5, 4, 1, 2}))\n}\n", "prompt_text": "", "prompt_explain": "We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\nnumbers in the array will be randomly ordered. Your task is to determine if\nit is possible to get an array sorted in non-decreasing order by performing\nthe following operation on the given array:\nYou are allowed to perform right shift operation any number of times.\n\nOne right shift operation means shifting all elements of the array by one\nposition in the right direction. The last element of the array will be moved to\nthe starting position in the array i.e. 0th index.\n\nIf it is possible to obtain the sorted array by performing the above operation\nthen return true else return false.\nIf the given array is empty then return true.\n\nNote: The given list is guaranteed to have unique elements.\n\nFor Example:\n\nMoveOneBall([3, 4, 5, 1, 2])==>true\nExplanation: By performin 2 right shift operations, non-decreasing order can\nbe achieved for the given array.\nMoveOneBall([3, 5, 4, 1, 2])==>false\nExplanation:It is not possible to get non-decreasing order for the given\narray by performing any number of right shift operations.\n", "func_title": "func MoveOneBall(arr []int) bool ", "prompt_text_chinese": "我们有一个N个整数的数组'arr' arr[1]， arr[2]，…, arr [N]。数组中的数字将是随机排序的。您的任务是确定是否有可能通过对给定数组执行以下操作以非递减顺序排序数组:您被允许执行右移操作任意次数。一次右移操作意味着将数组的所有元素向右移动一个位置。数组的最后一个元素将被移动到数组的起始位置，即第0个索引。如果可以通过执行上述操作获得排序后的数组，则返回true，否则返回false。如果给定数组为空，则返回true。注意:给定的列表保证有唯一的元素。"}
{"task_id": "Go/110", "prompt": "\n// In this problem, you will implement a function that takes two lists of numbers,\n// and determines whether it is possible to perform an Exchange of elements\n// between them to make lst1 a list of only even numbers.\n// There is no limit on the number of Exchanged elements between lst1 and lst2.\n// If it is possible to Exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// Exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n// Exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n// It is assumed that the input lists will be non-empty.\nfunc Exchange(lst1, lst2 []int) string {\n", "import": "", "docstring": "// In this problem, you will implement a function that takes two lists of numbers,\n// and determines whether it is possible to perform an Exchange of elements\n// between them to make lst1 a list of only even numbers.\n// There is no limit on the number of Exchanged elements between lst1 and lst2.\n// If it is possible to Exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// Exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n// Exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n// It is assumed that the input lists will be non-empty.\n", "declaration": "\nfunc Exchange(lst1, lst2 []int) string {\n", "canonical_solution": "    odd := 0\n    even := 0\n    for _, i := range lst1 {\n        if i%2 == 1 {\n            odd++\n        }\n    }\n    for _, i := range lst2 {\n        if i%2 == 0 {\n            even++\n        }\n    }\n    if even >= odd {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n            \n\n", "test": "func TestExchange(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"YES\", Exchange([]int{1, 2, 3, 4}, []int{1, 2, 3, 4}))\n    assert.Equal(\"NO\", Exchange([]int{1, 2, 3, 4}, []int{1, 5, 3, 4}))\n    assert.Equal(\"YES\", Exchange([]int{1, 2, 3, 4}, []int{2, 1, 4, 3}))\n    assert.Equal(\"YES\", Exchange([]int{5, 7, 3}, []int{2, 6, 4}))\n    assert.Equal(\"NO\", Exchange([]int{5, 7, 3}, []int{2, 6, 3}))\n    assert.Equal(\"NO\", Exchange([]int{3, 2, 6, 1, 8, 9}, []int{3, 5, 5, 1, 1, 1}))\n    assert.Equal(\"YES\", Exchange([]int{100, 200}, []int{200, 200}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestExchange(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"YES\", Exchange([]int{1, 2, 3, 4}, []int{1, 2, 3, 4}))\n    assert.Equal(\"NO\", Exchange([]int{1, 2, 3, 4}, []int{1, 5, 3, 4}))\n}\n", "prompt_text": "", "prompt_explain": "In this problem, you will implement a function that takes two lists of numbers,\nand determines whether it is possible to perform an Exchange of elements\nbetween them to make lst1 a list of only even numbers.\nThere is no limit on the number of Exchanged elements between lst1 and lst2.\nIf it is possible to Exchange elements between the lst1 and lst2 to make\nall the elements of lst1 to be even, return \"YES\".\nOtherwise, return \"NO\".\nFor example:\nExchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\nExchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\nIt is assumed that the input lists will be non-empty.\n", "func_title": "func Exchange(lst1, lst2 []int) string ", "prompt_text_chinese": "在这个问题中，您将实现一个函数，该函数接受两个数字列表，并确定是否可以在它们之间执行元素交换，以使lst1成为仅包含偶数的列表。lst1和lst2之间的交换元素的数量没有限制。如果可以在lst1和lst2之间交换元素，使lst1的所有元素都为偶数，则返回“YES”。否则，返回“NO”。"}
{"task_id": "Go/111", "prompt": "import (\n    \"strings\"\n)\n\n// Given a string representing a space separated lowercase letters, return a dictionary\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// \n// Example:\n// Histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n// Histogram('a b b a') == {'a': 2, 'b': 2}\n// Histogram('a b c a b') == {'a': 2, 'b': 2}\n// Histogram('b b b b a') == {'b': 4}\n// Histogram('') == {}\nfunc Histogram(test string) map[rune]int {\n", "import": "import (\n    \"strings\"\n)\n", "docstring": "// Given a string representing a space separated lowercase letters, return a dictionary\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// \n// Example:\n// Histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n// Histogram('a b b a') == {'a': 2, 'b': 2}\n// Histogram('a b c a b') == {'a': 2, 'b': 2}\n// Histogram('b b b b a') == {'b': 4}\n// Histogram('') == {}\n", "declaration": "\nfunc Histogram(test string) map[rune]int {\n", "canonical_solution": "    dict1 := make(map[rune]int)\n    list1 := strings.Fields(test)\n    t := 0\n    count := func(lst []string, v string) int {\n        cnt := 0\n        for _, i := range lst {\n            if i == v {\n                cnt++\n            }\n        }\n        return cnt\n    }\n    for _, i := range list1 {\n        if c := count(list1, i); c>t && i!=\"\" {\n            t=c\n        }\n    }\n    if t>0 {\n        for _, i := range list1 {\n            if count(list1, i)==t {\n                dict1[[]rune(i)[0]]=t\n            }\n        }\n    }\n    return dict1\n}\n\n", "test": "func TestHistogram(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(map[rune]int{'a':2,'b': 2}, Histogram(\"a b b a\"))\n    assert.Equal(map[rune]int{'a': 2, 'b': 2}, Histogram(\"a b c a b\"))\n    assert.Equal(map[rune]int{'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, Histogram(\"a b c d g\"))\n    assert.Equal(map[rune]int{'r': 1,'t': 1,'g': 1}, Histogram(\"r t g\"))\n    assert.Equal(map[rune]int{'b': 4}, Histogram(\"b b b b a\"))\n    assert.Equal(map[rune]int{}, Histogram(\"\"))\n    assert.Equal(map[rune]int{'a': 1}, Histogram(\"a\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestHistogram(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(map[rune]int{'a':2,'b': 2}, Histogram(\"a b b a\"))\n    assert.Equal(map[rune]int{'a': 2, 'b': 2}, Histogram(\"a b c a b\"))\n    assert.Equal(map[rune]int{'a': 1,'b': 1,'c': 1}, Histogram(\"a b c\"))\n    assert.Equal(map[rune]int{'b': 4}, Histogram(\"b b b b a\"))\n    assert.Equal(map[rune]int{}, Histogram(\"\"))\n}\n", "prompt_text": "", "prompt_explain": "Given a string representing a space separated lowercase letters, return a dictionary\nof the letter with the most repetition and containing the corresponding count.\nIf several letters have the same occurrence, return all of them.\n\nExample:\nHistogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\nHistogram('a b b a') == {'a': 2, 'b': 2}\nHistogram('a b c a b') == {'a': 2, 'b': 2}\nHistogram('b b b b a') == {'b': 4}\nHistogram('') == {}\n", "func_title": "func Histogram(test string) map[rune]int ", "prompt_text_chinese": "给定一个表示空格分隔的小写字母的字符串，返回重复次数最多且包含相应计数的字母字典。如果有几个字母出现相同的情况，则返回所有字母。"}
{"task_id": "Go/112", "prompt": "import (\n    \"strings\"\n)\n\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n// For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n// For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\nfunc ReverseDelete(s,c string) [2]interface{} {\n", "import": "import (\n    \"strings\"\n)\n", "docstring": "// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n// For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n// For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n", "declaration": "\nfunc ReverseDelete(s,c string) [2]interface{} {\n", "canonical_solution": "    rs := make([]rune, 0)\n    for _, r := range s {\n        if !strings.ContainsRune(c, r) {\n            rs = append(rs, r)\n        }\n    }\n    t := true\n    for i := 0;i < len(rs)>>1;i++ {\n        if rs[i] != rs[len(rs)-i-1] {\n            t=false\n            break\n        }\n    }\n    return [2]interface{}{string(rs), t}\n}\n\n", "test": "func TestReverseDelete(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([2]interface{}{\"bcd\", false}, ReverseDelete(\"abcde\",\"ae\"))\n    assert.Equal([2]interface{}{\"acdef\", false}, ReverseDelete(\"abcdef\", \"b\"))\n    assert.Equal([2]interface{}{\"cdedc\", true}, ReverseDelete(\"abcdedcba\",\"ab\"))\n    assert.Equal([2]interface{}{\"dik\", false}, ReverseDelete(\"dwik\",\"w\"))\n    assert.Equal([2]interface{}{\"\", true}, ReverseDelete(\"a\",\"a\"))\n    assert.Equal([2]interface{}{\"abcdedcba\", true}, ReverseDelete(\"abcdedcba\",\"\"))\n    assert.Equal([2]interface{}{\"abcdedcba\", true}, ReverseDelete(\"abcdedcba\",\"v\"))\n    assert.Equal([2]interface{}{\"abba\", true}, ReverseDelete(\"vabba\",\"v\"))\n    assert.Equal([2]interface{}{\"\", true}, ReverseDelete(\"mamma\",\"mia\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestReverseDelete(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([2]interface{}{\"bcd\", false}, ReverseDelete(\"abcde\",\"ae\"))\n    assert.Equal([2]interface{}{\"acdef\", false}, ReverseDelete(\"abcdef\", \"b\"))\n    assert.Equal([2]interface{}{\"cdedc\", true}, ReverseDelete(\"abcdedcba\",\"ab\"))\n}\n", "prompt_text": "", "prompt_explain": "Task\nWe are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\nthen check if the result string is palindrome.\nA string is called palindrome if it reads the same backward as forward.\nYou should return a tuple containing the result string and true/false for the check.\nExample\nFor s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\nFor s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\nFor s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n", "func_title": "func ReverseDelete(s,c string) [2]interface{} ", "prompt_text_chinese": "我们有两个字符串s和c，你必须删除s中所有等于c中的任何字符的字符，然后检查结果字符串是否为回文。一个字符串如果向前和向后读是一样的，就叫做回文。您应该返回一个元组，其中包含检查的结果字符串和true/false。"}
{"task_id": "Go/113", "prompt": "import (\n    \"fmt\"\n)\n\n// Given a list of strings, where each string consists of only digits, return a list.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// \n// >>> OddCount(['1234567'])\n// [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n// >>> OddCount(['3',\"11111111\"])\n// [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n// \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\nfunc OddCount(lst []string) []string {\n", "import": "import (\n    \"fmt\"\n)\n", "docstring": "// Given a list of strings, where each string consists of only digits, return a list.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// \n// >>> OddCount(['1234567'])\n// [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n// >>> OddCount(['3',\"11111111\"])\n// [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n// \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n", "declaration": "\nfunc OddCount(lst []string) []string {\n", "canonical_solution": "    res := make([]string, 0, len(lst))\n    for _, arr := range lst {\n        n := 0\n        for _, d := range arr {\n            if (d - '0') % 2 == 1 {\n                n++\n            }\n        }\n        res = append(res, fmt.Sprintf(\"the number of odd elements %dn the str%dng %d of the %dnput.\", n,n,n,n))\n    }\n    return res\n}\n\n", "test": "func TestOddCount(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]string{\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}, OddCount([]string{\"1234567\"}))\n    assert.Equal([]string{\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"}, OddCount([]string{\"3\", \"11111111\"}))\n    assert.Equal([]string{\n        \"the number of odd elements 2n the str2ng 2 of the 2nput.\",\n        \"the number of odd elements 3n the str3ng 3 of the 3nput.\",\n        \"the number of odd elements 2n the str2ng 2 of the 2nput.\",\n    }, OddCount([]string{\"271\", \"137\", \"314\"}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestOddCount(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]string{\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}, OddCount([]string{\"1234567\"}))\n    assert.Equal([]string{\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"}, OddCount([]string{\"3\", \"11111111\"}))\n}\n", "prompt_text": "Given a list of strings, where each string consists of only digits, return a list. Each element i of the output should be \"the number of odd elements in the string i of the input.\" where all the i's should be replaced by the number of odd digits in the i'th string of the input. ", "prompt_explain": "Given a list of strings, where each string consists of only digits, return a list.\nEach element i of the output should be \"the number of odd elements in the\nstring i of the input.\" where all the i's should be replaced by the number\nof odd digits in the i'th string of the input.\n\n>>> OddCount(['1234567'])\n[\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n>>> OddCount(['3',\"11111111\"])\n[\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n\"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n", "func_title": "func OddCount(lst []string) []string ","prompt_text_chinese": "在这个问题中，您将实现一个函数，该函数接受两个数字列表，并确定是否可以在它们之间执行元素交换，以使lst1成为仅包含偶数的列表。lst1和lst2之间的交换元素的数量没有限制。如果可以在lst1和lst2之间交换元素，使lst1的所有元素都为偶数，则返回“YES”。否则，返回“NO”。"}
{"task_id": "Go/114", "prompt": "import (\n    \"math\"\n)\n\n// Given an array of integers nums, find the minimum sum of any non-empty sub-array\n// of nums.\n// Example\n// Minsubarraysum([2, 3, 4, 1, 2, 4]) == 1\n// Minsubarraysum([-1, -2, -3]) == -6\nfunc Minsubarraysum(nums []int) int {\n", "import": "import (\n    \"math\"\n)\n", "docstring": "// Given an array of integers nums, find the minimum sum of any non-empty sub-array\n// of nums.\n// Example\n// Minsubarraysum([2, 3, 4, 1, 2, 4]) == 1\n// Minsubarraysum([-1, -2, -3]) == -6\n", "declaration": "\nfunc Minsubarraysum(nums []int) int {\n", "canonical_solution": "    max_sum := 0\n    s := 0\n    for _, num := range nums {\n        s += -num\n        if s < 0 {\n            s = 0\n        }\n        if s > max_sum {\n            max_sum = s\n        }\n    }\n    if max_sum == 0 {\n        max_sum = math.MinInt\n        for _, i := range nums {\n            if -i > max_sum {\n                max_sum = -i\n            }\n        }\n    }\n    return -max_sum\n}\n\n", "test": "func TestMinSubArraySum(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(1, Minsubarraysum([]int{2, 3, 4, 1, 2, 4}))\n    assert.Equal(-6, Minsubarraysum([]int{-1, -2, -3}))\n    assert.Equal(-14, Minsubarraysum([]int{-1, -2, -3, 2, -10}))\n    assert.Equal(-9999999999999999, Minsubarraysum([]int{-9999999999999999}))\n    assert.Equal(0, Minsubarraysum([]int{0, 10, 20, 1000000}))\n    assert.Equal(-6, Minsubarraysum([]int{-1, -2, -3, 10, -5}))\n    assert.Equal(-6, Minsubarraysum([]int{100, -1, -2, -3, 10, -5}))\n    assert.Equal(3, Minsubarraysum([]int{10, 11, 13, 8, 3, 4}))\n    assert.Equal(-33, Minsubarraysum([]int{100, -33, 32, -1, 0, -2}))\n    assert.Equal(-10, Minsubarraysum([]int{-10}))\n    assert.Equal(7, Minsubarraysum([]int{7}))\n    assert.Equal(-1, Minsubarraysum([]int{1, -1}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestMinSubArraySum(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(1, Minsubarraysum([]int{2, 3, 4, 1, 2, 4}))\n    assert.Equal(-6, Minsubarraysum([]int{-1, -2, -3}))\n}\n", "prompt_text": "", "prompt_explain": "Given an array of integers nums, find the minimum sum of any non-empty sub-array\nof nums.\nExample\nMinsubarraysum([2, 3, 4, 1, 2, 4]) == 1\nMinsubarraysum([-1, -2, -3]) == -6\n", "func_title": "func Minsubarraysum(nums []int) int ", "prompt_text_chinese": "给定一个整数数组nums，找出nums的任何非空子数组的最小和。"}
{"task_id": "Go/115", "prompt": "import (\n    \"math\"\n)\n\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it,\n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// \n// Example 1:\n// Input:\n// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n// bucket_capacity : 1\n// Output: 6\n// \n// Example 2:\n// Input:\n// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n// bucket_capacity : 2\n// Output: 5\n// \n// Example 3:\n// Input:\n// grid : [[0,0,0], [0,0,0]]\n// bucket_capacity : 5\n// Output: 0\n// \n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunc MaxFill(grid [][]int, capacity int) int {\n", "import": "import (\n    \"math\"\n)\n", "docstring": "// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it,\n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// \n// Example 1:\n// Input:\n// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n// bucket_capacity : 1\n// Output: 6\n// \n// Example 2:\n// Input:\n// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n// bucket_capacity : 2\n// Output: 5\n// \n// Example 3:\n// Input:\n// grid : [[0,0,0], [0,0,0]]\n// bucket_capacity : 5\n// Output: 0\n// \n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n", "declaration": "\nfunc MaxFill(grid [][]int, capacity int) int {\n", "canonical_solution": "    result := 0\n    for _, arr := range grid {\n        sum := 0\n        for _, i := range arr {\n            sum += i\n        }\n        result += int(math.Ceil(float64(sum) / float64(capacity)))\n    }\n    return result\n}\n\n", "test": "func TestMaxFill(t *testing.T) {\n  assert := assert.New(t)\n  assert.Equal(6, MaxFill([][]int{{0,0,1,0}, {0,1,0,0}, {1,1,1,1}}, 1))\n  assert.Equal(5, MaxFill([][]int{{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}}, 2))\n  assert.Equal(0, MaxFill([][]int{{0,0,0}, {0,0,0}}, 5))\n  assert.Equal(4, MaxFill([][]int{{1,1,1,1}, {1,1,1,1}}, 2))\n  assert.Equal(2, MaxFill([][]int{{1,1,1,1}, {1,1,1,1}}, 9))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestMaxFill(t *testing.T) {\n  assert := assert.New(t)\n  assert.Equal(6, MaxFill([][]int{{0,0,1,0}, {0,1,0,0}, {1,1,1,1}}, 1))\n  assert.Equal(5, MaxFill([][]int{{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}}, 2))\n  assert.Equal(0, MaxFill([][]int{{0,0,0}, {0,0,0}}, 5))\n}\n", "prompt_text": "", "prompt_explain": "You are given a rectangular grid of wells. Each row represents a single well,\nand each 1 in a row represents a single unit of water.\nEach well has a corresponding bucket that can be used to extract water from it,\nand all buckets have the same capacity.\nYour task is to use the buckets to empty the wells.\nOutput the number of times you need to lower the buckets.\n\nExample 1:\nInput:\ngrid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\nbucket_capacity : 1\nOutput: 6\n\nExample 2:\nInput:\ngrid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\nbucket_capacity : 2\nOutput: 5\n\nExample 3:\nInput:\ngrid : [[0,0,0], [0,0,0]]\nbucket_capacity : 5\nOutput: 0\n\nConstraints:\n* all wells have the same length\n* 1 <= grid.length <= 10^2\n* 1 <= grid[:,1].length <= 10^2\n* grid[i][j] -> 0 | 1\n* 1 <= capacity <= 10\n", "func_title": "func MaxFill(grid [][]int, capacity int) int ", "prompt_text_chinese": "给你一个矩形网格的井。每一行代表一口井，每一行中的每一个1代表一个单位的水。每口井都有一个对应的桶，可以用来从井里取水，所有的桶都有相同的容量。你的任务是用水桶把井里的水倒空。输出需要降低桶的次数。"}
{"task_id": "Go/116", "prompt": "import (\n    \"fmt\"\n    \"sort\"\n)\n\n// In this Kata, you have to sort an array of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// \n// It must be implemented like this:\n// >>> SortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n// >>> SortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n// >>> SortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfunc SortArray(arr []int) []int {\n", "import": "import (\n    \"fmt\"\n    \"sort\"\n)\n", "docstring": "// In this Kata, you have to sort an array of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// \n// It must be implemented like this:\n// >>> SortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n// >>> SortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n// >>> SortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n", "declaration": "\nfunc SortArray(arr []int) []int {\n", "canonical_solution": "    sort.Slice(arr, func(i, j int) bool {\n        return arr[i] < arr[j]\n    })\n    sort.Slice(arr, func(i, j int) bool {\n        key := func(x int) int {\n            b := fmt.Sprintf(\"%b\", x)\n            cnt := 0\n            for _, r := range b {\n                if r == '1' {\n                    cnt++\n                }\n            }\n            return cnt\n        }\n        return key(arr[i]) < key(arr[j])\n    })\n    return arr\n}\n\n", "test": "func TestSortArray(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{1, 2, 4, 3, 5}, SortArray([]int{1,5,2,3,4}))\n    assert.Equal([]int{-4, -2, -6, -5, -3}, SortArray([]int{-2,-3,-4,-5,-6}))\n    assert.Equal([]int{0, 1, 2, 4, 3}, SortArray([]int{1,0,2,3,4}))\n    assert.Equal([]int{}, SortArray([]int{}))\n    assert.Equal([]int{2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77}, SortArray([]int{2,5,77,4,5,3,5,7,2,3,4}))\n    assert.Equal([]int{32, 3, 5, 6, 12, 44}, SortArray([]int{3,6,44,12,32,5}))\n    assert.Equal([]int{2, 4, 8, 16, 32}, SortArray([]int{2,4,8,16,32}))\n    assert.Equal([]int{2, 4, 8, 16, 32}, SortArray([]int{2,4,8,16,32}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSortArray(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{1, 2, 4, 3, 5}, SortArray([]int{1,5,2,3,4}))\n    assert.Equal([]int{-4, -2, -6, -5, -3}, SortArray([]int{-2,-3,-4,-5,-6}))\n    assert.Equal([]int{0, 1, 2, 4, 3}, SortArray([]int{1,0,2,3,4}))\n}\n", "prompt_text": "In this Kata, you have to sort an array of non-negative integers according to number of ones in their binary representation in ascending order. For similar number of ones, sort based on decimal value.  It must be implemented like this:", "prompt_explain": "In this Kata, you have to sort an array of non-negative integers according to\nnumber of ones in their binary representation in ascending order.\nFor similar number of ones, sort based on decimal value.\n\nIt must be implemented like this:\n>>> SortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n>>> SortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n>>> SortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n", "func_title": "func SortArray(arr []int) []int ", "prompt_text_chinese": "在这个型中，您必须根据二进制表示中的1的数量对非负整数数组进行升序排序。对于相同数量的1，根据十进制值排序"}
{"task_id": "Go/117", "prompt": "import (\n    \"bytes\"\n    \"strings\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement\n// a function that returns a list of all words from string s that contain exactly\n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// SelectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// SelectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// SelectWords(\"simple white space\", 2) ==> []\n// SelectWords(\"Hello world\", 4) ==> [\"world\"]\n// SelectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc SelectWords(s string, n int) []string {\n", "import": "import (\n    \"bytes\"\n    \"strings\"\n)\n", "docstring": "// Given a string s and a natural number n, you have been tasked to implement\n// a function that returns a list of all words from string s that contain exactly\n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// SelectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// SelectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// SelectWords(\"simple white space\", 2) ==> []\n// SelectWords(\"Hello world\", 4) ==> [\"world\"]\n// SelectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n", "declaration": "\nfunc SelectWords(s string, n int) []string {\n", "canonical_solution": "    result := make([]string, 0)\n    for _, word := range strings.Fields(s) {\n        n_consonants := 0\n        lower := strings.ToLower(word)\n        for i := 0;i < len(word); i++ {\n            if !bytes.Contains([]byte(\"aeiou\"), []byte{lower[i]}) {\n                n_consonants++\n            }\n        }\n        if n_consonants == n{\n            result = append(result, word)\n        }\n    }\n    return result\n}\n\n", "test": "func TestSelectWords(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]string{\"little\"}, SelectWords(\"Mary had a little lamb\", 4))\n    assert.Equal([]string{\"Mary\", \"lamb\"}, SelectWords(\"Mary had a little lamb\", 3))\n    assert.Equal([]string{}, SelectWords(\"simple white space\", 2))\n    assert.Equal([]string{\"world\"}, SelectWords(\"Hello world\", 4))\n    assert.Equal([]string{\"Uncle\"}, SelectWords(\"Uncle sam\", 3))\n    assert.Equal([]string{}, SelectWords(\"\", 4))\n    assert.Equal([]string{\"b\", \"c\", \"d\", \"f\"}, SelectWords(\"a b c d e f\", 1))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSelectWords(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]string{\"little\"}, SelectWords(\"Mary had a little lamb\", 4))\n    assert.Equal([]string{\"Mary\", \"lamb\"}, SelectWords(\"Mary had a little lamb\", 3))\n    assert.Equal([]string{}, SelectWords(\"simple white space\", 2))\n    assert.Equal([]string{\"world\"}, SelectWords(\"Hello world\", 4))\n    assert.Equal([]string{\"Uncle\"}, SelectWords(\"Uncle sam\", 3))\n}\n", "prompt_text": "", "prompt_explain": "Given a string s and a natural number n, you have been tasked to implement\na function that returns a list of all words from string s that contain exactly\nn consonants, in order these words appear in the string s.\nIf the string s is empty then the function should return an empty list.\nNote: you may assume the input string contains only letters and spaces.\nExamples:\nSelectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\nSelectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\nSelectWords(\"simple white space\", 2) ==> []\nSelectWords(\"Hello world\", 4) ==> [\"world\"]\nSelectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n", "func_title": "func SelectWords(s string, n int) []string ", "prompt_text_chinese": "给定一个字符串s和一个自然数n，你的任务是实现一个函数，返回字符串s中包含n个辅音的所有单词的列表，按照这些单词出现在字符串s中的顺序。如果字符串s是空的，那么函数应该返回一个空列表。注意:您可以假设输入字符串只包含字母和空格"}
{"task_id": "Go/118", "prompt": "import (\n    \"bytes\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between\n// two consonants from the right side of the word (case sensitive).\n// \n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition.\n// \n// You may assume that the given string contains English letter only.\n// \n// Example:\n// GetClosestVowel(\"yogurt\") ==> \"u\"\n// GetClosestVowel(\"FULL\") ==> \"U\"\n// GetClosestVowel(\"quick\") ==> \"\"\n// GetClosestVowel(\"ab\") ==> \"\"\nfunc GetClosestVowel(word string) string {\n", "import": "import (\n    \"bytes\"\n)\n", "docstring": "// You are given a word. Your task is to find the closest vowel that stands between\n// two consonants from the right side of the word (case sensitive).\n// \n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition.\n// \n// You may assume that the given string contains English letter only.\n// \n// Example:\n// GetClosestVowel(\"yogurt\") ==> \"u\"\n// GetClosestVowel(\"FULL\") ==> \"U\"\n// GetClosestVowel(\"quick\") ==> \"\"\n// GetClosestVowel(\"ab\") ==> \"\"\n", "declaration": "\nfunc GetClosestVowel(word string) string {\n", "canonical_solution": "    if len(word) < 3 {\n        return \"\"\n    }\n\n    vowels := []byte(\"aeiouAEOUI\")\n    for i := len(word)-2; i > 0; i-- {\n        if bytes.Contains(vowels, []byte{word[i]}) {\n            if !bytes.Contains(vowels, []byte{word[i+1]}) && !bytes.Contains(vowels, []byte{word[i-1]}) {\n                return string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n\n", "test": "func TestGetClosestVowel(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"u\", GetClosestVowel(\"yogurt\"))\n    assert.Equal(\"u\", GetClosestVowel(\"full\"))\n    assert.Equal(\"\", GetClosestVowel(\"easy\"))\n    assert.Equal(\"\", GetClosestVowel(\"eAsy\"))\n    assert.Equal(\"\", GetClosestVowel(\"ali\"))\n    assert.Equal(\"a\", GetClosestVowel(\"bad\"))\n    assert.Equal(\"o\", GetClosestVowel(\"most\"))\n    assert.Equal(\"\", GetClosestVowel(\"ab\"))\n    assert.Equal(\"\", GetClosestVowel(\"ba\"))\n    assert.Equal(\"\", GetClosestVowel(\"quick\"))\n    assert.Equal(\"i\", GetClosestVowel(\"anime\"))\n    assert.Equal(\"\", GetClosestVowel(\"Asia\"))\n    assert.Equal(\"o\", GetClosestVowel(\"Above\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestGetClosestVowel(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"u\", GetClosestVowel(\"yogurt\"))\n    assert.Equal(\"U\", GetClosestVowel(\"FULL\"))\n    assert.Equal(\"\", GetClosestVowel(\"ab\"))\n    assert.Equal(\"\", GetClosestVowel(\"quick\"))\n}\n", "prompt_text": "", "prompt_explain": "You are given a word. Your task is to find the closest vowel that stands between\ntwo consonants from the right side of the word (case sensitive).\n\nVowels in the beginning and ending doesn't count. Return empty string if you didn't\nfind any vowel met the above condition.\n\nYou may assume that the given string contains English letter only.\n\nExample:\nGetClosestVowel(\"yogurt\") ==> \"u\"\nGetClosestVowel(\"FULL\") ==> \"U\"\nGetClosestVowel(\"quick\") ==> \"\"\nGetClosestVowel(\"ab\") ==> \"\"\n", "func_title": "func GetClosestVowel(word string) string ", "prompt_text_chinese": "给你一个词。你的任务是找到距离单词右边两个辅音之间最近的元音(区分大小写)。开头和结尾的元音不算数。如果没有找到符合上述条件的元音，则返回空字符串。您可以假设给定的字符串只包含英文字母。"}
{"task_id": "Go/119", "prompt": "\n// You are given a list of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// \n// Examples:\n// MatchParens(['()(', ')']) == 'Yes'\n// MatchParens([')', ')']) == 'No'\nfunc MatchParens(lst []string) string {\n", "import": "", "docstring": "// You are given a list of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// \n// Examples:\n// MatchParens(['()(', ')']) == 'Yes'\n// MatchParens([')', ')']) == 'No'\n", "declaration": "\nfunc MatchParens(lst []string) string {\n", "canonical_solution": "    check := func(s string) bool {\n        val := 0\n        for _, i := range s {\n            if i == '(' {\n                val++\n            } else {\n                val--\n            }\n            if val < 0 {\n                return false\n            }\n        }\n        return val == 0\n    }\n\n    S1 := lst[0] + lst[1]\n    S2 := lst[1] + lst[0]\n    if check(S1) || check(S2) {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n", "test": "func TestMatchParens(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"Yes\", MatchParens([]string{\"()(\", \")\"}))\n    assert.Equal(\"No\", MatchParens([]string{\")\", \")\"}))\n    assert.Equal(\"No\", MatchParens([]string{\"(()(())\", \"())())\"}))\n    assert.Equal(\"Yes\", MatchParens([]string{\")())\", \"(()()(\"}))\n    assert.Equal(\"Yes\", MatchParens([]string{\"(())))\", \"(()())((\"}))\n    assert.Equal(\"No\", MatchParens([]string{\"()\", \"())\"}))\n    assert.Equal(\"Yes\", MatchParens([]string{\"(()(\", \"()))()\"}))\n    assert.Equal(\"No\", MatchParens([]string{\"((((\", \"((())\"}))\n    assert.Equal(\"No\", MatchParens([]string{\")(()\", \"(()(\"}))\n    assert.Equal(\"No\", MatchParens([]string{\")(\", \")(\"}))\n    assert.Equal(\"Yes\", MatchParens([]string{\"(\", \")\"}))\n    assert.Equal(\"Yes\", MatchParens([]string{\")\", \"(\"}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestMatchParens(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"Yes\", MatchParens([]string{\"()(\", \")\"}))\n    assert.Equal(\"No\", MatchParens([]string{\")\", \")\"}))\n}\n", "prompt_text": "", "prompt_explain": "You are given a list of two strings, both strings consist of open\nparentheses '(' or close parentheses ')' only.\nYour job is to check if it is possible to concatenate the two strings in\nsome order, that the resulting string will be good.\nA string S is considered to be good if and only if all parentheses in S\nare balanced. For example: the string '(())()' is good, while the string\n'())' is not.\nReturn 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\nExamples:\nMatchParens(['()(', ')']) == 'Yes'\nMatchParens([')', ')']) == 'No'\n", "func_title": "func MatchParens(lst []string) string ", "prompt_text_chinese": "给你一个包含两个字符串的列表，两个字符串都只由开括号'('或闭括号')'组成。您的工作是检查是否有可能以某种顺序连接这两个字符串，以确保得到的字符串是正确的。字符串S被认为是好的，当且仅当S中的所有括号都是平衡的"}
{"task_id": "Go/120", "prompt": "import (\n    \"sort\"\n)\n\n// Given an array arr of integers and a positive integer k, return a sorted list\n// of length k with the Maximum k numbers in arr.\n// \n// Example 1:\n// \n// Input: arr = [-3, -4, 5], k = 3\n// Output: [-4, -3, 5]\n// \n// Example 2:\n// \n// Input: arr = [4, -4, 4], k = 2\n// Output: [4, 4]\n// \n// Example 3:\n// \n// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n// Output: [2]\n// \n// Note:\n// 1. The length of the array will be in the range of [1, 1000].\n// 2. The elements in the array will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nfunc Maximum(arr []int, k int) []int {\n", "import": "import (\n    \"sort\"\n)\n", "docstring": "// Given an array arr of integers and a positive integer k, return a sorted list\n// of length k with the Maximum k numbers in arr.\n// \n// Example 1:\n// \n// Input: arr = [-3, -4, 5], k = 3\n// Output: [-4, -3, 5]\n// \n// Example 2:\n// \n// Input: arr = [4, -4, 4], k = 2\n// Output: [4, 4]\n// \n// Example 3:\n// \n// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n// Output: [2]\n// \n// Note:\n// 1. The length of the array will be in the range of [1, 1000].\n// 2. The elements in the array will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\n", "declaration": "\nfunc Maximum(arr []int, k int) []int {\n", "canonical_solution": "    if k == 0 {\n        return []int{}\n    }\n    sort.Slice(arr, func(i, j int) bool {\n        return arr[i] < arr[j]\n    })\n    return arr[len(arr)-k:]\n}\n\n", "test": "func TestMaximum(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{-4, -3, 5}, Maximum([]int{-3, -4, 5}, 3))\n    assert.Equal([]int{4, 4}, Maximum([]int{4, -4, 4}, 2))\n    assert.Equal([]int{2}, Maximum([]int{-3, 2, 1, 2, -1, -2, 1}, 1))\n    assert.Equal([]int{2, 20, 123}, Maximum([]int{123, -123, 20, 0 , 1, 2, -3}, 3))\n    assert.Equal([]int{0, 1, 2, 20}, Maximum([]int{-123, 20, 0 , 1, 2, -3}, 4))\n    assert.Equal([]int{-13, -8, 0, 0, 3, 5, 15}, Maximum([]int{5, 15, 0, 3, -13, -8, 0}, 7))\n    assert.Equal([]int{3, 5}, Maximum([]int{-1, 0, 2, 5, 3, -10}, 2))\n    assert.Equal([]int{5}, Maximum([]int{1, 0, 5, -7}, 1))\n    assert.Equal([]int{-4, 4}, Maximum([]int{4, -4}, 2))\n    assert.Equal([]int{-10, 10}, Maximum([]int{-10, 10}, 2))\n    assert.Equal([]int{}, Maximum([]int{1, 2, 3, -23, 243, -400, 0}, 0))\n  }\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestMaximum(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{-4, -3, 5}, Maximum([]int{-3, -4, 5}, 3))\n    assert.Equal([]int{4, 4}, Maximum([]int{4, -4, 4}, 2))\n    assert.Equal([]int{2}, Maximum([]int{-3, 2, 1, 2, -1, -2, 1}, 1))\n  }\n", "prompt_text": "", "prompt_explain": "Given an array arr of integers and a positive integer k, return a sorted list\nof length k with the Maximum k numbers in arr.\n\nExample 1:\n\nInput: arr = [-3, -4, 5], k = 3\nOutput: [-4, -3, 5]\n\nExample 2:\n\nInput: arr = [4, -4, 4], k = 2\nOutput: [4, 4]\n\nExample 3:\n\nInput: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\nOutput: [2]\n\nNote:\n1. The length of the array will be in the range of [1, 1000].\n2. The elements in the array will be in the range of [-1000, 1000].\n3. 0 <= k <= len(arr)\n", "func_title": "func Maximum(arr []int, k int) []int ", "prompt_text_chinese": "给定一个整数数组arr和一个正整数k，返回一个长度为k且arr中最大k个数字的排序列表。"}
{"task_id": "Go/121", "prompt": "\n// Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n// \n// Examples\n// Solution([5, 8, 7, 1]) ==> 12\n// Solution([3, 3, 3, 3, 3]) ==> 9\n// Solution([30, 13, 24, 321]) ==>0\nfunc Solution(lst []int) int {\n", "import": "", "docstring": "// Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n// \n// Examples\n// Solution([5, 8, 7, 1]) ==> 12\n// Solution([3, 3, 3, 3, 3]) ==> 9\n// Solution([30, 13, 24, 321]) ==>0\n", "declaration": "\nfunc Solution(lst []int) int {\n", "canonical_solution": "    sum:=0\n    for i, x := range lst {\n        if i&1==0&&x&1==1 {\n            sum+=x\n        }\n    }\n    return sum\n}\n\n", "test": "func TestSolution(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(12, Solution([]int{5, 8, 7, 1}))\n    assert.Equal(9, Solution([]int{3, 3, 3, 3, 3}))\n    assert.Equal(0, Solution([]int{30, 13, 24, 321}))\n    assert.Equal(5, Solution([]int{5, 9}))\n    assert.Equal(0, Solution([]int{2, 4, 8}))\n    assert.Equal(23, Solution([]int{30, 13, 23, 32}))\n    assert.Equal(3, Solution([]int{3, 13, 2, 9}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSolution(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(12, Solution([]int{5, 8, 7, 1}))\n    assert.Equal(9, Solution([]int{3, 3, 3, 3, 3}))\n    assert.Equal(0, Solution([]int{30, 13, 24, 321}))\n}\n", "prompt_text": "", "prompt_explain": "Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\nExamples\nSolution([5, 8, 7, 1]) ==> 12\nSolution([3, 3, 3, 3, 3]) ==> 9\nSolution([30, 13, 24, 321]) ==>0\n", "func_title": "func Solution(lst []int) int ", "prompt_text_chinese": "给定一个非空的整数列表，返回位于偶数位置的所有奇数元素的和。"}
{"task_id": "Go/122", "prompt": "import (\n    \"strconv\"\n)\n\n// Given a non-empty array of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// \n// Example:\n// \n// Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n// Output: 24 # sum of 21 + 3\n// \n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nfunc AddElements(arr []int, k int) int {\n", "import": "import (\n    \"strconv\"\n)\n", "docstring": "// Given a non-empty array of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// \n// Example:\n// \n// Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n// Output: 24 # sum of 21 + 3\n// \n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\n", "declaration": "\nfunc AddElements(arr []int, k int) int {\n", "canonical_solution": "    sum := 0\n    for _, elem := range arr[:k] {\n        if len(strconv.Itoa(elem)) <= 2 {\n            sum += elem\n        }\n    }\n    return sum\n}\n\n", "test": "func TestAddElements(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(-4, AddElements([]int{1,-2,-3,41,57,76,87,88,99}, 3))\n    assert.Equal(0, AddElements([]int{111,121,3,4000,5,6}, 2))\n    assert.Equal(125, AddElements([]int{11,21,3,90,5,6,7,8,9}, 4))\n    assert.Equal(24, AddElements([]int{111,21,3,4000,5,6,7,8,9}, 4))\n    assert.Equal(1, AddElements([]int{1}, 1))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestAddElements(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(24, AddElements([]int{111,21,3,4000,5,6,7,8,9}, 4))\n}\n", "prompt_text": "", "prompt_explain": "Given a non-empty array of integers arr and an integer k, return\nthe sum of the elements with at most two digits from the first k elements of arr.\n\nExample:\n\nInput: arr = [111,21,3,4000,5,6,7,8,9], k = 4\nOutput: 24 # sum of 21 + 3\n\nConstraints:\n1. 1 <= len(arr) <= 100\n2. 1 <= k <= len(arr)\n", "func_title": "func AddElements(arr []int, k int) int ", "prompt_text_chinese": "给定一个由整数arr和整数k组成的非空数组，返回arr中前k个元素中最多两位数的元素之和。"}
{"task_id": "Go/123", "prompt": "import (\n    \"sort\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// \n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the\n// previous term as follows: if the previous term is even, the next term is one half of\n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// \n// Note:\n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// \n// For example:\n// GetOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\nfunc GetOddCollatz(n int) []int {\n", "import": "import (\n    \"sort\"\n)\n", "docstring": "// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// \n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the\n// previous term as follows: if the previous term is even, the next term is one half of\n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// \n// Note:\n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// \n// For example:\n// GetOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n", "declaration": "\nfunc GetOddCollatz(n int) []int {\n", "canonical_solution": "    odd_collatz := make([]int, 0)\n    if n&1==1 {\n        odd_collatz = append(odd_collatz, n)\n    }\n    for n > 1 {\n        if n &1==0 {\n            n>>=1\n        } else {\n            n = n*3 + 1\n        }            \n        if n&1 == 1 {\n            odd_collatz = append(odd_collatz, n)\n        }\n    }\n    sort.Slice(odd_collatz, func(i, j int) bool {\n        return odd_collatz[i] < odd_collatz[j]\n    })\n    return odd_collatz\n}\n\n", "test": "func TestGetOddCollatz(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{1, 5, 7, 11, 13, 17}, GetOddCollatz(14))\n    assert.Equal([]int{1, 5}, GetOddCollatz(5))\n    assert.Equal([]int{1, 3, 5}, GetOddCollatz(12))\n    assert.Equal([]int{1}, GetOddCollatz(1))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestGetOddCollatz(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{1, 5}, GetOddCollatz(5))\n}\n", "prompt_text": "", "prompt_explain": "Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\nThe Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\nas follows: start with any positive integer n. Then each term is obtained from the\nprevious term as follows: if the previous term is even, the next term is one half of\nthe previous term. If the previous term is odd, the next term is 3 times the previous\nterm plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\nNote:\n1. Collatz(1) is [1].\n2. returned list sorted in increasing order.\n\nFor example:\nGetOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n", "func_title": "func GetOddCollatz(n int) []int ", "prompt_text_chinese": "给定一个正整数n，返回一个以collatz顺序排列的奇数的有序列表。Collatz猜想是数学中的一个猜想，它涉及一个序列，定义如下:从任意正整数n开始，然后每一项都从上一项得到，如下所示:如果前一项是偶数，下一项是前一项的一半。如果前一项是奇数，那么下一项就是3乘以前一项加1。猜想是不管n的值是多少，序列总是会达到1。注意:1。Collatz(1)是[1]。2. 返回的列表按递增顺序排序。"}
{"task_id": "Go/124", "prompt": "import (\n    \"strconv\"\n    \"strings\"\n)\n\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// \n// for example:\n// ValidDate('03-11-2000') => true\n// \n// ValidDate('15-01-2012') => false\n// \n// ValidDate('04-0-2040') => false\n// \n// ValidDate('06-04-2020') => true\n// \n// ValidDate('06/04/2020') => false\nfunc ValidDate(date string) bool {\n", "import": "import (\n    \"strconv\"\n    \"strings\"\n)\n", "docstring": "// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// \n// for example:\n// ValidDate('03-11-2000') => true\n// \n// ValidDate('15-01-2012') => false\n// \n// ValidDate('04-0-2040') => false\n// \n// ValidDate('06-04-2020') => true\n// \n// ValidDate('06/04/2020') => false\n", "declaration": "\nfunc ValidDate(date string) bool {\n", "canonical_solution": "    isInArray := func(arr []int, i int) bool {\n        for _, x := range arr {\n            if i == x {\n                return true\n            }\n        }\n        return false\n    }\n\n    date = strings.TrimSpace(date)\n    split := strings.SplitN(date, \"-\", 3)\n    if len(split) != 3 {\n        return false\n    }\n    month, err := strconv.Atoi(split[0])\n    if err != nil {\n        return false\n    }\n    day, err := strconv.Atoi(split[1])\n    if err != nil {\n        return false\n    }\n    _, err = strconv.Atoi(split[2])\n    if err != nil {\n        return false\n    }\n    if month < 1 || month > 12 {\n        return false\n    }\n    \n    if isInArray([]int{1,3,5,7,8,10,12}, month) && day < 1 || day > 31 {\n        return false\n    }\n    if isInArray([]int{4,6,9,11}, month) && day < 1 || day > 30 {\n        return false\n    }\n    if month == 2 && day < 1 || day > 29 {\n        return false\n    }\n\n    return true\n}\n\n", "test": "func TestValidDate(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, ValidDate(\"03-11-2000\"))\n    assert.Equal(false, ValidDate(\"15-01-2012\"))\n    assert.Equal(false, ValidDate(\"04-0-2040\"))\n    assert.Equal(true, ValidDate(\"06-04-2020\"))\n    assert.Equal(true, ValidDate(\"01-01-2007\"))\n    assert.Equal(false, ValidDate(\"03-32-2011\"))\n    assert.Equal(false, ValidDate(\"\"))\n    assert.Equal(false, ValidDate(\"04-31-3000\"))\n    assert.Equal(true, ValidDate(\"06-06-2005\"))\n    assert.Equal(false, ValidDate(\"21-31-2000\"))\n    assert.Equal(true, ValidDate(\"04-12-2003\"))\n    assert.Equal(false, ValidDate(\"04122003\"))\n    assert.Equal(false, ValidDate(\"20030412\"))\n    assert.Equal(false, ValidDate(\"2003-04\"))\n    assert.Equal(false, ValidDate(\"2003-04-12\"))\n    assert.Equal(false, ValidDate(\"04-2003\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestValidDate(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, ValidDate(\"03-11-2000\"))\n    assert.Equal(false, ValidDate(\"15-01-2012\"))\n    assert.Equal(false, ValidDate(\"04-0-2040\"))\n    assert.Equal(true, ValidDate(\"06-04-2020\"))\n    assert.Equal(false, ValidDate(\"06/04/2020\"))\n}\n", "prompt_text": "", "prompt_explain": "You have to write a function which validates a given date string and\nreturns true if the date is valid otherwise false.\nThe date is valid if all of the following rules are satisfied:\n1. The date string is not empty.\n2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n3. The months should not be less than 1 or higher than 12.\n4. The date should be in the format: mm-dd-yyyy\n\nfor example:\nValidDate('03-11-2000') => true\n\nValidDate('15-01-2012') => false\n\nValidDate('04-0-2040') => false\n\nValidDate('06-04-2020') => true\n\nValidDate('06/04/2020') => false\n", "func_title": "func ValidDate(date string) bool ", "prompt_text_chinese": "您必须编写一个函数来验证给定的日期字符串，如果日期有效则返回true，否则返回false。当满足以下所有条件时，该日期有效。日期字符串不是空的。2. 第1、3、5、7、8、10、12月的天数不少于1天或大于31天。第4、6、9、11个月的天数不少于1天或大于30天。并且，第2个月的天数不小于1或大于29。3.月份不应小于1或大于12。4. 日期的格式为:mm-dd-yyyy"}
{"task_id": "Go/125", "prompt": "import (\n    \"strings\"\n)\n\n// Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// SplitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n// SplitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n// SplitWords(\"abcdef\") == 3\nfunc SplitWords(txt string) interface{} {\n", "import": "import (\n    \"strings\"\n)\n", "docstring": "// Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// SplitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n// SplitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n// SplitWords(\"abcdef\") == 3\n", "declaration": "\nfunc SplitWords(txt string) interface{} {\n", "canonical_solution": "    if strings.Contains(txt, \" \") {\n        return strings.Fields(txt)\n    } else if strings.Contains(txt, \",\") {\n        return strings.Split(txt, \",\")\n    }\n    cnt := 0\n    for _, r := range txt {\n        if 'a' <= r && r <= 'z' && (r-'a')&1==1 {\n            cnt++\n        }\n    }\n    return cnt\n}\n\n", "test": "func TestSplitWords(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]string{\"Hello\", \"world!\"}, SplitWords(\"Hello world!\"))\n    assert.Equal([]string{\"Hello\", \"world!\"}, SplitWords(\"Hello,world!\"))\n    assert.Equal([]string{\"Hello\", \"world,!\"}, SplitWords(\"Hello world,!\"))\n    assert.Equal([]string{\"Hello,Hello,world\", \"!\"}, SplitWords(\"Hello,Hello,world !\"))\n    assert.Equal(3, SplitWords(\"abcdef\"))\n    assert.Equal(2, SplitWords(\"aaabb\"))\n    assert.Equal(1, SplitWords(\"aaaBb\"))\n    assert.Equal(0, SplitWords(\"\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSplitWords(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]string{\"Hello\", \"world!\"}, SplitWords(\"Hello world!\"))\n    assert.Equal([]string{\"Hello\", \"world!\"}, SplitWords(\"Hello,world!\"))\n    assert.Equal(3, SplitWords(\"abcdef\"))\n}\n", "prompt_text": "", "prompt_explain": "Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\nshould split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\nalphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\nExamples\nSplitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\nSplitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\nSplitWords(\"abcdef\") == 3\n", "func_title": "func SplitWords(txt string) interface{} ", "prompt_text_chinese": "给定一串单词，返回一个以空格分隔的单词列表，如果文本中不存在空格，则应以逗号分隔，如果不存在逗号，则应返回字母表中奇数顺序的小写字母的数量"}
{"task_id": "Go/126", "prompt": "\n// Given a list of numbers, return whether or not they are sorted\n// in ascending order. If list has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// \n// Examples\n// IsSorted([5]) ➞ true\n// IsSorted([1, 2, 3, 4, 5]) ➞ true\n// IsSorted([1, 3, 2, 4, 5]) ➞ false\n// IsSorted([1, 2, 3, 4, 5, 6]) ➞ true\n// IsSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n// IsSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n// IsSorted([1, 2, 2, 3, 3, 4]) ➞ true\n// IsSorted([1, 2, 2, 2, 3, 4]) ➞ false\nfunc IsSorted(lst []int) bool {\n", "import": "", "docstring": "// Given a list of numbers, return whether or not they are sorted\n// in ascending order. If list has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// \n// Examples\n// IsSorted([5]) ➞ true\n// IsSorted([1, 2, 3, 4, 5]) ➞ true\n// IsSorted([1, 3, 2, 4, 5]) ➞ false\n// IsSorted([1, 2, 3, 4, 5, 6]) ➞ true\n// IsSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n// IsSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n// IsSorted([1, 2, 2, 3, 3, 4]) ➞ true\n// IsSorted([1, 2, 2, 2, 3, 4]) ➞ false\n", "declaration": "\nfunc IsSorted(lst []int) bool {\n", "canonical_solution": "    count_digit := make(map[int]int)\n    for _, i := range lst {\n        count_digit[i] = 0\n    }\n    for _, i := range lst {\n        count_digit[i]++\n    }\n    for _, i := range lst {\n        if count_digit[i] > 2 {\n            return false\n        }\n    }\n    for i := 1;i < len(lst);i++ {\n        if lst[i-1] > lst[i] {\n            return false\n        }\n    }\n    return true\n}\n    \n\n", "test": "func TestIsSorted(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, IsSorted([]int{5}))\n    assert.Equal(true, IsSorted([]int{1, 2, 3, 4, 5}))\n    assert.Equal(false, IsSorted([]int{1, 3, 2, 4, 5}))\n    assert.Equal(true, IsSorted([]int{1, 2, 3, 4, 5, 6}))\n    assert.Equal(true, IsSorted([]int{1, 2, 3, 4, 5, 6, 7}))\n    assert.Equal(false, IsSorted([]int{1, 3, 2, 4, 5, 6, 7}))\n    assert.Equal(true, IsSorted([]int{}))\n    assert.Equal(true, IsSorted([]int{1}))\n    assert.Equal(false, IsSorted([]int{3, 2, 1}))\n    assert.Equal(false, IsSorted([]int{1, 2, 2, 2, 3, 4}))\n    assert.Equal(false, IsSorted([]int{1, 2, 3, 3, 3, 4}))\n    assert.Equal(true, IsSorted([]int{1, 2, 2, 3, 3, 4}))\n    assert.Equal(true, IsSorted([]int{1, 2, 3, 4}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestIsSorted(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, IsSorted([]int{5}))\n    assert.Equal(true, IsSorted([]int{1, 2, 3, 4, 5}))\n    assert.Equal(false, IsSorted([]int{1, 3, 2, 4, 5}))\n    assert.Equal(true, IsSorted([]int{1, 2, 3, 4, 5, 6}))\n    assert.Equal(true, IsSorted([]int{1, 2, 3, 4, 5, 6, 7}))\n    assert.Equal(false, IsSorted([]int{1, 3, 2, 4, 5, 6, 7}))\n    assert.Equal(false, IsSorted([]int{1, 2, 2, 2, 3, 4}))\n    assert.Equal(true, IsSorted([]int{1, 2, 2, 3, 3, 4}))\n}\n", "prompt_text": "", "prompt_explain": "Given a list of numbers, return whether or not they are sorted\nin ascending order. If list has more than 1 duplicate of the same\nnumber, return false. Assume no negative numbers and only integers.\n\nExamples\nIsSorted([5]) ➞ true\nIsSorted([1, 2, 3, 4, 5]) ➞ true\nIsSorted([1, 3, 2, 4, 5]) ➞ false\nIsSorted([1, 2, 3, 4, 5, 6]) ➞ true\nIsSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\nIsSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\nIsSorted([1, 2, 2, 3, 3, 4]) ➞ true\nIsSorted([1, 2, 2, 2, 3, 4]) ➞ false\n", "func_title": "func IsSorted(lst []int) bool ", "prompt_text_chinese": "给定一个数字列表，返回它们是否按升序排序。如果列表中有多个相同数字的副本，则返回false。假设没有负数，只有整数"}
{"task_id": "Go/127", "prompt": "\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of Intersection of these two\n// intervals is a prime number.\n// Example, the Intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the Intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// \n// \n// [input/output] samples:\n// Intersection((1, 2), (2, 3)) ==> \"NO\"\n// Intersection((-1, 1), (0, 4)) ==> \"NO\"\n// Intersection((-3, -1), (-5, 5)) ==> \"YES\"\nfunc Intersection(interval1 [2]int, interval2 [2]int) string {\n", "import": "", "docstring": "// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of Intersection of these two\n// intervals is a prime number.\n// Example, the Intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the Intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// \n// \n// [input/output] samples:\n// Intersection((1, 2), (2, 3)) ==> \"NO\"\n// Intersection((-1, 1), (0, 4)) ==> \"NO\"\n// Intersection((-3, -1), (-5, 5)) ==> \"YES\"\n", "declaration": "\nfunc Intersection(interval1 [2]int, interval2 [2]int) string {\n", "canonical_solution": "    is_prime := func(num int) bool {\n        if num == 1 || num == 0 {\n            return false\n        }\n        if num == 2 {\n            return true\n        }\n        for i := 2;i < num;i++ {\n            if num%i == 0 {\n                return false\n            }\n        }\n        return true\n    }\n    l := interval1[0]\n    if interval2[0] > l {\n        l = interval2[0]\n    }\n    r := interval1[1]\n    if interval2[1] < r {\n        r = interval2[1]\n    }\n    length := r - l\n    if length > 0 && is_prime(length) {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\n", "test": "func TestIntersection(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"NO\", Intersection([2]int{1, 2}, [2]int{2, 3}))\n    assert.Equal(\"NO\", Intersection([2]int{-1, 1}, [2]int{0, 4}))\n    assert.Equal(\"YES\", Intersection([2]int{-3, -1}, [2]int{-5, 5}))\n    assert.Equal(\"YES\", Intersection([2]int{-2, 2}, [2]int{-4, 0}))\n    assert.Equal(\"NO\", Intersection([2]int{-11, 2}, [2]int{-1, -1}))\n    assert.Equal(\"NO\", Intersection([2]int{1, 2}, [2]int{3, 5}))\n    assert.Equal(\"NO\", Intersection([2]int{1, 2}, [2]int{1, 2}))\n    assert.Equal(\"NO\", Intersection([2]int{-2, -2}, [2]int{-3, -2}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestIntersection(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"NO\", Intersection([2]int{1, 2}, [2]int{2, 3}))\n    assert.Equal(\"NO\", Intersection([2]int{-1, 1}, [2]int{0, 4}))\n    assert.Equal(\"YES\", Intersection([2]int{-3, -1}, [2]int{-5, 5}))\n}\n", "prompt_text": "", "prompt_explain": "You are given two intervals,\nwhere each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\nThe given intervals are closed which means that the interval (start, end)\nincludes both start and end.\nFor each given interval, it is assumed that its start is less or equal its end.\nYour task is to determine whether the length of Intersection of these two\nintervals is a prime number.\nExample, the Intersection of the intervals (1, 3), (2, 4) is (2, 3)\nwhich its length is 1, which not a prime number.\nIf the length of the Intersection is a prime number, return \"YES\",\notherwise, return \"NO\".\nIf the two intervals don't intersect, return \"NO\".\n\n\n[input/output] samples:\nIntersection((1, 2), (2, 3)) ==> \"NO\"\nIntersection((-1, 1), (0, 4)) ==> \"NO\"\nIntersection((-3, -1), (-5, 5)) ==> \"YES\"\n", "func_title": "func Intersection(interval1 [2]int, interval2 [2]int) string ", "prompt_text_chinese": "给定两个区间，每个区间是一对整数。例如，interval = (start, end) =(1,2)。给定的间隔是封闭的，这意味着间隔(start, end)包括start和end。对于每个给定的区间，假设它的起始点小于或等于它的结束点。你的任务是确定这两个区间的交集长度是否为质数"}
{"task_id": "Go/128", "prompt": "import (\n    \"math\"\n)\n\n// You are given an array arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the array, represented by 1, -1 or 0.\n// Note: return nil for empty arr.\n// \n// Example:\n// >>> ProdSigns([1, 2, 2, -4]) == -9\n// >>> ProdSigns([0, 1]) == 0\n// >>> ProdSigns([]) == nil\nfunc ProdSigns(arr []int) interface{} {\n", "import": "import (\n    \"math\"\n)\n", "docstring": "// You are given an array arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the array, represented by 1, -1 or 0.\n// Note: return nil for empty arr.\n// \n// Example:\n// >>> ProdSigns([1, 2, 2, -4]) == -9\n// >>> ProdSigns([0, 1]) == 0\n// >>> ProdSigns([]) == nil\n", "declaration": "\nfunc ProdSigns(arr []int) interface{} {\n", "canonical_solution": "    if len(arr) == 0 {\n        return nil\n    }\n    cnt := 0\n    sum := 0\n    for _, i := range arr {\n        if i == 0 {\n            return 0\n        }\n        if i < 0 {\n            cnt++\n        }\n        sum += int(math.Abs(float64(i)))\n    }\n\n    prod := int(math.Pow(-1, float64(cnt)))\n    return prod * sum\n}\n\n", "test": "func TestProdSigns(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(-9, ProdSigns([]int{1, 2, 2, -4}))\n    assert.Equal(0, ProdSigns([]int{0, 1}))\n    assert.Equal(-10, ProdSigns([]int{1, 1, 1, 2, 3, -1, 1}))\n    assert.Equal(nil, ProdSigns([]int{}))\n    assert.Equal(20, ProdSigns([]int{2, 4,1, 2, -1, -1, 9}))\n    assert.Equal(4, ProdSigns([]int{-1, 1, -1, 1}))\n    assert.Equal(-4, ProdSigns([]int{-1, 1, 1, 1}))\n    assert.Equal(0, ProdSigns([]int{-1, 1, 1, 0}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestProdSigns(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(-9, ProdSigns([]int{1, 2, 2, -4}))\n    assert.Equal(0, ProdSigns([]int{0, 1}))\n    assert.Equal(nil, ProdSigns([]int{}))\n}\n", "prompt_text": "You are given an array arr of integers and you need to return sum of magnitudes of integers multiplied by product of all signs of each number in the array, represented by 1, -1 or 0. Note: return nil for empty arr.  Example:", "prompt_explain": "You are given an array arr of integers and you need to return\nsum of magnitudes of integers multiplied by product of all signs\nof each number in the array, represented by 1, -1 or 0.\nNote: return nil for empty arr.\n\nExample:\n>>> ProdSigns([1, 2, 2, -4]) == -9\n>>> ProdSigns([0, 1]) == 0\n>>> ProdSigns([]) == nil\n", "func_title": "func ProdSigns(arr []int) interface{} ", "prompt_text_chinese": "给你一个整数数组arr，你需要返回整数大小的和乘以数组中每个数字的所有符号的乘积，用1、-1或0表示。注意:空arr返回nil"}
{"task_id": "Go/129", "prompt": "\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k,\n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// \n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered lists of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered list of the values on the cells that the minimum path go through.\n// \n// Examples:\n// \n// Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n// Output: [1, 2, 1]\n// \n// Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n// Output: [1]\nfunc Minpath(grid [][]int, k int) []int {\n", "import": "", "docstring": "// Given a grid with N rows and N columns (N >= 2) and a positive integer k,\n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// \n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered lists of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered list of the values on the cells that the minimum path go through.\n// \n// Examples:\n// \n// Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n// Output: [1, 2, 1]\n// \n// Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n// Output: [1]\n", "declaration": "\nfunc Minpath(grid [][]int, k int) []int {\n", "canonical_solution": "    n := len(grid)\n    val := n * n + 1\n    for i:= 0;i < n; i++ {\n        for j := 0;j < n;j++ {\n            if grid[i][j] == 1 {\n                temp := make([]int, 0)\n                if i != 0 {\n                    temp = append(temp, grid[i - 1][j])\n                }\n\n                if j != 0 {\n                    temp = append(temp, grid[i][j - 1])\n                }\n\n                if i != n - 1 {\n                    temp = append(temp, grid[i + 1][j])\n                }\n\n                if j != n - 1 {\n                    temp = append(temp, grid[i][j + 1])\n                }\n                for _, x := range temp {\n                    if x < val {\n                        val = x\n                    }\n                }\n            }\n        }\n    }\n\n    ans := make([]int, 0, k)\n    for i := 0;i < k;i++ {\n        if i & 1 == 0 {\n            ans = append(ans,  1)\n        } else {\n            ans = append(ans,  val)\n        }\n    }\n    return ans\n}\n\n", "test": "func TestMinPath(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{1, 2, 1}, Minpath([][]int{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, 3))\n    assert.Equal([]int{1}, Minpath([][]int{{5, 9, 3}, {4, 1, 6}, {7, 8, 2}}, 1))\n    assert.Equal([]int{1, 2, 1, 2}, Minpath([][]int{{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}}, 4))\n    assert.Equal([]int{1, 10, 1, 10, 1, 10, 1}, Minpath([][]int{{6, 4, 13, 10}, {5, 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}}, 7))\n    assert.Equal([]int{1, 7, 1, 7, 1}, Minpath([][]int{{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3, 10, 11, 16}}, 5))\n    assert.Equal([]int{1, 6, 1, 6, 1, 6, 1, 6, 1}, Minpath([][]int{{11, 8, 7, 2}, {5, 16, 14, 4}, {9, 3, 15, 6}, {12, 13, 10, 1}}, 9))\n    assert.Equal([]int{1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6}, Minpath([][]int{{12, 13, 10, 1}, {9, 3, 15, 6}, {5, 16, 14, 4}, {11, 8, 7, 2}}, 12))\n    assert.Equal([]int{1, 3, 1, 3, 1, 3, 1, 3}, Minpath([][]int{{2, 7, 4}, {3, 1, 5}, {6, 8, 9}}, 8))\n    assert.Equal([]int{1, 5, 1, 5, 1, 5, 1, 5}, Minpath([][]int{{6, 1, 5}, {3, 8, 9}, {2, 7, 4}}, 8))\n    assert.Equal([]int{1, 2, 1, 2, 1, 2, 1, 2, 1, 2}, Minpath([][]int{{1, 2}, {3, 4}}, 10))\n    assert.Equal([]int{1, 3, 1, 3, 1, 3, 1, 3, 1, 3}, Minpath([][]int{{1, 3}, {3, 2}}, 10))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestMinPath(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{1, 2, 1}, Minpath([][]int{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, 3))\n    assert.Equal([]int{1}, Minpath([][]int{{5, 9, 3}, {4, 1, 6}, {7, 8, 2}}, 1))\n}\n", "prompt_text": "", "prompt_explain": "Given a grid with N rows and N columns (N >= 2) and a positive integer k,\neach cell of the grid contains a value. Every integer in the range [1, N * N]\ninclusive appears exactly once on the cells of the grid.\n\nYou have to find the minimum path of length k in the grid. You can start\nfrom any cell, and in each step you can move to any of the neighbor cells,\nin other words, you can go to cells which share an edge with you current\ncell.\nPlease note that a path of length k means visiting exactly k cells (not\nnecessarily distinct).\nYou CANNOT go off the grid.\nA path A (of length k) is considered less than a path B (of length k) if\nafter making the ordered lists of the values on the cells that A and B go\nthrough (let's call them lst_A and lst_B), lst_A is lexicographically less\nthan lst_B, in other words, there exist an integer index i (1 <= i <= k)\nsuch that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\nlst_A[j] = lst_B[j].\nIt is guaranteed that the answer is unique.\nReturn an ordered list of the values on the cells that the minimum path go through.\n\nExamples:\n\nInput: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\nOutput: [1, 2, 1]\n\nInput: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\nOutput: [1]\n", "func_title": "func Minpath(grid [][]int, k int) []int ", "prompt_text_chinese": "给定一个有N行N列(N >= 2)和正整数k的网格，网格的每个单元格都包含一个值。包括[1,N * N]在内的范围内的每个整数在网格的单元格中恰好出现一次。你必须找到网格中长度为k的最小路径。你可以从任何单元格开始，每一步你都可以移动到任何相邻的单元格，换句话说，你可以移动到与当前单元格共享一条边的单元格。请注意，长度为k的路径意味着访问k个单元格(不一定是不同的)。你不能离开电网。路径长度(k)被认为是不到一个路径B (k)长度值的有序列表后如果A和B细胞经历(我们称之为lst_A lst_B) lst_A按小于lst_B,换句话说,存在一个整数指数(1 < =我< = k)这样lst_A[我]< lst_B[我]和任何j(1 < = <我)我们有lst_A [j] = lst_B [j]。它保证答案是唯一的。返回最小路径所经过的单元格上的值的有序列表。"}
{"task_id": "Go/130", "prompt": "\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in\n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// Tri(1) = 3\n// Tri(n) = 1 + n / 2, if n is even.\n// Tri(n) =  Tri(n - 1) + Tri(n - 2) + Tri(n + 1), if n is odd.\n// For example:\n// Tri(2) = 1 + (2 / 2) = 2\n// Tri(4) = 3\n// Tri(3) = Tri(2) + Tri(1) + Tri(4)\n// = 2 + 3 + 3 = 8\n// You are given a non-negative integer number n, you have to a return a list of the\n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// Tri(3) = [1, 3, 2, 8]\nfunc Tri(n int) []float64 {\n", "import": "", "docstring": "// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in\n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// Tri(1) = 3\n// Tri(n) = 1 + n / 2, if n is even.\n// Tri(n) =  Tri(n - 1) + Tri(n - 2) + Tri(n + 1), if n is odd.\n// For example:\n// Tri(2) = 1 + (2 / 2) = 2\n// Tri(4) = 3\n// Tri(3) = Tri(2) + Tri(1) + Tri(4)\n// = 2 + 3 + 3 = 8\n// You are given a non-negative integer number n, you have to a return a list of the\n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// Tri(3) = [1, 3, 2, 8]\n", "declaration": "\nfunc Tri(n int) []float64 {\n", "canonical_solution": "    if n == 0 {\n        return []float64{1}\n    }\n    my_tri := []float64{1, 3}\n    for i := 2; i < n + 1; i++ {\n        if i &1 == 0 {\n            my_tri = append(my_tri, float64(i) / 2 + 1)\n        } else {\n            my_tri = append(my_tri, my_tri[i - 1] + my_tri[i - 2] + (float64(i) + 3) / 2)\n        }\n    }\n    return my_tri\n}\n\n", "test": "func TestTri(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]float64{1, 3, 2.0, 8.0}, Tri(3))\n    assert.Equal([]float64{1, 3, 2.0, 8.0, 3.0}, Tri(4))\n    assert.Equal([]float64{1, 3, 2.0, 8.0, 3.0, 15.0}, Tri(5))\n    assert.Equal([]float64{1, 3, 2.0, 8.0, 3.0, 15.0, 4.0}, Tri(6))\n    assert.Equal([]float64{1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0}, Tri(7))\n    assert.Equal([]float64{1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0}, Tri(8))\n    assert.Equal([]float64{1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0}, Tri(9))\n    assert.Equal([]float64{1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0}, Tri(20))\n    assert.Equal([]float64{1}, Tri(0))\n    assert.Equal([]float64{1, 3}, Tri(1))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestTri(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]float64{1, 3, 2.0, 8.0}, Tri(3))\n}\n", "prompt_text": "", "prompt_explain": "Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in\nthe last couple centuries. However, what people don't know is Tribonacci sequence.\nTribonacci sequence is defined by the recurrence:\nTri(1) = 3\nTri(n) = 1 + n / 2, if n is even.\nTri(n) =  Tri(n - 1) + Tri(n - 2) + Tri(n + 1), if n is odd.\nFor example:\nTri(2) = 1 + (2 / 2) = 2\nTri(4) = 3\nTri(3) = Tri(2) + Tri(1) + Tri(4)\n= 2 + 3 + 3 = 8\nYou are given a non-negative integer number n, you have to a return a list of the\nfirst n + 1 numbers of the Tribonacci sequence.\nExamples:\nTri(3) = [1, 3, 2, 8]\n", "func_title": "func Tri(n int) []float64 ", "prompt_text_chinese": "每个人都知道斐波那契数列，在过去的几个世纪里，数学家对它进行了深入的研究。然而，人们不知道的是Tribonacci数列。Tribonacci数列由以下递归式定义:当n为偶数时，Tri(1) = 3 Tri(n) = 1 + n / 2。如果n是奇数，Tri(n) = Tri(n - 1) + Tri(n - 2) + Tri(n + 1)。"}
{"task_id": "Go/131", "prompt": "import (\n    \"strconv\"\n)\n\n// Given a positive integer n, return the product of the odd Digits.\n// Return 0 if all Digits are even.\n// For example:\n// Digits(1)  == 1\n// Digits(4)  == 0\n// Digits(235) == 15\nfunc Digits(n int) int {\n", "import": "import (\n    \"strconv\"\n)\n", "docstring": "// Given a positive integer n, return the product of the odd Digits.\n// Return 0 if all Digits are even.\n// For example:\n// Digits(1)  == 1\n// Digits(4)  == 0\n// Digits(235) == 15\n", "declaration": "\nfunc Digits(n int) int {\n", "canonical_solution": "    product := 1\n    odd_count := 0\n    for _, digit := range strconv.Itoa(n) {\n        int_digit := int(digit-'0')\n        if int_digit&1 == 1 {\n            product= product*int_digit\n            odd_count++\n        }\n    }\n    if odd_count==0 {\n        return 0\n    }\n    return product\n}\n\n", "test": "func TestDigits(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(5, Digits(5))\n    assert.Equal(5, Digits(54))\n    assert.Equal(1, Digits(120))\n    assert.Equal(5, Digits(5014))\n    assert.Equal(315, Digits(98765))\n    assert.Equal(2625, Digits(5576543))\n    assert.Equal(0, Digits(2468))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestDigits(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(1, Digits(1))\n    assert.Equal(0, Digits(4))\n    assert.Equal(15, Digits(235))\n}\n", "prompt_text": "", "prompt_explain": "Given a positive integer n, return the product of the odd Digits.\nReturn 0 if all Digits are even.\nFor example:\nDigits(1)  == 1\nDigits(4)  == 0\nDigits(235) == 15\n", "func_title": "func Digits(n int) int ", "prompt_text_chinese": "给定一个正整数n，返回奇数的乘积。如果所有数字都是偶数，则返回0。"}
{"task_id": "Go/132", "prompt": "\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets\n// where at least one bracket in the subsequence is nested.\n// \n// IsNested('[[]]') ➞ true\n// IsNested('[]]]]]]][[[[[]') ➞ false\n// IsNested('[][]') ➞ false\n// IsNested('[]') ➞ false\n// IsNested('[[][]]') ➞ true\n// IsNested('[[]][[') ➞ true\nfunc IsNested(s string) bool {\n", "import": "", "docstring": "// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets\n// where at least one bracket in the subsequence is nested.\n// \n// IsNested('[[]]') ➞ true\n// IsNested('[]]]]]]][[[[[]') ➞ false\n// IsNested('[][]') ➞ false\n// IsNested('[]') ➞ false\n// IsNested('[[][]]') ➞ true\n// IsNested('[[]][[') ➞ true\n", "declaration": "\nfunc IsNested(s string) bool {\n", "canonical_solution": "    opening_bracket_index := make([]int, 0)\n    closing_bracket_index := make([]int, 0)\n    for i:=0;i < len(s);i++ {\n        if s[i] == '[' {\n            opening_bracket_index = append(opening_bracket_index, i)\n        } else {\n            closing_bracket_index = append(closing_bracket_index, i)\n        }\n    }\n    for i := 0;i < len(closing_bracket_index)>>1;i++ {\n        closing_bracket_index[i], closing_bracket_index[len(closing_bracket_index)-i-1] = closing_bracket_index[len(closing_bracket_index)-i-1], closing_bracket_index[i]\n    }\n    cnt := 0\n    i := 0\n    l := len(closing_bracket_index)\n    for _, idx := range opening_bracket_index {\n        if i < l && idx < closing_bracket_index[i] {\n            cnt++\n            i++\n        }\n    }\n    return cnt >= 2\n}\n\n    \n\n", "test": "func TestIsNested(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, IsNested(\"[[]]\"))\n    assert.Equal(false, IsNested(\"[]]]]]]][[[[[]\"))\n    assert.Equal(false, IsNested(\"[][]\"))\n    assert.Equal(false, IsNested(\"'[]'\"))\n    assert.Equal(true, IsNested(\"[[[[]]]]\"))\n    assert.Equal(false, IsNested(\"[]]]]]]]]]]\"))\n    assert.Equal(true, IsNested(\"[][][[]]\"))\n    assert.Equal(false, IsNested(\"[[]\"))\n    assert.Equal(false, IsNested(\"[]]\"))\n    assert.Equal(true, IsNested(\"[[]][[\"))\n    assert.Equal(true, IsNested(\"[[][]]\"))\n    assert.Equal(false, IsNested(\"\"))\n    assert.Equal(false, IsNested(\"[[[[[[[[\"))\n    assert.Equal(false, IsNested(\"]]]]]]]]\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestIsNested(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, IsNested(\"[[]]\"))\n    assert.Equal(false, IsNested(\"[]]]]]]][[[[[]\"))\n    assert.Equal(false, IsNested(\"[][]\"))\n    assert.Equal(false, IsNested(\"'[]'\"))\n    assert.Equal(true, IsNested(\"[[]][[\"))\n    assert.Equal(true, IsNested(\"[[][]]\"))\n}\n", "prompt_text": "", "prompt_explain": "Create a function that takes a string as input which contains only square brackets.\nThe function should return true if and only if there is a valid subsequence of brackets\nwhere at least one bracket in the subsequence is nested.\n\nIsNested('[[]]') ➞ true\nIsNested('[]]]]]]][[[[[]') ➞ false\nIsNested('[][]') ➞ false\nIsNested('[]') ➞ false\nIsNested('[[][]]') ➞ true\nIsNested('[[]][[') ➞ true\n", "func_title": "func IsNested(s string) bool ", "prompt_text_chinese": "创建一个函数，该函数接受一个字符串作为输入，该字符串只包含方括号。当且仅当存在括号的有效子序列，且该子序列中至少有一个括号嵌套时，函数应返回true。"}
{"task_id": "Go/133", "prompt": "import (\n    \"math\"\n)\n\n// You are given a list of numbers.\n// You need to return the sum of squared numbers in the given list,\n// round each element in the list to the upper int(Ceiling) first.\n// Examples:\n// For lst = [1,2,3] the output should be 14\n// For lst = [1,4,9] the output should be 98\n// For lst = [1,3,5,7] the output should be 84\n// For lst = [1.4,4.2,0] the output should be 29\n// For lst = [-2.4,1,1] the output should be 6\nfunc SumSquares(lst []float64) int {\n", "import": "import (\n    \"math\"\n)\n", "docstring": "// You are given a list of numbers.\n// You need to return the sum of squared numbers in the given list,\n// round each element in the list to the upper int(Ceiling) first.\n// Examples:\n// For lst = [1,2,3] the output should be 14\n// For lst = [1,4,9] the output should be 98\n// For lst = [1,3,5,7] the output should be 84\n// For lst = [1.4,4.2,0] the output should be 29\n// For lst = [-2.4,1,1] the output should be 6\n", "declaration": "\nfunc SumSquares(lst []float64) int {\n", "canonical_solution": "    squared := 0\n    for _, i := range lst {\n        squared += int(math.Pow(math.Ceil(i), 2))\n    }\n    return squared\n}\n\n", "test": "func TestSumSquares(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(14, SumSquares([]float64{1,2,3}))\n    assert.Equal(14, SumSquares([]float64{1.0,2,3}))\n    assert.Equal(84, SumSquares([]float64{1,3,5,7}))\n    assert.Equal(29, SumSquares([]float64{1.4,4.2,0}))\n    assert.Equal(6, SumSquares([]float64{-2.4,1,1}))\n    assert.Equal(10230, SumSquares([]float64{100,1,15,2}))\n    assert.Equal(200000000, SumSquares([]float64{10000,10000}))\n    assert.Equal(75, SumSquares([]float64{-1.4,4.6,6.3}))\n    assert.Equal(1086, SumSquares([]float64{-1.4,17.9,18.9,19.9}))\n    assert.Equal(0, SumSquares([]float64{0}))\n    assert.Equal(1, SumSquares([]float64{-1}))\n    assert.Equal(2, SumSquares([]float64{-1,1,0}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSumSquares(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(14, SumSquares([]float64{1,2,3}))\n    assert.Equal(98, SumSquares([]float64{1,4,9}))\n    assert.Equal(84, SumSquares([]float64{1,3,5,7}))\n    assert.Equal(29, SumSquares([]float64{1.4,4.2,0}))\n    assert.Equal(6, SumSquares([]float64{-2.4,1,1}))\n}\n", "prompt_text": "", "prompt_explain": "You are given a list of numbers.\nYou need to return the sum of squared numbers in the given list,\nround each element in the list to the upper int(Ceiling) first.\nExamples:\nFor lst = [1,2,3] the output should be 14\nFor lst = [1,4,9] the output should be 98\nFor lst = [1,3,5,7] the output should be 84\nFor lst = [1.4,4.2,0] the output should be 29\nFor lst = [-2.4,1,1] the output should be 6\n", "func_title": "func SumSquares(lst []float64) int ", "prompt_text_chinese": "给你一个数字列表。您需要返回给定列表中数字的平方和，首先将列表中的每个元素四舍五入为上整数(Ceiling)"}
{"task_id": "Go/134", "prompt": "import (\n    \"strings\"\n)\n\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// \n// Examples:\n// CheckIfLastCharIsALetter(\"apple pie\") ➞ false\n// CheckIfLastCharIsALetter(\"apple pi e\") ➞ true\n// CheckIfLastCharIsALetter(\"apple pi e \") ➞ false\n// CheckIfLastCharIsALetter(\"\") ➞ false\nfunc CheckIfLastCharIsALetter(txt string) bool {\n", "import": "import (\n    \"strings\"\n)\n", "docstring": "// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// \n// Examples:\n// CheckIfLastCharIsALetter(\"apple pie\") ➞ false\n// CheckIfLastCharIsALetter(\"apple pi e\") ➞ true\n// CheckIfLastCharIsALetter(\"apple pi e \") ➞ false\n// CheckIfLastCharIsALetter(\"\") ➞ false\n", "declaration": "\nfunc CheckIfLastCharIsALetter(txt string) bool {\n", "canonical_solution": "    split := strings.Split(txt, \" \")\n    check := strings.ToLower(split[len(split)-1])\n    if len(check) == 1 && 'a' <= check[0] && check[0] <= 'z' {\n        return true\n    }\n    return false\n}\n\n", "test": "func TestCheckIfLastCharIsALetter(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(false, CheckIfLastCharIsALetter(\"apple\"))\n    assert.Equal(true, CheckIfLastCharIsALetter(\"apple pi e\"))\n    assert.Equal(false, CheckIfLastCharIsALetter(\"eeeee\"))\n    assert.Equal(true, CheckIfLastCharIsALetter(\"A\"))\n    assert.Equal(false, CheckIfLastCharIsALetter(\"Pumpkin pie \"))\n    assert.Equal(false, CheckIfLastCharIsALetter(\"Pumpkin pie 1\"))\n    assert.Equal(false, CheckIfLastCharIsALetter(\"\"))\n    assert.Equal(false, CheckIfLastCharIsALetter(\"eeeee e \"))\n    assert.Equal(false, CheckIfLastCharIsALetter(\"apple pie\"))\n    assert.Equal(false, CheckIfLastCharIsALetter(\"apple pi e \"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestCheckIfLastCharIsALetter(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, CheckIfLastCharIsALetter(\"apple pi e\"))\n    assert.Equal(false, CheckIfLastCharIsALetter(\"\"))\n    assert.Equal(false, CheckIfLastCharIsALetter(\"apple pie\"))\n    assert.Equal(false, CheckIfLastCharIsALetter(\"apple pi e \"))\n}\n", "prompt_text": "", "prompt_explain": "Create a function that returns true if the last character\nof a given string is an alphabetical character and is not\na part of a word, and false otherwise.\nNote: \"word\" is a group of characters separated by space.\n\nExamples:\nCheckIfLastCharIsALetter(\"apple pie\") ➞ false\nCheckIfLastCharIsALetter(\"apple pi e\") ➞ true\nCheckIfLastCharIsALetter(\"apple pi e \") ➞ false\nCheckIfLastCharIsALetter(\"\") ➞ false\n", "func_title": "func CheckIfLastCharIsALetter(txt string) bool ", "prompt_text_chinese": "创建一个函数，如果给定字符串的最后一个字符是字母字符并且不是单词的一部分，则返回true，否则返回false。注:“字”是一组用空格分隔的字符。"}
{"task_id": "Go/135", "prompt": "\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given array will not contain\n// duplicate values.\n// \n// Examples:\n// CanArrange([1,2,4,3,5]) = 3\n// CanArrange([1,2,3]) = -1\nfunc CanArrange(arr []int) int {\n", "import": "", "docstring": "// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given array will not contain\n// duplicate values.\n// \n// Examples:\n// CanArrange([1,2,4,3,5]) = 3\n// CanArrange([1,2,3]) = -1\n", "declaration": "\nfunc CanArrange(arr []int) int {\n", "canonical_solution": "    ind:=-1\n    i:=1\n    for i<len(arr) {\n      if arr[i]<arr[i-1] {\n        ind=i\n      }\n      i++\n    }\n    return ind\n}\n\n", "test": "func TestCanArrange(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(3, CanArrange([]int{1,2,4,3,5}))\n    assert.Equal(-1, CanArrange([]int{1,2,4,5}))\n    assert.Equal(2, CanArrange([]int{1,4,2,5,6,7,8,9,10}))\n    assert.Equal(4, CanArrange([]int{4,8,5,7,3}))\n    assert.Equal(-1, CanArrange([]int{}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestCanArrange(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(3, CanArrange([]int{1,2,4,3,5}))\n    assert.Equal(-1, CanArrange([]int{1,2,3}))\n}\n", "prompt_text": "", "prompt_explain": "Create a function which returns the largest index of an element which\nis not greater than or equal to the element immediately preceding it. If\nno such element exists then return -1. The given array will not contain\nduplicate values.\n\nExamples:\nCanArrange([1,2,4,3,5]) = 3\nCanArrange([1,2,3]) = -1\n", "func_title": "func CanArrange(arr []int) int ", "prompt_text_chinese": "创建一个函数，返回不大于或等于紧挨着它前面的元素的最大下标。如果不存在这样的元素，则返回-1。给定的数组将不包含重复的值。"}
{"task_id": "Go/136", "prompt": "\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a list.\n// If there is no negative or positive integers, return them as nil.\n// \n// Examples:\n// LargestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (nil, 1)\n// LargestSmallestIntegers([]) == (nil, nil)\n// LargestSmallestIntegers([0]) == (nil, nil)\nfunc LargestSmallestIntegers(lst []int) [2]interface{}{\n", "import": "", "docstring": "// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a list.\n// If there is no negative or positive integers, return them as nil.\n// \n// Examples:\n// LargestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (nil, 1)\n// LargestSmallestIntegers([]) == (nil, nil)\n// LargestSmallestIntegers([0]) == (nil, nil)\n", "declaration": "\nfunc LargestSmallestIntegers(lst []int) [2]interface{}{\n", "canonical_solution": "    smallest := make([]int, 0)\n    largest := make([]int, 0)\n    for _, x := range lst {\n        if x < 0 {\n            smallest = append(smallest, x)\n        } else if x > 0 {\n            largest = append(largest, x)\n        }\n    }\n    var result [2]interface{}\n    if len(smallest) == 0 {\n        result[0] = nil\n    } else {\n        max := smallest[0]\n        for i := 1;i < len(smallest);i++ {\n            if smallest[i] > max {\n                max = smallest[i]\n            }\n        }\n        result[0] = max\n    }\n    if len(largest) == 0 {\n        result[1] = nil\n    } else {\n        min := largest[0]\n        for i := 1;i < len(largest);i++ {\n            if largest[i] < min {\n                min = largest[i]\n            }\n        }\n        result[1] = min\n    }\n    return result\n}\n\n", "test": "func TestLargestSmallestIntegers(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([2]interface{}{nil, 1}, LargestSmallestIntegers([]int{2, 4, 1, 3, 5, 7}))\n    assert.Equal([2]interface{}{nil, 1}, LargestSmallestIntegers([]int{2, 4, 1, 3, 5, 7, 0}))\n    assert.Equal([2]interface{}{-2, 1}, LargestSmallestIntegers([]int{1, 3, 2, 4, 5, 6, -2}))\n    assert.Equal([2]interface{}{-7, 2}, LargestSmallestIntegers([]int{4, 5, 3, 6, 2, 7, -7}))\n    assert.Equal([2]interface{}{-9, 2}, LargestSmallestIntegers([]int{7, 3, 8, 4, 9, 2, 5, -9}))\n    assert.Equal([2]interface{}{nil, nil}, LargestSmallestIntegers([]int{}))\n    assert.Equal([2]interface{}{nil, nil}, LargestSmallestIntegers([]int{0}))\n    assert.Equal([2]interface{}{-1, nil}, LargestSmallestIntegers([]int{-1, -3, -5, -6}))\n    assert.Equal([2]interface{}{-1, nil}, LargestSmallestIntegers([]int{-1, -3, -5, -6, 0}))\n    assert.Equal([2]interface{}{-3, 1}, LargestSmallestIntegers([]int{-6, -4, -4, -3, 1}))\n    assert.Equal([2]interface{}{-3, 1}, LargestSmallestIntegers([]int{-6, -4, -4, -3, -100, 1}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestLargestSmallestIntegers(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([2]interface{}{nil, 1}, LargestSmallestIntegers([]int{2, 4, 1, 3, 5, 7}))\n    assert.Equal([2]interface{}{nil, nil}, LargestSmallestIntegers([]int{}))\n    assert.Equal([2]interface{}{nil, nil}, LargestSmallestIntegers([]int{0}))\n}\n", "prompt_text": "", "prompt_explain": "Create a function that returns a tuple (a, b), where 'a' is\nthe largest of negative integers, and 'b' is the smallest\nof positive integers in a list.\nIf there is no negative or positive integers, return them as nil.\n\nExamples:\nLargestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (nil, 1)\nLargestSmallestIntegers([]) == (nil, nil)\nLargestSmallestIntegers([0]) == (nil, nil)\n", "func_title": "func LargestSmallestIntegers(lst []int) [2]interface{}", "prompt_text_chinese": "创建一个函数，返回一个元组(a, b)，其中'a'是列表中最大的负整数，'b'是列表中最小的正整数。如果没有负整数或正整数，则将它们返回为nil"}
{"task_id": "Go/137", "prompt": "import (\n    \"fmt\"\n    \"strconv\"\n    \"strings\"\n)\n\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return nil if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// \n// CompareOne(1, 2.5) ➞ 2.5\n// CompareOne(1, \"2,3\") ➞ \"2,3\"\n// CompareOne(\"5,1\", \"6\") ➞ \"6\"\n// CompareOne(\"1\", 1) ➞ nil\nfunc CompareOne(a, b interface{}) interface{} {\n", "import": "import (\n    \"fmt\"\n    \"strconv\"\n    \"strings\"\n)\n", "docstring": "// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return nil if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// \n// CompareOne(1, 2.5) ➞ 2.5\n// CompareOne(1, \"2,3\") ➞ \"2,3\"\n// CompareOne(\"5,1\", \"6\") ➞ \"6\"\n// CompareOne(\"1\", 1) ➞ nil\n", "declaration": "\nfunc CompareOne(a, b interface{}) interface{} {\n", "canonical_solution": "    temp_a := fmt.Sprintf(\"%v\", a)\n    temp_b := fmt.Sprintf(\"%v\", b)\n    temp_a = strings.ReplaceAll(temp_a, \",\", \".\")\n    temp_b = strings.ReplaceAll(temp_b, \",\", \".\")\n    fa, _ := strconv.ParseFloat(temp_a, 64)\n    fb, _ := strconv.ParseFloat(temp_b, 64)\n    \n    if fa == fb {\n        return nil\n    }\n    if fa > fb {\n        return a\n    } else {\n        return b\n    }\n}\n\n", "test": "func TestCompareOne(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(2, CompareOne(1, 2))\n    assert.Equal(2.5, CompareOne(1, 2.5))\n    assert.Equal(3, CompareOne(2, 3))\n    assert.Equal(6, CompareOne(5, 6))\n    assert.Equal(\"2,3\", CompareOne(1, \"2,3\"))\n    assert.Equal(\"6\", CompareOne(\"5,1\", \"6\"))\n    assert.Equal(\"2\", CompareOne(\"1\", \"2\"))\n    assert.Equal(nil, CompareOne(\"1\", 1))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestCompareOne(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(2.5, CompareOne(1, 2.5))\n    assert.Equal(\"2,3\", CompareOne(1, \"2,3\"))\n    assert.Equal(\"6\", CompareOne(\"5,1\", \"6\"))\n    assert.Equal(nil, CompareOne(\"1\", 1))\n}\n", "prompt_text": "", "prompt_explain": "Create a function that takes integers, floats, or strings representing\nreal numbers, and returns the larger variable in its given variable type.\nReturn nil if the values are equal.\nNote: If a real number is represented as a string, the floating point might be . or ,\n\nCompareOne(1, 2.5) ➞ 2.5\nCompareOne(1, \"2,3\") ➞ \"2,3\"\nCompareOne(\"5,1\", \"6\") ➞ \"6\"\nCompareOne(\"1\", 1) ➞ nil\n", "func_title": "func CompareOne(a, b interface{}) interface{} ", "prompt_text_chinese": "创建一个函数，接受整数、浮点数或表示实数的字符串，并返回给定变量类型的较大变量。如果值相等，则返回nil"}
{"task_id": "Go/138", "prompt": "\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// IsEqualToSumEven(4) == false\n// IsEqualToSumEven(6) == false\n// IsEqualToSumEven(8) == true\nfunc IsEqualToSumEven(n int) bool {\n", "import": "", "docstring": "// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// IsEqualToSumEven(4) == false\n// IsEqualToSumEven(6) == false\n// IsEqualToSumEven(8) == true\n", "declaration": "\nfunc IsEqualToSumEven(n int) bool {\n", "canonical_solution": "    return n&1 == 0 && n >= 8\n}\n\n", "test": "func TestIsEqualToSumEven(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(false, IsEqualToSumEven(4))\n    assert.Equal(false, IsEqualToSumEven(6))\n    assert.Equal(true, IsEqualToSumEven(8))\n    assert.Equal(true, IsEqualToSumEven(10))\n    assert.Equal(false, IsEqualToSumEven(11))\n    assert.Equal(true, IsEqualToSumEven(12))\n    assert.Equal(false, IsEqualToSumEven(13))\n    assert.Equal(true, IsEqualToSumEven(16))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestIsEqualToSumEven(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(false, IsEqualToSumEven(4))\n    assert.Equal(false, IsEqualToSumEven(6))\n    assert.Equal(true, IsEqualToSumEven(8))\n}\n", "prompt_text": "", "prompt_explain": "Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\nExample\nIsEqualToSumEven(4) == false\nIsEqualToSumEven(6) == false\nIsEqualToSumEven(8) == true\n", "func_title": "func IsEqualToSumEven(n int) bool ", "prompt_text_chinese": "计算给定的数n是否可以写成恰好4个正偶数的和"}
{"task_id": "Go/139", "prompt": "\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// \n// For example:\n// >>> SpecialFactorial(4)\n// 288\n// \n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nfunc SpecialFactorial(n int) int {\n", "import": "", "docstring": "// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// \n// For example:\n// >>> SpecialFactorial(4)\n// 288\n// \n// The function will receive an integer as input and should return the special\n// factorial of this integer.\n", "declaration": "\nfunc SpecialFactorial(n int) int {\n", "canonical_solution": "    fact_i := 1\n    special_fact := 1\n    for i := 1; i <= n; i++ {\n        fact_i *= i\n        special_fact *= fact_i\n    }\n    return special_fact\n}\n\n", "test": "func TestSpecialFactorial(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(288, SpecialFactorial(4))\n    assert.Equal(34560, SpecialFactorial(5))\n    assert.Equal(125411328000, SpecialFactorial(7))\n    assert.Equal(1, SpecialFactorial(1))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSpecialFactorial(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(288, SpecialFactorial(4))\n}\n", "prompt_text": "The Brazilian factorial is defined as: brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! where n > 0  For example:", "prompt_explain": "The Brazilian factorial is defined as:\nbrazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\nwhere n > 0\n\nFor example:\n>>> SpecialFactorial(4)\n288\n\nThe function will receive an integer as input and should return the special\nfactorial of this integer.\n", "func_title": "func SpecialFactorial(n int) int ", "prompt_text_chinese": "巴西阶乘定义为:brazilian_factorial(n) = n!* (n - 1) !* (n - 2) !*……* 1 !，其中n > 0,该函数将接收一个整数作为输入，并应返回该整数的特殊阶乘。"}
{"task_id": "Go/140", "prompt": "\n// Given a string text, replace all spaces in it with underscores,\n// and if a string has more than 2 consecutive spaces,\n// then replace all consecutive spaces with -\n// \n// FixSpaces(\"Example\") == \"Example\"\n// FixSpaces(\"Example 1\") == \"Example_1\"\n// FixSpaces(\" Example 2\") == \"_Example_2\"\n// FixSpaces(\" Example   3\") == \"_Example-3\"\nfunc FixSpaces(text string) string {\n", "import": "", "docstring": "// Given a string text, replace all spaces in it with underscores,\n// and if a string has more than 2 consecutive spaces,\n// then replace all consecutive spaces with -\n// \n// FixSpaces(\"Example\") == \"Example\"\n// FixSpaces(\"Example 1\") == \"Example_1\"\n// FixSpaces(\" Example 2\") == \"_Example_2\"\n// FixSpaces(\" Example   3\") == \"_Example-3\"\n", "declaration": "\nfunc FixSpaces(text string) string {\n", "canonical_solution": "    new_text := make([]byte, 0)\n    i := 0\n    start, end := 0, 0\n    for i < len(text) {\n        if text[i] == ' ' {\n            end++\n        } else {\n            switch {\n            case end - start > 2:\n                new_text = append(new_text, '-')\n            case end - start > 0:\n                for n := 0;n < end-start;n++ {\n                    new_text = append(new_text, '_')\n                }\n            }\n            new_text = append(new_text, text[i])\n            start, end = i+1, i+1\n        }\n        i+=1\n    }\n    if end - start > 2 {\n        new_text = append(new_text, '-')\n    } else if end - start > 0 {\n        new_text = append(new_text, '_')\n    }\n    return string(new_text)\n}\n\n", "test": "func TestFixSpaces(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"Example\", FixSpaces(\"Example\"))\n    assert.Equal(\"Mudasir_Hanif_\", FixSpaces(\"Mudasir Hanif \"))\n    assert.Equal(\"Yellow_Yellow__Dirty__Fellow\", FixSpaces(\"Yellow Yellow  Dirty  Fellow\"))\n    assert.Equal(\"Exa-mple\", FixSpaces(\"Exa   mple\"))\n    assert.Equal(\"-Exa_1_2_2_mple\", FixSpaces(\"   Exa 1 2 2 mple\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestFixSpaces(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"Example\", FixSpaces(\"Example\"))\n    assert.Equal(\"Example_1\", FixSpaces(\"Example 1\"))\n    assert.Equal(\"_Example_2\", FixSpaces(\" Example 2\"))\n    assert.Equal(\"_Example-3\", FixSpaces(\" Example   3\"))\n}\n", "prompt_text": "", "prompt_explain": "Given a string text, replace all spaces in it with underscores,\nand if a string has more than 2 consecutive spaces,\nthen replace all consecutive spaces with -\n\nFixSpaces(\"Example\") == \"Example\"\nFixSpaces(\"Example 1\") == \"Example_1\"\nFixSpaces(\" Example 2\") == \"_Example_2\"\nFixSpaces(\" Example   3\") == \"_Example-3\"\n", "func_title": "func FixSpaces(text string) string ", "prompt_text_chinese": "给定一个字符串文本，将其中的所有空格替换为下划线，如果字符串有超过2个连续空格，则将所有连续空格替换为-"}
{"task_id": "Go/141", "prompt": "import (\n    \"strings\"\n)\n\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions\n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from\n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// FileNameCheck(\"example.txt\") # => 'Yes'\n// FileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\nfunc FileNameCheck(file_name string) string {\n", "import": "import (\n    \"strings\"\n)\n", "docstring": "// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions\n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from\n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// FileNameCheck(\"example.txt\") # => 'Yes'\n// FileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n", "declaration": "\nfunc FileNameCheck(file_name string) string {\n", "canonical_solution": "    suf := []string{\"txt\", \"exe\", \"dll\"}\n    lst := strings.Split(file_name, \".\")\n    isInArray := func (arr []string, x string) bool {\n        for _, y := range arr {\n            if x == y {\n                return true\n            }\n        }\n        return false\n    }\n    switch {\n    case len(lst) != 2:\n        return \"No\"\n    case !isInArray(suf, lst[1]):\n        return \"No\"\n    case len(lst[0]) == 0:\n        return \"No\"\n    case 'a' > strings.ToLower(lst[0])[0] || strings.ToLower(lst[0])[0] > 'z':\n        return \"No\"\n    }\n    t := 0\n    for _, c := range lst[0] {\n        if '0' <= c && c <= '9' {\n            t++\n        }\n    }\n    if t > 3 {\n        return \"No\"\n    }\n    return \"Yes\"\n}\n\n", "test": "func TestFileNameCheck(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"Yes\", FileNameCheck(\"example.txt\"))\n    assert.Equal(\"No\", FileNameCheck(\"1example.dll\"))\n    assert.Equal(\"No\", FileNameCheck(\"s1sdf3.asd\"))\n    assert.Equal(\"Yes\", FileNameCheck(\"K.dll\"))\n    assert.Equal(\"Yes\", FileNameCheck(\"MY16FILE3.exe\"))\n    assert.Equal(\"No\", FileNameCheck(\"His12FILE94.exe\"))\n    assert.Equal(\"No\", FileNameCheck(\"_Y.txt\"))\n    assert.Equal(\"No\", FileNameCheck(\"?aREYA.exe\"))\n    assert.Equal(\"No\", FileNameCheck(\"/this_is_valid.dll\"))\n    assert.Equal(\"No\", FileNameCheck(\"this_is_valid.wow\"))\n    assert.Equal(\"Yes\", FileNameCheck(\"this_is_valid.txt\"))\n    assert.Equal(\"No\", FileNameCheck(\"this_is_valid.txtexe\"))\n    assert.Equal(\"No\", FileNameCheck(\"#this2_i4s_5valid.ten\"))\n    assert.Equal(\"No\", FileNameCheck(\"@this1_is6_valid.exe\"))\n    assert.Equal(\"No\", FileNameCheck(\"this_is_12valid.6exe4.txt\"))\n    assert.Equal(\"No\", FileNameCheck(\"all.exe.txt\"))\n    assert.Equal(\"Yes\", FileNameCheck(\"I563_No.exe\"))\n    assert.Equal(\"Yes\", FileNameCheck(\"Is3youfault.txt\"))\n    assert.Equal(\"Yes\", FileNameCheck(\"no_one#knows.dll\"))\n    assert.Equal(\"No\", FileNameCheck(\"1I563_Yes3.exe\"))\n    assert.Equal(\"No\", FileNameCheck(\"I563_Yes3.txtt\"))\n    assert.Equal(\"No\", FileNameCheck(\"final..txt\"))\n    assert.Equal(\"No\", FileNameCheck(\"final132\"))\n    assert.Equal(\"No\", FileNameCheck(\"_f4indsartal132.\"))\n    assert.Equal(\"No\", FileNameCheck(\".txt\"))\n    assert.Equal(\"No\", FileNameCheck(\"s.\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestFileNameCheck(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"Yes\", FileNameCheck(\"example.txt\"))\n    assert.Equal(\"No\", FileNameCheck(\"1example.dll\"))\n}\n", "prompt_text": "", "prompt_explain": "Create a function which takes a string representing a file's name, and returns\n'Yes' if the the file's name is valid, and returns 'No' otherwise.\nA file's name is considered to be valid if and only if all the following conditions\nare met:\n- There should not be more than three digits ('0'-'9') in the file's name.\n- The file's name contains exactly one dot '.'\n- The substring before the dot should not be empty, and it starts with a letter from\nthe latin alphapet ('a'-'z' and 'A'-'Z').\n- The substring after the dot should be one of these: ['txt', 'exe', 'dll']\nExamples:\nFileNameCheck(\"example.txt\") # => 'Yes'\nFileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n", "func_title": "func FileNameCheck(file_name string) string ", "prompt_text_chinese": "创建一个函数，该函数接受一个表示文件名的字符串，如果文件名有效则返回'Yes'，否则返回'No'。当且仅当满足以下所有条件时，文件名才被认为是有效的:—文件名中不应超过三位数字('0'-'9')。-文件名中只包含一个点。-点前的子字符串不能为空，以拉丁字母开头('a'-'z'和'a'-'z')。点后面的子字符串应该是以下其中之一:['txt'， 'exe'， 'dll']"}
{"task_id": "Go/142", "prompt": "import (\n    \"math\"\n)\n\n// This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a\n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not\n// change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n// \n// Examples:\n// For lst = [1,2,3] the output should be 6\n// For lst = []  the output should be 0\n// For lst = [-1,-5,2,-1,-5]  the output should be -126\nfunc SumSquares(lst []int) int {\n", "import": "import (\n    \"math\"\n)\n", "docstring": "// This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a\n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not\n// change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n// \n// Examples:\n// For lst = [1,2,3] the output should be 6\n// For lst = []  the output should be 0\n// For lst = [-1,-5,2,-1,-5]  the output should be -126\n", "declaration": "\nfunc SumSquares(lst []int) int {\n", "canonical_solution": "    result := make([]int, 0)\n    for i := 0;i < len(lst);i++ {\n        switch {\n        case i %3 == 0:\n            result = append(result, int(math.Pow(float64(lst[i]), 2)))\n        case i % 4 == 0 && i%3 != 0:\n            result = append(result, int(math.Pow(float64(lst[i]), 3)))\n        default:\n            result = append(result, lst[i])\n        }\n    }\n    sum := 0\n    for _, x := range result {\n        sum += x\n    }\n    return sum\n}\n\n", "test": "func TestSumSquares(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(6, SumSquares([]int{1,2,3}))\n    assert.Equal(14, SumSquares([]int{1,4,9}))\n    assert.Equal(0, SumSquares([]int{}))\n    assert.Equal(9, SumSquares([]int{1,1,1,1,1,1,1,1,1}))\n    assert.Equal(-3, SumSquares([]int{-1,-1,-1,-1,-1,-1,-1,-1,-1}))\n    assert.Equal(0, SumSquares([]int{0}))\n    assert.Equal(-126, SumSquares([]int{-1,-5,2,-1,-5}))\n    assert.Equal(3030, SumSquares([]int{-56,-99,1,0,-2}))\n    assert.Equal(0, SumSquares([]int{-1,0,0,0,0,0,0,0,-1}))\n    assert.Equal(-14196, SumSquares([]int{-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37}))\n    assert.Equal(-1448, SumSquares([]int{-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSumSquares(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(6, SumSquares([]int{1,2,3}))\n    assert.Equal(0, SumSquares([]int{}))\n    assert.Equal(-126, SumSquares([]int{-1,-5,2,-1,-5}))\n}\n", "prompt_text": "", "prompt_explain": "This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a\nmultiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not\nchange the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n\nExamples:\nFor lst = [1,2,3] the output should be 6\nFor lst = []  the output should be 0\nFor lst = [-1,-5,2,-1,-5]  the output should be -126\n", "func_title": "func SumSquares(lst []int) int ", "prompt_text_chinese": "这个函数将接受一个整数列表。对于列表中的所有条目，如果索引是3的倍数，则函数将对整数项进行平方;如果索引是4的倍数而不是3的倍数，则函数将对整数项进行立方。该函数将不会更改列表中索引不是3或4的倍数的条目。然后，函数将返回所有项的和。"}
{"task_id": "Go/143", "prompt": "import (\n    \"strings\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// \n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// \n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// \n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc WordsInSentence(sentence string) string {\n", "import": "import (\n    \"strings\"\n)\n", "docstring": "// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// \n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// \n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// \n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n", "declaration": "\nfunc WordsInSentence(sentence string) string {\n", "canonical_solution": "    new_lst := make([]string, 0)\n    for _, word := range strings.Fields(sentence) {\n        flg := 0\n        if len(word) == 1 {\n            flg = 1\n        }\n        for i := 2;i < len(word);i++ {\n            if len(word)%i == 0 {\n                flg = 1\n            }\n        }\n        if flg == 0 || len(word) == 2 {\n            new_lst = append(new_lst, word)\n        }\n    }\n    return strings.Join(new_lst, \" \")\n}\n\n", "test": "func TestWordsInSentence(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"is\", WordsInSentence(\"This is a test\"))\n    assert.Equal(\"go for\", WordsInSentence(\"lets go for swimming\"))\n    assert.Equal(\"there is no place\", WordsInSentence(\"there is no place available here\"))\n    assert.Equal(\"Hi am Hussein\", WordsInSentence(\"Hi I am Hussein\"))\n    assert.Equal(\"go for it\", WordsInSentence(\"go for it\"))\n    assert.Equal(\"\", WordsInSentence(\"here\"))\n    assert.Equal(\"is\", WordsInSentence(\"here is\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestWordsInSentence(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"is\", WordsInSentence(\"This is a test\"))\n    assert.Equal(\"go for\", WordsInSentence(\"lets go for swimming\"))\n}\n", "prompt_text": "", "prompt_explain": "You are given a string representing a sentence,\nthe sentence contains some words separated by a space,\nand you have to return a string that contains the words from the original sentence,\nwhose lengths are prime numbers,\nthe order of the words in the new string should be the same as the original one.\n\nExample 1:\nInput: sentence = \"This is a test\"\nOutput: \"is\"\n\nExample 2:\nInput: sentence = \"lets go for swimming\"\nOutput: \"go for\"\n\nConstraints:\n* 1 <= len(sentence) <= 100\n* sentence contains only letters\n", "func_title": "func WordsInSentence(sentence string) string ", "prompt_text_chinese": "给定一个表示一个句子的字符串，该句子包含一些用空格分隔的单词，并且必须返回一个包含原始句子中的单词的字符串，其长度为素数，新字符串中单词的顺序应与原始字符串相同。"}
{"task_id": "Go/144", "prompt": "import (\n    \"strconv\"\n    \"strings\"\n)\n\n// Your task is to implement a function that will Simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// \n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// \n// Simplify(\"1/5\", \"5/1\") = true\n// Simplify(\"1/6\", \"2/1\") = false\n// Simplify(\"7/10\", \"10/2\") = false\nfunc Simplify(x, n string) bool {\n", "import": "import (\n    \"strconv\"\n    \"strings\"\n)\n", "docstring": "// Your task is to implement a function that will Simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// \n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// \n// Simplify(\"1/5\", \"5/1\") = true\n// Simplify(\"1/6\", \"2/1\") = false\n// Simplify(\"7/10\", \"10/2\") = false\n", "declaration": "\nfunc Simplify(x, n string) bool {\n", "canonical_solution": "    xx := strings.Split(x, \"/\")\n    nn := strings.Split(n, \"/\")\n    a, _ := strconv.Atoi(xx[0])\n    b, _ := strconv.Atoi(xx[1])\n    c, _ := strconv.Atoi(nn[0])\n    d, _ := strconv.Atoi(nn[1])\n    numerator := float64(a*c)\n    denom := float64(b*d)\n    return numerator/denom == float64(int(numerator/denom))\n}\n\n", "test": "func TestSimplify(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, Simplify(\"1/5\", \"5/1\"))\n    assert.Equal(false, Simplify(\"1/6\", \"2/1\"))\n    assert.Equal(true, Simplify(\"5/1\", \"3/1\"))\n    assert.Equal(false, Simplify(\"7/10\", \"10/2\"))\n    assert.Equal(true, Simplify(\"2/10\", \"50/10\"))\n    assert.Equal(true, Simplify(\"7/2\", \"4/2\"))\n    assert.Equal(true, Simplify(\"11/6\", \"6/1\"))\n    assert.Equal(false, Simplify(\"2/3\", \"5/2\"))\n    assert.Equal(false, Simplify(\"5/2\", \"3/5\"))\n    assert.Equal(true, Simplify(\"2/4\", \"8/4\"))\n    assert.Equal(true, Simplify(\"2/4\", \"4/2\"))\n    assert.Equal(true, Simplify(\"1/5\", \"5/1\"))\n    assert.Equal(false, Simplify(\"1/5\", \"1/5\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSimplify(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, Simplify(\"1/5\", \"5/1\"))\n    assert.Equal(false, Simplify(\"1/6\", \"2/1\"))\n    assert.Equal(false, Simplify(\"7/10\", \"10/2\"))\n}\n", "prompt_text": "", "prompt_explain": "Your task is to implement a function that will Simplify the expression\nx * n. The function returns true if x * n evaluates to a whole number and false\notherwise. Both x and n, are string representation of a fraction, and have the following format,\n<numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\nYou can assume that x, and n are valid fractions, and do not have zero as denominator.\n\nSimplify(\"1/5\", \"5/1\") = true\nSimplify(\"1/6\", \"2/1\") = false\nSimplify(\"7/10\", \"10/2\") = false\n", "func_title": "func Simplify(x, n string) bool ", "prompt_text_chinese": "您的任务是实现一个函数来简化表达式x * n。如果x * n计算为整数，则函数返回true，否则返回false。x和n都是分数的字符串表示形式，格式如下:分子和分母都是正整数。你可以假设x和n是有效的分数，分母不为零。"}
{"task_id": "Go/145", "prompt": "import (\n    \"sort\"\n    \"strconv\"\n)\n\n// Write a function which sorts the given list of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original list.\n// \n// For example:\n// >>> OrderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n// >>> OrderByPoints([]) == []\nfunc OrderByPoints(nums []int) []int {\n", "import": "import (\n    \"sort\"\n    \"strconv\"\n)\n", "docstring": "// Write a function which sorts the given list of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original list.\n// \n// For example:\n// >>> OrderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n// >>> OrderByPoints([]) == []\n", "declaration": "\nfunc OrderByPoints(nums []int) []int {\n", "canonical_solution": "    digits_sum := func (n int) int {\n        neg := 1\n        if n < 0 {\n            n, neg = -1 * n, -1 \n        }\n        sum := 0\n        for i, c := range strconv.Itoa(n) {\n            if i == 0 {\n                sum += int(c-'0')*neg\n            } else {\n                sum += int(c-'0')\n            }\n        }\n        return sum\n    }\n    sort.SliceStable(nums, func(i, j int) bool {\n        return digits_sum(nums[i]) < digits_sum(nums[j])\n    })\n    return nums\n}\n\n", "test": "func TestOrderByPoints(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{-1, -11, 1, -12, 11}, OrderByPoints([]int{1, 11, -1, -11, -12}))\n    assert.Equal([]int{0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457}, OrderByPoints([]int{1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46}))\n    assert.Equal([]int{}, OrderByPoints([]int{}))\n    assert.Equal([]int{-3, -32, -98, -11, 1, 2, 43, 54}, OrderByPoints([]int{1, -11, -32, 43, 54, -98, 2, -3}))\n    assert.Equal([]int{1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9}, OrderByPoints([]int{1,2,3,4,5,6,7,8,9,10,11}))\n    assert.Equal([]int{-76, -21, 0, 4, 23, 6, 6}, OrderByPoints([]int{0,6,6,-76,-21,23,4}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestOrderByPoints(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{-1, -11, 1, -12, 11}, OrderByPoints([]int{1, 11, -1, -11, -12}))\n    assert.Equal([]int{}, OrderByPoints([]int{}))\n}\n", "prompt_text": "Write a function which sorts the given list of integers in ascending order according to the sum of their digits. Note: if there are several items with similar sum of their digits, order them based on their index in original list.  For example:", "prompt_explain": "Write a function which sorts the given list of integers\nin ascending order according to the sum of their digits.\nNote: if there are several items with similar sum of their digits,\norder them based on their index in original list.\n\nFor example:\n>>> OrderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n>>> OrderByPoints([]) == []\n", "func_title": "func OrderByPoints(nums []int) []int ", "prompt_text_chinese": "编写一个函数，根据给定整数的数字和按升序排序。注:如果有几项数字和相近，则按其在原列表中的索引排序。"}
{"task_id": "Go/146", "prompt": "import (\n    \"strconv\"\n)\n\n// Write a function that takes an array of numbers as input and returns\n// the number of elements in the array that are greater than 10 and both\n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// Specialfilter([15, -73, 14, -15]) => 1\n// Specialfilter([33, -2, -3, 45, 21, 109]) => 2\nfunc Specialfilter(nums []int) int {\n", "import": "import (\n    \"strconv\"\n)\n", "docstring": "// Write a function that takes an array of numbers as input and returns\n// the number of elements in the array that are greater than 10 and both\n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// Specialfilter([15, -73, 14, -15]) => 1\n// Specialfilter([33, -2, -3, 45, 21, 109]) => 2\n", "declaration": "\nfunc Specialfilter(nums []int) int {\n", "canonical_solution": "    count := 0\n    for _, num := range nums {\n        if num > 10 {\n            number_as_string := strconv.Itoa(num)\n            if number_as_string[0]&1==1 && number_as_string[len(number_as_string)-1]&1==1 {\n                count++\n            }\n        }\n    }        \n    return count\n}\n\n", "test": "func TestSpecialFilter(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(0, Specialfilter([]int{5, -2, 1, -5}))\n    assert.Equal(1, Specialfilter([]int{15, -73, 14, -15}))\n    assert.Equal(2, Specialfilter([]int{33, -2, -3, 45, 21, 109}))\n    assert.Equal(4, Specialfilter([]int{43, -12, 93, 125, 121, 109}))\n    assert.Equal(3, Specialfilter([]int{71, -2, -33, 75, 21, 19}))\n    assert.Equal(0, Specialfilter([]int{1}))\n    assert.Equal(0, Specialfilter([]int{}))\n}               \n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSpecialFilter(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(1, Specialfilter([]int{15, -73, 14, -15}))\n    assert.Equal(2, Specialfilter([]int{33, -2, -3, 45, 21, 109}))\n}               \n", "prompt_text": "", "prompt_explain": "Write a function that takes an array of numbers as input and returns\nthe number of elements in the array that are greater than 10 and both\nfirst and last digits of a number are odd (1, 3, 5, 7, 9).\nFor example:\nSpecialfilter([15, -73, 14, -15]) => 1\nSpecialfilter([33, -2, -3, 45, 21, 109]) => 2\n", "func_title": "func Specialfilter(nums []int) int ", "prompt_text_chinese": "编写一个函数，该函数接受一个数字数组作为输入，并返回数组中大于10且数字的第一位和最后一位都是奇数(1,3,5,7,9)的元素数量。"}
{"task_id": "Go/147", "prompt": "\n// You are given a positive integer n. You have to create an integer array a of length n.\n// For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,\n// and a[i] + a[j] + a[k] is a multiple of 3.\n// \n// Example :\n// Input: n = 5\n// Output: 1\n// Explanation:\n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nfunc GetMaxTriples(n int) int {\n", "import": "", "docstring": "// You are given a positive integer n. You have to create an integer array a of length n.\n// For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,\n// and a[i] + a[j] + a[k] is a multiple of 3.\n// \n// Example :\n// Input: n = 5\n// Output: 1\n// Explanation:\n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\n", "declaration": "\nfunc GetMaxTriples(n int) int {\n", "canonical_solution": "    A := make([]int, 0)\n    for i := 1;i <= n;i++ {\n        A = append(A, i*i-i+1)\n    }\n    ans := 0\n    for i := 0;i < n;i++ {\n        for j := i + 1;j < n;j++ {\n            for k := j + 1;k < n;k++ {\n                if (A[i]+A[j]+A[k])%3 == 0 {\n                    ans++\n                }\n            }\n        }\n    }\n    return ans\n}\n\n", "test": "func TestGetMaxTriples(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(1, GetMaxTriples(5))\n    assert.Equal(4, GetMaxTriples(6))\n    assert.Equal(36, GetMaxTriples(10))\n    assert.Equal(53361, GetMaxTriples(100))\n} \n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestGetMaxTriples(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(1, GetMaxTriples(5))\n} \n", "prompt_text": "", "prompt_explain": "You are given a positive integer n. You have to create an integer array a of length n.\nFor each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\nReturn the number of triples (a[i], a[j], a[k]) of a where i < j < k,\nand a[i] + a[j] + a[k] is a multiple of 3.\n\nExample :\nInput: n = 5\nOutput: 1\nExplanation:\na = [1, 3, 7, 13, 21]\nThe only valid triple is (1, 7, 13).\n", "func_title": "func GetMaxTriples(n int) int ", "prompt_text_chinese": "给定一个正整数n。你必须创建一个长度为n的整数数组a。对于每个i(1≤i≤n)， a[i] = i * i - i + 1。返回a的三元组(a[i]， a[j]， a[k])的个数，其中i < j < k，且a[i] + a[j] + a[k]是3的倍数。"}
{"task_id": "Go/148", "prompt": "\n// There are eight planets in our solar system: the closerst to the Sun\n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2.\n// The function should return a tuple containing all planets whose orbits are\n// located between the orbit of planet1 and the orbit of planet2, sorted by\n// the proximity to the sun.\n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names.\n// Examples\n// Bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// Bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n// Bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nfunc Bf(planet1, planet2 string) []string {\n", "import": "", "docstring": "// There are eight planets in our solar system: the closerst to the Sun\n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2.\n// The function should return a tuple containing all planets whose orbits are\n// located between the orbit of planet1 and the orbit of planet2, sorted by\n// the proximity to the sun.\n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names.\n// Examples\n// Bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// Bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n// Bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n", "declaration": "\nfunc Bf(planet1, planet2 string) []string {\n", "canonical_solution": "    planet_names := []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    pos1 := -1\n    pos2 := -1\n    for i, x := range planet_names {\n        if planet1 == x {\n            pos1 = i\n        }\n        if planet2 == x {\n            pos2 = i\n        }\n    }\n    if pos1 == -1 || pos2 == -1 || pos1 == pos2 {\n        return []string{}\n    }\n    if pos1 < pos2 {\n        return planet_names[pos1 + 1: pos2]\n    }\n    return planet_names[pos2 + 1 : pos1]\n}\n\n", "test": "func TestBf(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]string{\"Saturn\", \"Uranus\"}, Bf(\"Jupiter\", \"Neptune\"))\n    assert.Equal([]string{\"Venus\"}, Bf(\"Earth\", \"Mercury\"))\n    assert.Equal([]string{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}, Bf(\"Mercury\", \"Uranus\"))\n    assert.Equal([]string{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"}, Bf(\"Neptune\", \"Venus\"))\n    assert.Equal([]string{}, Bf(\"Earth\", \"Earth\"))\n    assert.Equal([]string{}, Bf(\"Mars\", \"Earth\"))\n    assert.Equal([]string{}, Bf(\"Jupiter\", \"Makemake\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestBf(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]string{\"Saturn\", \"Uranus\"}, Bf(\"Jupiter\", \"Neptune\"))\n    assert.Equal([]string{\"Venus\"}, Bf(\"Earth\", \"Mercury\"))\n    assert.Equal([]string{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}, Bf(\"Mercury\", \"Uranus\"))\n    assert.Equal([]string{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"}, Bf(\"Neptune\", \"Venus\"))\n    assert.Equal([]string{}, Bf(\"Earth\", \"Earth\"))\n    assert.Equal([]string{}, Bf(\"Mars\", \"Earth\"))\n    assert.Equal([]string{}, Bf(\"Jupiter\", \"Makemake\"))\n}\n", "prompt_text": "", "prompt_explain": "There are eight planets in our solar system: the closerst to the Sun\nis Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\nUranus, Neptune.\nWrite a function that takes two planet names as strings planet1 and planet2.\nThe function should return a tuple containing all planets whose orbits are\nlocated between the orbit of planet1 and the orbit of planet2, sorted by\nthe proximity to the sun.\nThe function should return an empty tuple if planet1 or planet2\nare not correct planet names.\nExamples\nBf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\nBf(\"Earth\", \"Mercury\") ==> (\"Venus\")\nBf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n", "func_title": "func Bf(planet1, planet2 string) []string ", "prompt_text_chinese": "我们的太阳系有八颗行星:离太阳最近的是水星，其次是金星，然后是地球、火星、木星、土星、天王星、海王星。编写一个函数，将两个行星名作为字符串planet1和planet2。该函数应返回一个元组，其中包含轨道位于planet1轨道和planet2轨道之间的所有行星，按距离太阳的远近排序。如果planet1或planet2不是正确的行星名称，函数将返回一个空元组。"}
{"task_id": "Go/149", "prompt": "import (\n    \"sort\"\n)\n\n// Write a function that accepts a list of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted list with a sorted order,\n// The list is always a list of strings and never an array of numbers,\n// and it may contain duplicates.\n// The order of the list should be ascending by length of each word, and you\n// should return the list sorted by that rule.\n// If two words have the same length, sort the list alphabetically.\n// The function should return a list of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n// assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfunc SortedListSum(lst []string) []string {\n", "import": "import (\n    \"sort\"\n)\n", "docstring": "// Write a function that accepts a list of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted list with a sorted order,\n// The list is always a list of strings and never an array of numbers,\n// and it may contain duplicates.\n// The order of the list should be ascending by length of each word, and you\n// should return the list sorted by that rule.\n// If two words have the same length, sort the list alphabetically.\n// The function should return a list of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n// assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n", "declaration": "\nfunc SortedListSum(lst []string) []string {\n", "canonical_solution": "    sort.SliceStable(lst, func(i, j int) bool {\n        return lst[i] < lst[j]\n    })\n    new_lst := make([]string, 0)\n    for _, i := range lst {\n        if len(i)&1==0 {\n            new_lst = append(new_lst, i)\n        }\n    }\n    sort.SliceStable(new_lst, func(i, j int) bool {\n        return len(new_lst[i]) < len(new_lst[j])\n    })\n    return new_lst\n}\n\n", "test": "func TestSortedListSum(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]string{\"aa\"}, SortedListSum([]string{\"aa\", \"a\", \"aaa\"}))\n    assert.Equal([]string{\"AI\", \"asdf\", \"school\"}, SortedListSum([]string{\"school\", \"AI\", \"asdf\", \"b\"}))\n    assert.Equal([]string{}, SortedListSum([]string{\"d\", \"b\", \"c\", \"a\"}))\n    assert.Equal([]string{\"abcd\", \"dcba\"}, SortedListSum([]string{\"d\", \"dcba\", \"abcd\", \"a\"}))\n    assert.Equal([]string{\"AI\", \"ai\", \"au\"}, SortedListSum([]string{\"AI\", \"ai\", \"au\"}))\n    assert.Equal([]string{}, SortedListSum([]string{\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"}))\n    assert.Equal([]string{\"cc\", \"dd\", \"aaaa\", \"bbbb\"}, SortedListSum([]string{\"aaaa\", \"bbbb\", \"dd\", \"cc\"}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSortedListSum(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]string{\"aa\"}, SortedListSum([]string{\"aa\", \"a\", \"aaa\"}))\n    assert.Equal([]string{\"ab\", \"cd\"}, SortedListSum([]string{\"ab\", \"a\", \"aaa\", \"cd\"}))\n}\n", "prompt_text": "", "prompt_explain": "Write a function that accepts a list of strings as a parameter,\ndeletes the strings that have odd lengths from it,\nand returns the resulted list with a sorted order,\nThe list is always a list of strings and never an array of numbers,\nand it may contain duplicates.\nThe order of the list should be ascending by length of each word, and you\nshould return the list sorted by that rule.\nIf two words have the same length, sort the list alphabetically.\nThe function should return a list of strings in sorted order.\nYou may assume that all words will have the same length.\nFor example:\nassert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\nassert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n", "func_title": "func SortedListSum(lst []string) []string ", "prompt_text_chinese": "编写一个函数，接受字符串列表作为参数，从其中删除长度为奇数的字符串，并以排序顺序返回结果列表。列表始终是字符串列表，而不是数字数组，并且可能包含重复的数字。列表的顺序应该按每个单词的长度递增，并且您应该返回按该规则排序的列表。如果两个单词的长度相同，则按字母顺序对列表进行排序。该函数应返回一个按顺序排列的字符串列表。你可以假设所有的单词都有相同的长度。"}
{"task_id": "Go/150", "prompt": "\n// A simple program which should return the value of x if n is\n// a prime number and should return the value of y otherwise.\n// \n// Examples:\n// for XOrY(7, 34, 12) == 34\n// for XOrY(15, 8, 5) == 5\nfunc XOrY(n, x, y int) int {\n", "import": "", "docstring": "// A simple program which should return the value of x if n is\n// a prime number and should return the value of y otherwise.\n// \n// Examples:\n// for XOrY(7, 34, 12) == 34\n// for XOrY(15, 8, 5) == 5\n", "declaration": "\nfunc XOrY(n, x, y int) int {\n", "canonical_solution": "    if n == 1 {\n        return y\n    }\n    for i := 2;i < n;i++ {\n        if n % i == 0 {\n            return y\n        }\n    }\n    return x\n}\n\n", "test": "func TestXOrY(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(34, XOrY(7, 34, 12))\n    assert.Equal(5, XOrY(15, 8, 5))\n    assert.Equal(33, XOrY(3, 33, 5212))\n    assert.Equal(3, XOrY(1259, 3, 52))\n    assert.Equal(-1, XOrY(7919, -1, 12))\n    assert.Equal(583, XOrY(3609, 1245, 583))\n    assert.Equal(129, XOrY(91, 56, 129))\n    assert.Equal(1234, XOrY(6, 34, 1234))\n    assert.Equal(0, XOrY(1, 2, 0))\n    assert.Equal(2, XOrY(2, 2, 0))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestXOrY(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(34, XOrY(7, 34, 12))\n    assert.Equal(5, XOrY(15, 8, 5))\n}\n", "prompt_text": "", "prompt_explain": "A simple program which should return the value of x if n is\na prime number and should return the value of y otherwise.\n\nExamples:\nfor XOrY(7, 34, 12) == 34\nfor XOrY(15, 8, 5) == 5\n", "func_title": "func XOrY(n, x, y int) int ", "prompt_text_chinese": "一个简单的程序，如果n是质数，则返回x的值，否则返回y的值。"}
{"task_id": "Go/151", "prompt": "import (\n    \"math\"\n)\n\n// Given a list of numbers, return the sum of squares of the numbers\n// in the list that are odd. Ignore numbers that are negative or not integers.\n// \n// DoubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n// DoubleTheDifference([-1, -2, 0]) == 0\n// DoubleTheDifference([9, -2]) == 81\n// DoubleTheDifference([0]) == 0\n// \n// If the input list is empty, return 0.\nfunc DoubleTheDifference(lst []float64) int {\n", "import": "import (\n    \"math\"\n)\n", "docstring": "// Given a list of numbers, return the sum of squares of the numbers\n// in the list that are odd. Ignore numbers that are negative or not integers.\n// \n// DoubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n// DoubleTheDifference([-1, -2, 0]) == 0\n// DoubleTheDifference([9, -2]) == 81\n// DoubleTheDifference([0]) == 0\n// \n// If the input list is empty, return 0.\n", "declaration": "\nfunc DoubleTheDifference(lst []float64) int {\n", "canonical_solution": "    sum := 0\n    for _, i := range lst {\n        if i > 0 && math.Mod(i, 2) != 0 && i == float64(int(i)) {\n            sum += int(math.Pow(i, 2))\n        }\n    }\n    return sum\n}\n\n", "test": "func TestDoubleTheDifference(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(0, DoubleTheDifference([]float64{}))\n    assert.Equal(25, DoubleTheDifference([]float64{5, 4}))\n    assert.Equal(0, DoubleTheDifference([]float64{0.1, 0.2, 0.3}))\n    assert.Equal(0, DoubleTheDifference([]float64{-10, -20, -30}))\n    assert.Equal(0, DoubleTheDifference([]float64{-1, -2, 8}))\n    assert.Equal(34, DoubleTheDifference([]float64{0.2, 3, 5}))\n    lst := make([]float64, 0)\n    odd_sum := 0\n    var i float64\n    for i = -99; i < 100; i+= 2 {\n        lst = append(lst, float64(i))\n        if math.Mod(i, 2) != 0 && i > 0 {\n            odd_sum +=int(math.Pow(i, 2))\n        }\n    }\n    assert.Equal(odd_sum, DoubleTheDifference(lst))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestDoubleTheDifference(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(10, DoubleTheDifference([]float64{1,3,2,0}))\n    assert.Equal(0, DoubleTheDifference([]float64{-1,-2,0}))\n    assert.Equal(81, DoubleTheDifference([]float64{9,-2}))\n    assert.Equal(0, DoubleTheDifference([]float64{0}))\n}\n", "prompt_text": "", "prompt_explain": "Given a list of numbers, return the sum of squares of the numbers\nin the list that are odd. Ignore numbers that are negative or not integers.\n\nDoubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\nDoubleTheDifference([-1, -2, 0]) == 0\nDoubleTheDifference([9, -2]) == 81\nDoubleTheDifference([0]) == 0\n\nIf the input list is empty, return 0.\n", "func_title": "func DoubleTheDifference(lst []float64) int ", "prompt_text_chinese": "给定一个数字列表，返回列表中奇数的平方和。忽略负数或非整数的数字。"}
{"task_id": "Go/152", "prompt": "import (\n    \"math\"\n)\n\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two arrays of scores and guesses of equal length, where each index shows a match.\n// Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// \n// \n// example:\n// \n// Compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n// Compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\nfunc Compare(game,guess []int) []int {\n", "import": "import (\n    \"math\"\n)\n", "docstring": "// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two arrays of scores and guesses of equal length, where each index shows a match.\n// Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// \n// \n// example:\n// \n// Compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n// Compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n", "declaration": "\nfunc Compare(game,guess []int) []int {\n", "canonical_solution": "    ans := make([]int, 0, len(game))\n    for i := range game {\n        ans = append(ans, int(math.Abs(float64(game[i]-guess[i]))))\n    }\n    return ans\n}\n\n", "test": "func TestCompare(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{0,0,0,0,3,3}, Compare([]int{1,2,3,4,5,1}, []int{1,2,3,4,2,-2}))\n    assert.Equal([]int{4,4,1,0,0,6}, Compare([]int{0,5,0,0,0,4}, []int{4,1,1,0,0,-2}))\n    assert.Equal([]int{0,0,0,0,3,3}, Compare([]int{1,2,3,4,5,1}, []int{1,2,3,4,2,-2}))\n    assert.Equal([]int{0,0,0,0,0,0}, Compare([]int{0,0,0,0,0,0}, []int{0,0,0,0,0,0}))\n    assert.Equal([]int{2,4,6}, Compare([]int{1,2,3}, []int{-1,-2,-3}))\n    assert.Equal([]int{2,0,0,1}, Compare([]int{1,2,3,5}, []int{-1,2,3,4}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestCompare(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{0,0,0,0,3,3}, Compare([]int{1,2,3,4,5,1}, []int{1,2,3,4,2,-2}))\n    assert.Equal([]int{4,4,1,0,0,6}, Compare([]int{0,5,0,0,0,4}, []int{4,1,1,0,0,-2}))\n}\n", "prompt_text": "", "prompt_explain": "I think we all remember that feeling when the result of some long-awaited\nevent is finally known. The feelings and thoughts you have at that moment are\ndefinitely worth noting down and comparing.\nYour task is to determine if a person correctly guessed the results of a number of matches.\nYou are given two arrays of scores and guesses of equal length, where each index shows a match.\nReturn an array of the same length denoting how far off each guess was. If they have guessed correctly,\nthe value is 0, and if not, the value is the absolute difference between the guess and the score.\n\n\nexample:\n\nCompare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\nCompare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n", "func_title": "func Compare(game,guess []int) []int ", "prompt_text_chinese": "我想我们都记得那种期待已久的结果终于揭晓的感觉。你在那一刻的感受和想法绝对值得记录和比较。你的任务是确定一个人是否正确地猜出了一些匹配的结果。您将得到两个长度相等的分数和猜测数组，其中每个索引显示一个匹配。返回一个相同长度的数组，表示每次猜测的距离。如果他们猜对了，这个值是0，如果没有，这个值是猜对和分数之间的绝对差。"}
{"task_id": "Go/153", "prompt": "import (\n    \"math\"\n)\n\n// You will be given the name of a class (a string) and a list of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters\n// in the extension's name, the strength is given by the fraction CAP - SM.\n// You should find the strongest extension and return a string in this\n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the list.\n// For example, if you are given \"Slices\" as the class and a list of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n// (its strength is -1).\n// Example:\n// for StrongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc StrongestExtension(class_name string, extensions []string) string {\n", "import": "import (\n    \"math\"\n)\n", "docstring": "// You will be given the name of a class (a string) and a list of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters\n// in the extension's name, the strength is given by the fraction CAP - SM.\n// You should find the strongest extension and return a string in this\n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the list.\n// For example, if you are given \"Slices\" as the class and a list of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n// (its strength is -1).\n// Example:\n// for StrongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n", "declaration": "\nfunc StrongestExtension(class_name string, extensions []string) string {\n", "canonical_solution": "    strong := extensions[0]\n    \n    my_val := math.MinInt\n    for _, s := range extensions {\n        cnt0, cnt1 := 0, 0\n        for _, c := range s {\n            switch {\n            case 'A' <= c && c <= 'Z':\n                cnt0++\n            case 'a' <= c && c <= 'z':\n                cnt1++\n            }\n        }\n        val := cnt0-cnt1\n        if val > my_val {\n            strong = s\n            my_val = val\n        }\n    }\n    return class_name + \".\" + strong\n}\n\n", "test": "func TestStrongestExtension(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"Watashi.eIGHt8OKe\", StrongestExtension(\"Watashi\", []string{\"tEN\", \"niNE\", \"eIGHt8OKe\"}))\n    assert.Equal(\"Boku123.YEs.WeCaNe\", StrongestExtension(\"Boku123\", []string{\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))\n    assert.Equal(\"__YESIMHERE.NuLl__\", StrongestExtension(\"__YESIMHERE\", []string{\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))\n    assert.Equal(\"K.TAR\", StrongestExtension(\"K\", []string{\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}))\n    assert.Equal(\"__HAHA.123\", StrongestExtension(\"__HAHA\", []string{\"Tab\", \"123\", \"781345\", \"-_-\"}))\n    assert.Equal(\"YameRore.okIWILL123\", StrongestExtension(\"YameRore\", []string{\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))\n    assert.Equal(\"finNNalLLly.WoW\", StrongestExtension(\"finNNalLLly\", []string{\"Die\", \"NowW\", \"Wow\", \"WoW\"}))\n    assert.Equal(\"_.Bb\", StrongestExtension(\"_\", []string{\"Bb\", \"91245\"}))\n    assert.Equal(\"Sp.671235\", StrongestExtension(\"Sp\", []string{\"671235\", \"Bb\"}))\n}\n    \n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestStrongestExtension(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"my_class.AA\", StrongestExtension(\"my_class\", []string{\"AA\", \"Be\", \"CC\"}))\n}\n", "prompt_text": "", "prompt_explain": "You will be given the name of a class (a string) and a list of extensions.\nThe extensions are to be used to load additional classes to the class. The\nstrength of the extension is as follows: Let CAP be the number of the uppercase\nletters in the extension's name, and let SM be the number of lowercase letters\nin the extension's name, the strength is given by the fraction CAP - SM.\nYou should find the strongest extension and return a string in this\nformat: ClassName.StrongestExtensionName.\nIf there are two or more extensions with the same strength, you should\nchoose the one that comes first in the list.\nFor example, if you are given \"Slices\" as the class and a list of the\nextensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\nreturn 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n(its strength is -1).\nExample:\nfor StrongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n", "func_title": "func StrongestExtension(class_name string, extensions []string) string ", "prompt_text_chinese": "您将得到一个类的名称(一个字符串)和一个扩展列表。扩展将用于将其他类加载到类中。扩展的强度如下:设CAP为扩展名中大写字母的个数，SM为扩展名中小写字母的个数，强度由分数CAP - SM给出。您应该找到最强的扩展并返回如下格式的字符串:classname . stronggestextensionname。如果有两个或更多具有相同强度的扩展，您应该选择列表中最先出现的扩展。"}
{"task_id": "Go/154", "prompt": "\n// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// CycpatternCheck(\"abcd\",\"abd\") => false\n// CycpatternCheck(\"hello\",\"ell\") => true\n// CycpatternCheck(\"whassup\",\"psus\") => false\n// CycpatternCheck(\"abab\",\"baa\") => true\n// CycpatternCheck(\"efef\",\"eeff\") => false\n// CycpatternCheck(\"himenss\",\"simen\") => true\nfunc CycpatternCheck(a , b string) bool {\n", "import": "", "docstring": "// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// CycpatternCheck(\"abcd\",\"abd\") => false\n// CycpatternCheck(\"hello\",\"ell\") => true\n// CycpatternCheck(\"whassup\",\"psus\") => false\n// CycpatternCheck(\"abab\",\"baa\") => true\n// CycpatternCheck(\"efef\",\"eeff\") => false\n// CycpatternCheck(\"himenss\",\"simen\") => true\n", "declaration": "\nfunc CycpatternCheck(a , b string) bool {\n", "canonical_solution": "    l := len(b)\n    pat := b + b\n    for i := 0;i < len(a) - l + 1; i++ {\n        for j := 0;j<l + 1;j++ {\n            if a[i:i+l] == pat[j:j+l] {\n                return true\n            }\n        }\n    }\n    return false\n}\n\n", "test": "func TestCycpatternCheck(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(false, CycpatternCheck(\"xyzw\", \"xyw\"))\n    assert.Equal(true, CycpatternCheck(\"yello\", \"ell\"))\n    assert.Equal(false, CycpatternCheck(\"whattup\", \"ptut\"))\n    assert.Equal(true, CycpatternCheck(\"efef\", \"fee\"))\n    assert.Equal(false, CycpatternCheck(\"abab\", \"aabb\"))\n    assert.Equal(true, CycpatternCheck(\"winemtt\", \"tinem\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestCycpatternCheck(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(false, CycpatternCheck(\"abcd\", \"abd\"))\n    assert.Equal(true, CycpatternCheck(\"hello\", \"ell\"))\n    assert.Equal(false, CycpatternCheck(\"whasup\", \"psus\"))\n    assert.Equal(true, CycpatternCheck(\"abab\", \"baa\"))\n    assert.Equal(false, CycpatternCheck(\"efef\", \"eeff\"))\n    assert.Equal(true, CycpatternCheck(\"himenss\", \"simen\"))\n}\n", "prompt_text": "", "prompt_explain": "You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\nCycpatternCheck(\"abcd\",\"abd\") => false\nCycpatternCheck(\"hello\",\"ell\") => true\nCycpatternCheck(\"whassup\",\"psus\") => false\nCycpatternCheck(\"abab\",\"baa\") => true\nCycpatternCheck(\"efef\",\"eeff\") => false\nCycpatternCheck(\"himenss\",\"simen\") => true\n", "func_title": "func CycpatternCheck(a , b string) bool ", "prompt_text_chinese": "给你两个单词。如果第二个单词或它的任何旋转是第一个单词的子字符串，则需要返回true"}
{"task_id": "Go/155", "prompt": "import (\n    \"strconv\"\n)\n\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// \n// Example:\n// EvenOddCount(-12) ==> (1, 1)\n// EvenOddCount(123) ==> (1, 2)\nfunc EvenOddCount(num int) [2]int {\n", "import": "import (\n    \"strconv\"\n)\n", "docstring": "// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// \n// Example:\n// EvenOddCount(-12) ==> (1, 1)\n// EvenOddCount(123) ==> (1, 2)\n", "declaration": "\nfunc EvenOddCount(num int) [2]int {\n", "canonical_solution": "    even_count := 0\n    odd_count := 0\n    if num < 0 {\n        num = -num\n    }\n    for _, r := range strconv.Itoa(num) {\n        if r&1==0 {\n            even_count++\n        } else {\n            odd_count++\n        }\n    }\n    return [2]int{even_count, odd_count}\n}\n\n", "test": "func TestEvenOddCount(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([2]int{0, 1}, EvenOddCount(7))\n    assert.Equal([2]int{1, 1}, EvenOddCount(-78))\n    assert.Equal([2]int{2, 2}, EvenOddCount(3452))\n    assert.Equal([2]int{3, 3}, EvenOddCount(346211))\n    assert.Equal([2]int{3, 3}, EvenOddCount(-345821))\n    assert.Equal([2]int{1, 0}, EvenOddCount(-2))\n    assert.Equal([2]int{2, 3}, EvenOddCount(-45347))\n    assert.Equal([2]int{1, 0}, EvenOddCount(0))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestEvenOddCount(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([2]int{1, 1}, EvenOddCount(-12))\n    assert.Equal([2]int{1, 2}, EvenOddCount(123))\n}\n", "prompt_text": "", "prompt_explain": "Given an integer. return a tuple that has the number of even and odd digits respectively.\n\nExample:\nEvenOddCount(-12) ==> (1, 1)\nEvenOddCount(123) ==> (1, 2)\n", "func_title": "func EvenOddCount(num int) [2]int ", "prompt_text_chinese": "给定一个整数。返回一个元组，该元组分别包含偶数和奇数位数。"}
{"task_id": "Go/156", "prompt": "import (\n    \"strings\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// \n// Examples:\n// >>> IntToMiniRoman(19) == 'xix'\n// >>> IntToMiniRoman(152) == 'clii'\n// >>> IntToMiniRoman(426) == 'cdxxvi'\nfunc IntToMiniRoman(number int) string {\n", "import": "import (\n    \"strings\"\n)\n", "docstring": "// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// \n// Examples:\n// >>> IntToMiniRoman(19) == 'xix'\n// >>> IntToMiniRoman(152) == 'clii'\n// >>> IntToMiniRoman(426) == 'cdxxvi'\n", "declaration": "\nfunc IntToMiniRoman(number int) string {\n", "canonical_solution": "    num := []int{1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000}\n    sym := []string{\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"}\n    i := 12\n    res := \"\"\n    for number != 0 {\n        div := number / num[i] \n        number %= num[i] \n        for div != 0 {\n            res += sym[i] \n            div--\n        }\n        i--\n    }\n    return strings.ToLower(res)\n}\n\n", "test": "func TestIntToMiniRoman(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"xix\", IntToMiniRoman(19))\n    assert.Equal(\"clii\", IntToMiniRoman(152))\n    assert.Equal(\"ccli\", IntToMiniRoman(251))\n    assert.Equal(\"cdxxvi\", IntToMiniRoman(426))\n    assert.Equal(\"d\", IntToMiniRoman(500))\n    assert.Equal(\"i\", IntToMiniRoman(1))\n    assert.Equal(\"iv\", IntToMiniRoman(4))\n    assert.Equal(\"xliii\", IntToMiniRoman(43))\n    assert.Equal(\"xc\", IntToMiniRoman(90))\n    assert.Equal(\"xciv\", IntToMiniRoman(94))\n    assert.Equal(\"dxxxii\", IntToMiniRoman(532))\n    assert.Equal(\"cm\", IntToMiniRoman(900))\n    assert.Equal(\"cmxciv\", IntToMiniRoman(994))\n    assert.Equal(\"m\", IntToMiniRoman(1000))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestIntToMiniRoman(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"xix\", IntToMiniRoman(19))\n    assert.Equal(\"clii\", IntToMiniRoman(152))\n    assert.Equal(\"cdxxvi\", IntToMiniRoman(426))\n}\n", "prompt_text": "Given a positive integer, obtain its roman numeral equivalent as a string, and return it in lowercase. Restrictions: 1 <= num <= 1000  Examples:", "prompt_explain": "Given a positive integer, obtain its roman numeral equivalent as a string,\nand return it in lowercase.\nRestrictions: 1 <= num <= 1000\n\nExamples:\n>>> IntToMiniRoman(19) == 'xix'\n>>> IntToMiniRoman(152) == 'clii'\n>>> IntToMiniRoman(426) == 'cdxxvi'\n", "func_title": "func IntToMiniRoman(number int) string ", "prompt_text_chinese": "给定一个正整数，将其等效的罗马数字作为字符串，并以小写形式返回。"}
{"task_id": "Go/157", "prompt": "\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or\n// 90 degree.\n// Example:\n// RightAngleTriangle(3, 4, 5) == true\n// RightAngleTriangle(1, 2, 3) == false\nfunc RightAngleTriangle(a, b, c int) bool {\n", "import": "", "docstring": "// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or\n// 90 degree.\n// Example:\n// RightAngleTriangle(3, 4, 5) == true\n// RightAngleTriangle(1, 2, 3) == false\n", "declaration": "\nfunc RightAngleTriangle(a, b, c int) bool {\n", "canonical_solution": "    return a*a == b*b + c*c || b*b == a*a + c*c || c*c == a*a + b*b\n}\n\n", "test": "func TestRightAngleTriangle(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, RightAngleTriangle(3, 4, 5))\n    assert.Equal(false, RightAngleTriangle(1, 2, 3))\n    assert.Equal(true, RightAngleTriangle(10, 6, 8))\n    assert.Equal(false, RightAngleTriangle(2, 2, 2))\n    assert.Equal(true, RightAngleTriangle(7, 24, 25))\n    assert.Equal(false, RightAngleTriangle(10, 5, 7))\n    assert.Equal(true, RightAngleTriangle(5, 12, 13))\n    assert.Equal(true, RightAngleTriangle(15, 8, 17))\n    assert.Equal(true, RightAngleTriangle(48, 55, 73))\n    assert.Equal(false, RightAngleTriangle(1, 1, 1))\n    assert.Equal(false, RightAngleTriangle(2, 2, 10))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestRightAngleTriangle(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, RightAngleTriangle(3, 4, 5))\n    assert.Equal(false, RightAngleTriangle(1, 2, 3))\n}\n", "prompt_text": "", "prompt_explain": "Given the lengths of the three sides of a triangle. Return true if the three\nsides form a right-angled triangle, false otherwise.\nA right-angled triangle is a triangle in which one angle is right angle or\n90 degree.\nExample:\nRightAngleTriangle(3, 4, 5) == true\nRightAngleTriangle(1, 2, 3) == false\n", "func_title": "func RightAngleTriangle(a, b, c int) bool ", "prompt_text_chinese": "已知三角形三条边的长度。如果三条边组成直角三角形则返回true，否则返回false。直角三角形是其中一个角是直角或90度的三角形。"}
{"task_id": "Go/158", "prompt": "import (\n    \"sort\"\n)\n\n// Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// \n// FindMax([\"name\", \"of\", \"string\"]) == \"string\"\n// FindMax([\"name\", \"enam\", \"game\"]) == \"enam\"\n// FindMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nfunc FindMax(words []string) string {\n", "import": "import (\n    \"sort\"\n)\n", "docstring": "// Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// \n// FindMax([\"name\", \"of\", \"string\"]) == \"string\"\n// FindMax([\"name\", \"enam\", \"game\"]) == \"enam\"\n// FindMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n", "declaration": "\nfunc FindMax(words []string) string {\n", "canonical_solution": "    key := func (word string) (int, string) {\n        set := make(map[rune]struct{})\n        for _, r := range word {\n            set[r] = struct{}{}\n        }\n        return -len(set), word\n    }\n    sort.SliceStable(words, func(i, j int) bool {\n        ia, ib := key(words[i])\n        ja, jb := key(words[j])\n        if ia == ja {\n            return ib < jb\n        }\n        return ia < ja\n    })\n    return words[0]\n}\n\n", "test": "func TestFindMax(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"string\", FindMax([]string{\"name\", \"of\", \"string\"}))\n    assert.Equal(\"enam\", FindMax([]string{\"name\", \"enam\", \"game\"}))\n    assert.Equal(\"aaaaaaa\", FindMax([]string{\"aaaaaaa\", \"bb\", \"cc\"}))\n    assert.Equal(\"abc\", FindMax([]string{\"abc\", \"cba\"}))\n    assert.Equal(\"footbott\", FindMax([]string{\"play\", \"this\", \"game\", \"of\", \"footbott\"}))\n    assert.Equal(\"gonna\", FindMax([]string{\"we\", \"are\", \"gonna\", \"rock\"}))\n    assert.Equal(\"nation\", FindMax([]string{\"we\", \"are\", \"a\", \"mad\", \"nation\"}))\n    assert.Equal(\"this\", FindMax([]string{\"this\", \"is\", \"a\", \"prrk\"}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestFindMax(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"string\", FindMax([]string{\"name\", \"of\", \"string\"}))\n    assert.Equal(\"enam\", FindMax([]string{\"name\", \"enam\", \"game\"}))\n    assert.Equal(\"aaaaaaa\", FindMax([]string{\"aaaaaaa\", \"bb\", \"cc\"}))\n}\n", "prompt_text": "", "prompt_explain": "Write a function that accepts a list of strings.\nThe list contains different words. Return the word with maximum number\nof unique characters. If multiple strings have maximum number of unique\ncharacters, return the one which comes first in lexicographical order.\n\nFindMax([\"name\", \"of\", \"string\"]) == \"string\"\nFindMax([\"name\", \"enam\", \"game\"]) == \"enam\"\nFindMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n", "func_title": "func FindMax(words []string) string ", "prompt_text_chinese": "编写一个接受字符串列表的函数。这个列表包含了不同的单词。返回具有最大惟一字符数的单词。如果多个字符串具有最大惟一字符数，则返回按字典顺序排在前面的字符串。"}
{"task_id": "Go/159", "prompt": "\n// You're a hungry rabbit, and you already have Eaten a certain number of carrots,\n// but now you need to Eat more carrots to complete the day's meals.\n// you should return an array of [ total number of Eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will Eat all remaining carrots, but will still be hungry.\n// \n// Example:\n// * Eat(5, 6, 10) -> [11, 4]\n// * Eat(4, 8, 9) -> [12, 1]\n// * Eat(1, 10, 10) -> [11, 0]\n// * Eat(2, 11, 5) -> [7, 0]\n// \n// Variables:\n// @number : integer\n// the number of carrots that you have Eaten.\n// @need : integer\n// the number of carrots that you need to Eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// \n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// \n// Have fun :)\nfunc Eat(number, need, remaining int) []int {\n", "import": "", "docstring": "// You're a hungry rabbit, and you already have Eaten a certain number of carrots,\n// but now you need to Eat more carrots to complete the day's meals.\n// you should return an array of [ total number of Eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will Eat all remaining carrots, but will still be hungry.\n// \n// Example:\n// * Eat(5, 6, 10) -> [11, 4]\n// * Eat(4, 8, 9) -> [12, 1]\n// * Eat(1, 10, 10) -> [11, 0]\n// * Eat(2, 11, 5) -> [7, 0]\n// \n// Variables:\n// @number : integer\n// the number of carrots that you have Eaten.\n// @need : integer\n// the number of carrots that you need to Eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// \n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// \n// Have fun :)\n", "declaration": "\nfunc Eat(number, need, remaining int) []int {\n", "canonical_solution": "    if(need <= remaining) {\n        return []int{ number + need , remaining-need }\n    }\n    return []int{ number + remaining , 0}\n}\n\n", "test": "func TestEat(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{11, 4}, Eat(5, 6, 10))\n    assert.Equal([]int{12, 1}, Eat(4, 8, 9))\n    assert.Equal([]int{11, 0}, Eat(1, 10, 10))\n    assert.Equal([]int{7, 0}, Eat(2, 11, 5))\n    assert.Equal([]int{9, 2}, Eat(4, 5, 7))\n    assert.Equal([]int{5, 0}, Eat(4, 5, 1))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestEat(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{11, 4}, Eat(5, 6, 10))\n    assert.Equal([]int{12, 1}, Eat(4, 8, 9))\n    assert.Equal([]int{11, 0}, Eat(1, 10, 10))\n    assert.Equal([]int{7, 0}, Eat(2, 11, 5))\n}\n", "prompt_text": "", "prompt_explain": "You're a hungry rabbit, and you already have Eaten a certain number of carrots,\nbut now you need to Eat more carrots to complete the day's meals.\nyou should return an array of [ total number of Eaten carrots after your meals,\nthe number of carrots left after your meals ]\nif there are not enough remaining carrots, you will Eat all remaining carrots, but will still be hungry.\n\nExample:\n* Eat(5, 6, 10) -> [11, 4]\n* Eat(4, 8, 9) -> [12, 1]\n* Eat(1, 10, 10) -> [11, 0]\n* Eat(2, 11, 5) -> [7, 0]\n\nVariables:\n@number : integer\nthe number of carrots that you have Eaten.\n@need : integer\nthe number of carrots that you need to Eat.\n@remaining : integer\nthe number of remaining carrots thet exist in stock\n\nConstrain:\n* 0 <= number <= 1000\n* 0 <= need <= 1000\n* 0 <= remaining <= 1000\n\nHave fun :)\n", "func_title": "func Eat(number, need, remaining int) []int ", "prompt_text_chinese": "你是一只饥饿的兔子，你已经吃了一定数量的胡萝卜，但现在你需要吃更多的胡萝卜来完成一天的三餐。你应该返回一个数组[餐后吃的胡萝卜总数，餐后剩下的胡萝卜数量]如果没有足够的剩余胡萝卜，你将吃掉所有剩余的胡萝卜，但仍然会感到饥饿。"}
{"task_id": "Go/160", "prompt": "import (\n    \"math\"\n)\n\n// Given two lists operator, and operand. The first list has basic algebra operations, and\n// the second list is a list of integers. Use the two given lists to build the algebric\n// expression and return the evaluation of this expression.\n// \n// The basic algebra operations:\n// Addition ( + )\n// Subtraction ( - )\n// Multiplication ( * )\n// Floor division ( // )\n// Exponentiation ( ** )\n// \n// Example:\n// operator['+', '*', '-']\n// array = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// \n// Note:\n// The length of operator list is equal to the length of operand list minus one.\n// Operand is a list of of non-negative integers.\n// Operator list has at least one operator, and operand list has at least two operands.\nfunc DoAlgebra(operator []string, operand []int) int {\n", "import": "import (\n    \"math\"\n)\n", "docstring": "// Given two lists operator, and operand. The first list has basic algebra operations, and\n// the second list is a list of integers. Use the two given lists to build the algebric\n// expression and return the evaluation of this expression.\n// \n// The basic algebra operations:\n// Addition ( + )\n// Subtraction ( - )\n// Multiplication ( * )\n// Floor division ( // )\n// Exponentiation ( ** )\n// \n// Example:\n// operator['+', '*', '-']\n// array = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// \n// Note:\n// The length of operator list is equal to the length of operand list minus one.\n// Operand is a list of of non-negative integers.\n// Operator list has at least one operator, and operand list has at least two operands.\n", "declaration": "\nfunc DoAlgebra(operator []string, operand []int) int {\n", "canonical_solution": "    higher := func(a, b string) bool {\n        if b == \"*\" || b == \"//\" || b == \"**\" {\n            return false\n        }\n        if a == \"*\" || a == \"//\" || a == \"**\" {\n            return true\n        }\n        return false\n    }\n    for len(operand) > 1 {\n        pos := 0\n        sign := operator[0]\n        for i, str := range operator {\n            if higher(str, sign) {\n                sign = str\n                pos = i\n            }\n        }\n        switch sign {\n        case \"+\":\n            operand[pos] += operand[pos+1]\n        case \"-\":\n            operand[pos] -= operand[pos+1]\n        case \"*\":\n            operand[pos] *= operand[pos+1]\n        case \"//\":\n            operand[pos] /= operand[pos+1]\n        case \"**\":\n            operand[pos] = int(math.Pow(float64(operand[pos]), float64(operand[pos+1])))\n        }\n        operator = append(operator[:pos], operator[pos+1:]...)\n        operand = append(operand[:pos+1], operand[pos+2:]...)\n    }\n    return operand [0]\n}\n\n", "test": "func TestDoAlgebra(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(37, DoAlgebra([]string{\"**\", \"*\", \"+\"}, []int{2, 3, 4, 5}))\n    assert.Equal(9, DoAlgebra([]string{\"+\", \"*\", \"-\"}, []int{2, 3, 4, 5}))\n    assert.Equal(8, DoAlgebra([]string{\"//\", \"*\"}, []int{7, 3, 4}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "", "prompt_text": "", "prompt_explain": "Given two lists operator, and operand. The first list has basic algebra operations, and\nthe second list is a list of integers. Use the two given lists to build the algebric\nexpression and return the evaluation of this expression.\n\nThe basic algebra operations:\nAddition ( + )\nSubtraction ( - )\nMultiplication ( * )\nFloor division ( // )\nExponentiation ( ** )\n\nExample:\noperator['+', '*', '-']\narray = [2, 3, 4, 5]\nresult = 2 + 3 * 4 - 5\n=> result = 9\n\nNote:\nThe length of operator list is equal to the length of operand list minus one.\nOperand is a list of of non-negative integers.\nOperator list has at least one operator, and operand list has at least two operands.\n", "func_title": "func DoAlgebra(operator []string, operand []int) int ", "prompt_text_chinese": "给定两个列表操作符和操作数。第一个列表有基本的代数运算，第二个列表是一个整数列表。使用两个给定的列表构建代数表达式并返回该表达式的求值。"}
{"task_id": "Go/161", "prompt": "\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa,\n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// Solve(\"1234\") = \"4321\"\n// Solve(\"ab\") = \"AB\"\n// Solve(\"#a@C\") = \"#A@c\"\nfunc Solve(s string) string {\n", "import": "", "docstring": "// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa,\n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// Solve(\"1234\") = \"4321\"\n// Solve(\"ab\") = \"AB\"\n// Solve(\"#a@C\") = \"#A@c\"\n", "declaration": "\nfunc Solve(s string) string {\n", "canonical_solution": "    flg := 0\n    new_str := []rune(s)\n    for i, r := range new_str {\n        if ('a' <= r && r <= 'z') || ('A' <= r && r <= 'Z') {\n            if 'a' <= r && r <= 'z' {\n                new_str[i] = r - 'a' + 'A'\n            } else {\n                new_str[i] = r - 'A' + 'a'\n            }\n            flg = 1\n        }\n    }\n    if flg == 0 {\n        for i := 0;i < len(new_str)>>1;i++ {\n            new_str[i], new_str[len(new_str)-i-1] = new_str[len(new_str)-i-1], new_str[i]\n        }\n    }\n    return string(new_str)\n}\n\n", "test": "func TestSolve(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"aSdF\", Solve(\"AsDf\"))\n    assert.Equal(\"4321\", Solve(\"1234\"))\n    assert.Equal(\"AB\", Solve(\"ab\"))\n    assert.Equal(\"#A@c\", Solve(\"#a@C\"))\n    assert.Equal(\"#aSDFw^45\", Solve(\"#AsdfW^45\"))\n    assert.Equal(\"2@6#\", Solve(\"#6@2\"))\n    assert.Equal(\"#$A^d\", Solve(\"#$a^D\"))\n    assert.Equal(\"#CCC\", Solve(\"#ccc\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSolve(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"4321\", Solve(\"1234\"))\n    assert.Equal(\"AB\", Solve(\"ab\"))\n    assert.Equal(\"#A@c\", Solve(\"#a@C\"))\n}\n", "prompt_text": "", "prompt_explain": "You are given a string s.\nif s[i] is a letter, reverse its case from lower to upper or vise versa,\notherwise keep it as it is.\nIf the string contains no letters, reverse the string.\nThe function should return the resulted string.\nExamples\nSolve(\"1234\") = \"4321\"\nSolve(\"ab\") = \"AB\"\nSolve(\"#a@C\") = \"#A@c\"\n", "func_title": "func Solve(s string) string ", "prompt_text_chinese": "给你一个字符串s，如果s[i]是一个字母，将它的大小写从下到上颠倒，反之亦然，否则保持它的原样。如果字符串不包含字母，则反转字符串。函数应该返回结果字符串。"}
{"task_id": "Go/162", "prompt": "import (\n    \"crypto/md5\"\n    \"fmt\"\n)\n\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return nil.\n// \n// >>> StringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\nfunc StringToMd5(text string) interface{} {\n", "import": "import (\n    \"crypto/md5\"\n    \"fmt\"\n)\n", "docstring": "// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return nil.\n// \n// >>> StringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n", "declaration": "\nfunc StringToMd5(text string) interface{} {\n", "canonical_solution": "    if text == \"\" {\n        return nil\n    }\n    return fmt.Sprintf(\"%x\", md5.Sum([]byte(text)))\n}\n\n", "test": "func TestStringToMd5(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"3e25960a79dbc69b674cd4ec67a72c62\", StringToMd5(\"Hello world\"))\n    assert.Equal(nil, StringToMd5(\"\"))\n    assert.Equal(\"0ef78513b0cb8cef12743f5aeb35f888\", StringToMd5(\"A B C\"))\n    assert.Equal(\"5f4dcc3b5aa765d61d8327deb882cf99\", StringToMd5(\"password\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"crypto/md5\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestStringToMd5(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(\"3e25960a79dbc69b674cd4ec67a72c62\", StringToMd5(\"Hello world\"))\n}\n", "prompt_text": "Given a string 'text', return its md5 hash equivalent string. If 'text' is an empty string, return nil. ", "prompt_explain": "Given a string 'text', return its md5 hash equivalent string.\nIf 'text' is an empty string, return nil.\n\n>>> StringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n", "func_title": "func StringToMd5(text string) interface{} ", "prompt_text_chinese": "给定字符串'text'，返回其md5哈希等效字符串。如果'text'是空字符串，返回nil。"}
{"task_id": "Go/163", "prompt": "\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// \n// For example:\n// GenerateIntegers(2, 8) => [2, 4, 6, 8]\n// GenerateIntegers(8, 2) => [2, 4, 6, 8]\n// GenerateIntegers(10, 14) => []\nfunc GenerateIntegers(a, b int) []int {\n", "import": "", "docstring": "// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// \n// For example:\n// GenerateIntegers(2, 8) => [2, 4, 6, 8]\n// GenerateIntegers(8, 2) => [2, 4, 6, 8]\n// GenerateIntegers(10, 14) => []\n", "declaration": "\nfunc GenerateIntegers(a, b int) []int {\n", "canonical_solution": "    min := func (a, b int) int {\n        if a > b {\n            return b\n        }\n        return a\n    }\n    max := func (a, b int) int {\n        if a > b {\n            return a\n        }\n        return b\n    }\n    lower := max(2, min(a, b))\n    upper := min(8, max(a, b))\n    ans := make([]int, 0)\n    for i := lower;i <= upper;i++ {\n        if i&1==0 {\n            ans = append(ans, i)\n        }\n    }\n    return ans\n}\n\n", "test": "func TestGenerateIntegers(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{2, 4, 6, 8}, GenerateIntegers(2, 10))\n    assert.Equal([]int{2, 4, 6, 8}, GenerateIntegers(10, 2))\n    assert.Equal([]int{2, 4, 6, 8}, GenerateIntegers(132, 2))\n    assert.Equal([]int{}, GenerateIntegers(17, 89))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestGenerateIntegers(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{2, 4, 6, 8}, GenerateIntegers(2, 8))\n    assert.Equal([]int{2, 4, 6, 8}, GenerateIntegers(8, 2))\n    assert.Equal([]int{}, GenerateIntegers(10, 14))\n}\n", "prompt_text": "", "prompt_explain": "Given two positive integers a and b, return the even digits between a\nand b, in ascending order.\n\nFor example:\nGenerateIntegers(2, 8) => [2, 4, 6, 8]\nGenerateIntegers(8, 2) => [2, 4, 6, 8]\nGenerateIntegers(10, 14) => []\n", "func_title": "func GenerateIntegers(a, b int) []int ", "prompt_text_chinese": "给定两个正整数a和b，按升序返回a和b之间的偶数。"}