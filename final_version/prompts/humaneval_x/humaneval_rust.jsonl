{"task_id": "Rust/0", "prompt": "/*\n Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n", "canonical_solution": "\n    for i in 0..numbers.len(){\n        for j in 1..numbers.len(){\n\n            if i != j {\n                let distance:f32 = numbers[i] - numbers[j];\n\n            if distance.abs() < threshold{\n                return true;\n            }\n\n            }\n            \n        }\n    }\n\n    return false;\n\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_has_close_elements() {\n        assert_eq!(has_close_elements(vec![11.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n        assert_eq!(has_close_elements(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n        assert_eq!(has_close_elements(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n        assert_eq!(has_close_elements(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n        assert_eq!(has_close_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n        assert_eq!(has_close_elements(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n        assert_eq!(has_close_elements(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Check if in given list of numbers, are any two numbers closer to each other than given threshold.", "prompt_explain": "Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n        assert_eq!(has_close_elements(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false)", "func_title": "fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n", "prompt_text_chinese": "检查在给定的数字列表中，是否有任何两个数字比给定的阈值更接近。"}
{"task_id": "Rust/1", "prompt": "/*\n Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn separate_paren_groups(paren_string: String) -> Vec<String>{\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn separate_paren_groups(paren_string: String) -> Vec<String>{\n", "canonical_solution": "\n    let mut result:Vec<String> = vec![];\n    let mut current_string:String = String::new();\n    let mut current_depth:u32 = 0;\n\n    for c in paren_string.chars(){\n        if c == '('{\n            current_depth += 1;\n            current_string.push(c);\n        }\n        else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0{\n                result.push(current_string.clone());\n                current_string.clear()\n            }\n            \n        }\n\n\n    }\n    return result;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n#[test]\n    fn test_separate_paren_groups() {\n        assert_eq!(\n            separate_paren_groups(String::from(\"(()()) ((())) () ((())()())\")),\n            vec![\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n        );\n        assert_eq!(\n            separate_paren_groups(String::from(\"() (()) ((())) (((())))\")),\n            vec![\"()\", \"(())\", \"((()))\", \"(((())))\"]\n        );\n        assert_eq!(\n            separate_paren_groups(String::from(\"(()(())((())))\")),\n            vec![\"(()(())((())))\"]\n        );\n        assert_eq!(\n            separate_paren_groups(String::from(\"( ) (( )) (( )( ))\")),\n            vec![\"()\", \"(())\", \"(()())\"]\n        );\n    }\n\n}\n", "example_test": "None", "prompt_text": "Input to this function is a string containing multiple groups of nested parentheses. Your goal is to separate those group into separate strings and return the list of those. Separate groups are balanced (each open brace is properly closed) and not nested within each other Ignore any spaces in the input string.", "prompt_explain": "Input to this function is a string containing multiple groups of nested parentheses. Your goal is to separate those group into separate strings and return the list of those. Separate groups are balanced (each open brace is properly closed) and not nested within each other Ignore any spaces in the input string.\n        assert_eq!(\n            separate_paren_groups(String::from(\"( ) (( )) (( )( ))\")),\n            vec![\"()\", \"(())\", \"(()())\"]\n        )", "func_title": "fn separate_paren_groups(paren_string: String) -> Vec<String>{\n", "prompt_text_chinese": "这个函数的输入是一个包含多组嵌套括号的字符串。您的目标是将这些组分离为单独的字符串，并返回这些字符串的列表。独立的组是平衡的(每个开大括号都是正确关闭的)，并且彼此之间不嵌套。"}
{"task_id": "Rust/2", "prompt": "/*\n Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn truncate_number(number: &f32) -> f32{\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn truncate_number(number: &f32) -> f32{\n", "canonical_solution": "\n    return number % 1.0;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n#[test]\n    fn test_truncate_number() {\n        assert_eq!(truncate_number(&3.5), 0.5);\n        let t1: f32 = 1.33 - 0.33;\n        assert!(truncate_number(&t1) < 0.000001);\n        let t2: f32 = 123.456 - 0.456;\n        assert!(truncate_number(&t2) < 0.000001);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Given a positive floating point number, it can be decomposed into and integer part (largest integer smaller than given number) and decimals (leftover part always smaller than 1).  Return the decimal part of the number.", "prompt_explain": "Given a positive floating point number, it can be decomposed into and integer part (largest integer smaller than given number) and decimals (leftover part always smaller than 1).  Return the decimal part of the number.\n        assert!(truncate_number(&t2) < 0.000001)", "func_title": "fn truncate_number(number: &f32) -> f32{\n", "prompt_text_chinese": "给定一个正浮点数，它可以分解为整数部分(小于给定数字的最大整数)和小数部分(剩余部分总是小于1)，返回该数字的小数部分。"}
{"task_id": "Rust/3", "prompt": "/*\n You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn below_zero(operations:Vec<i32>) -> bool{\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn below_zero(operations:Vec<i32>) -> bool{\n", "canonical_solution": "\n\nlet mut balance:i32 = 0;\nfor op in operations {\n    balance = balance + op;\n    if balance < 0 {\n        return true;\n        }\n    }\n    return false;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n#[test]\n    fn test_below_zero() {\n        assert_eq!(below_zero(vec![]), false);\n        assert_eq!(below_zero(vec![1, 2, -3, 1, 2, -3]), false);\n        assert_eq!(below_zero(vec![1, 2, -4, 5, 6]), true);\n        assert_eq!(below_zero(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n        assert_eq!(below_zero(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n        assert_eq!(below_zero(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n    }\n\n}\n", "example_test": "None", "prompt_text": "You're given a list of deposit and withdrawal operations on a bank account that starts with zero balance. Your task is to detect if at any point the balance of account fallls below zero, and at that point function should return True. Otherwise it should return False.", "prompt_explain": "You're given a list of deposit and withdrawal operations on a bank account that starts with zero balance. Your task is to detect if at any point the balance of account fallls below zero, and at that point function should return True. Otherwise it should return False.\n        assert_eq!(below_zero(vec![1, -2, 2, -2, 5, -5, 4, -4]), true)", "func_title": "fn below_zero(operations:Vec<i32>) -> bool{\n", "prompt_text_chinese": "给你一个银行账户的存款和取款操作列表，余额为零。您的任务是检测帐户余额是否在任何时刻低于零，并且在该点函数应该返回True。否则返回False。"}
{"task_id": "Rust/4", "prompt": "/*\n For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n", "canonical_solution": "\n    let mean:f32 = numbers.iter().fold(0.0,|acc:f32, x:&f32| acc + x) / numbers.len() as f32;\n    return numbers.iter().map(|x:&f32| (x - mean).abs()).sum::<f32>() / numbers.len() as f32;\n}\n\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n  #[test]\n    fn test_mean_absolute_deviation() {\n        assert!(mean_absolute_deviation(vec![1.0, 2.0, 3.0]) - 2.0 / 3.0 < 0.000001);\n        assert!(mean_absolute_deviation(vec![1.0, 2.0, 3.0, 4.0]) - 1.0 < 0.000001);\n        assert!(mean_absolute_deviation(vec![1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0 < 0.000001);\n    }\n\n}\n", "example_test": "None", "prompt_text": "For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset. Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case): MAD = average | x - x_mean |", "prompt_explain": "For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset. Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case): MAD = average | x - x_mean |\n        assert!(mean_absolute_deviation(vec![1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0 < 0.000001)", "func_title": "fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n", "prompt_text_chinese": "对于给定的输入数字列表，计算该数据集平均值附近的平均绝对偏差。平均绝对偏差是每个元素与中心点之间的平均绝对差值(在本例中为平均值):MAD = average | x - x_mean |"}
{"task_id": "Rust/5", "prompt": "/*\n Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn intersperse(numbers:Vec<u32>, delimeter: u32) -> Vec<u32>{\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn intersperse(numbers:Vec<u32>, delimeter: u32) -> Vec<u32>{\n", "canonical_solution": "\n    let mut res:Vec<u32> = vec![];\n    numbers.iter().for_each(|item:&u32| {res.push(*item); res.push(delimeter);});\n    res.pop();\n    return res;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n #[test]\n    fn test_intersperse() {\n        assert!(intersperse(vec![], 7) == vec![]);\n        assert!(intersperse(vec![5, 6, 3, 2], 8) == vec![5, 8, 6, 8, 3, 8, 2]);\n        assert!(intersperse(vec![2, 2, 2], 2) == vec![2, 2, 2, 2, 2]);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Insert a number 'delimeter' between every two consecutive elements of input list `numbers'", "prompt_explain": "Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n        assert!(intersperse(vec![2, 2, 2], 2) == vec![2, 2, 2, 2, 2])", "func_title": "fn intersperse(numbers:Vec<u32>, delimeter: u32) -> Vec<u32>{\n", "prompt_text_chinese": "在输入列表“numbers”的每两个连续元素之间插入一个数字“delimeter”"}
{"task_id": "Rust/6", "prompt": "/*\n Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn parse_nested_parens(paren_string:String) -> Vec<i32>{\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn parse_nested_parens(paren_string:String) -> Vec<i32>{\n", "canonical_solution": "\n    let mut result:Vec<i32> = vec![];\n    let mut depth:i32 = 0;\n    let mut max_depth:i32 = 0;\n\n    for splits in paren_string.split(' '){\n        for c in splits.chars(){ \n        if c == '('{\n        depth = depth + 1;\n        max_depth = max(depth, max_depth);\n        }\n        else{\n        depth = depth - 1;\n        }\n    }\n    \n    if depth == 0 {\n        result.push(max_depth);\n        max_depth = 0;\n        }\n    }\n\n    return result;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n#[test]\n    fn test_parse_nested_parens() {\n        assert!(\n            parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\")) == vec![2, 3, 1, 3]\n        );\n        assert!(parse_nested_parens(String::from(\"() (()) ((())) (((())))\")) == vec![1, 2, 3, 4]);\n        assert!(parse_nested_parens(String::from(\"(()(())((())))\")) == vec![4]);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Input to this function is a string represented multiple groups for nested parentheses separated by spaces. For each of the group, output the deepest level of nesting of parentheses. E.g. (()()) has maximum two levels of nesting while ((())) has three. ", "prompt_explain": "Input to this function is a string represented multiple groups for nested parentheses separated by spaces. For each of the group, output the deepest level of nesting of parentheses. E.g. (()()) has maximum two levels of nesting while ((())) has three. \n        assert!(parse_nested_parens(String::from(\"(()(())((())))\")) == vec![4])", "func_title": "fn parse_nested_parens(paren_string:String) -> Vec<i32>{\n", "prompt_text_chinese": "该函数的输入是一个字符串，表示由空格分隔的嵌套括号中的多个组。对于每个组，输出圆括号嵌套的最深层次。例如，(()())最多有两层嵌套，而((()))有三层。"}
{"task_id": "Rust/7", "prompt": "/*\n Filter an input list of strings only for ones that contain given substring\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn filter_by_substring(strings: Vec<String>, substring:String) -> Vec<String>{\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn filter_by_substring(strings: Vec<String>, substring:String) -> Vec<String>{\n", "canonical_solution": "\n    return strings.iter().filter(|x:&&String| x.contains(&substring)).map(String::from).collect();\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n #[test]\n    fn test_filter_by_substring() {\n        let v_empty: Vec<String> = vec![];\n        assert!(filter_by_substring(vec![], String::from(\"john\")) == v_empty);\n        assert!(\n            filter_by_substring(\n                vec![\n                    \"xxx\".to_string(),\n                    \"asd\".to_string(),\n                    \"xxy\".to_string(),\n                    \"john doe\".to_string(),\n                    \"xxxAAA\".to_string(),\n                    \"xxx\".to_string()\n                ],\n                String::from(\"xxx\")\n            ) == vec![\"xxx\", \"xxxAAA\", \"xxx\"]\n        );\n        assert!(\n            filter_by_substring(\n                vec![\n                    \"xxx\".to_string(),\n                    \"asd\".to_string(),\n                    \"aaaxxy\".to_string(),\n                    \"john doe\".to_string(),\n                    \"xxxAAA\".to_string(),\n                    \"xxx\".to_string()\n                ],\n                String::from(\"xx\")\n            ) == vec![\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]\n        );\n        assert!(\n            filter_by_substring(\n                vec![\n                    \"grunt\".to_string(),\n                    \"trumpet\".to_string(),\n                    \"prune\".to_string(),\n                    \"gruesome\".to_string()\n                ],\n                String::from(\"run\")\n            ) == [\"grunt\", \"prune\"]\n        );\n    }\n\n}\n", "example_test": "None", "prompt_text": "Filter an input list of strings only for ones that contain given substring", "prompt_explain": "Filter an input list of strings only for ones that contain given substring\n        assert!(\n            filter_by_substring(\n                vec![\n                    \"grunt\".to_string(),\n                    \"trumpet\".to_string(),\n                    \"prune\".to_string(),\n                    \"gruesome\".to_string()\n                ],\n                String::from(\"run\")\n            ) == [\"grunt\", \"prune\"]\n        )", "func_title": "fn filter_by_substring(strings: Vec<String>, substring:String) -> Vec<String>{\n", "prompt_text_chinese": "只过滤包含给定子字符串的输入字符串列表。"}
{"task_id": "Rust/8", "prompt": "/*\n For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn sum_product(numbers:Vec<i32>) -> (i32,i32){\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn sum_product(numbers:Vec<i32>) -> (i32,i32){\n", "canonical_solution": "\n    let sum = |xs: &Vec<i32>| xs.iter()\n    .fold(0, |mut sum, &val| { sum += val; \n                                                 sum }\n    );\n    let product = |xs: &Vec<i32>| xs.iter()\n    .fold(1, |mut prod, &val| { prod *= val; \n                                                 prod }\n    );\n    return (sum(&numbers),product(&numbers));\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n #[test]\n    fn test_sum_product() {\n        assert!(sum_product(vec![]) == (0, 1));\n        assert!(sum_product(vec![1, 1, 1]) == (3, 1));\n        assert!(sum_product(vec![100, 0]) == (100, 0));\n        assert!(sum_product(vec![3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7));\n        assert!(sum_product(vec![10]) == (10, 10));\n    }\n\n}\n", "example_test": "None", "prompt_text": "For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list. Empty sum should be equal to 0 and empty product should be equal to 1.", "prompt_explain": "For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list. Empty sum should be equal to 0 and empty product should be equal to 1.\n        assert!(sum_product(vec![10]) == (10, 10))", "func_title": "fn sum_product(numbers:Vec<i32>) -> (i32,i32){\n", "prompt_text_chinese": "对于给定的整数列表，返回一个元组，该元组由列表中所有整数的和和乘积组成。空和应该等于0，空积应该等于1。"}
{"task_id": "Rust/9", "prompt": "/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn rolling_max(numbers:Vec<i32>) -> Vec<i32>{\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn rolling_max(numbers:Vec<i32>) -> Vec<i32>{\n", "canonical_solution": "\n    let mut running_max :Option<i32> = None;\n    let mut result:Vec<i32> = vec![];\n\n    for n in numbers{\n        if running_max == None {\n            running_max = Some(n);\n\n        }else{\n            running_max = max(running_max, Some(n));\n        }\n\n        result.push(running_max.unwrap());\n    }\n    return result;\n\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n #[test]\n    fn test_rolling_max() {\n        assert!(rolling_max(vec![]) == vec![]);\n        assert!(rolling_max(vec![1, 2, 3, 4]) == vec![1, 2, 3, 4]);\n        assert!(rolling_max(vec![4, 3, 2, 1]) == vec![4, 4, 4, 4]);\n        assert!(rolling_max(vec![3, 2, 3, 100, 3]) == vec![3, 3, 3, 100, 100]);\n    }\n\n}\n", "example_test": "None", "prompt_text": "From a given list of integers, generate a list of rolling maximum element found until given moment in the sequence.", "prompt_explain": "From a given list of integers, generate a list of rolling maximum element found until given moment in the sequence.\n        assert!(rolling_max(vec![3, 2, 3, 100, 3]) == vec![3, 3, 3, 100, 100])", "func_title": "fn rolling_max(numbers:Vec<i32>) -> Vec<i32>{\n", "prompt_text_chinese": "从给定的整数列表中，生成一个滚动到序列中给定时刻为止的最大元素列表。"}
{"task_id": "Rust/10", "prompt": "/*\n Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn is_palindrome_10(str: &str) -> bool {\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn is_palindrome_10(str: &str) -> bool {\n", "canonical_solution": "\n        let s: String = str.chars().rev().collect();\n        return s==str;\n    }\n    \n    fn make_palindrome(str: &str) -> String {\n        let mut i: usize = 0;\n        for i in 0..str.len() {\n            let rstr: &str = &str[i..];\n            if is_palindrome_10(rstr) {\n                let nstr: &str = &str[0..i];\n                let n2str: String = nstr.chars().rev().collect();\n                return str.to_string()+&n2str;\n            }\n        }\n        let n2str: String = str.chars().rev().collect();\n        return str.to_string()+&n2str;\n    }\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n #[test]\n    fn test_make_palindrome() {\n        assert_eq!(make_palindrome(\"\"), \"\");\n        assert_eq!(make_palindrome(\"x\"), \"x\");\n        assert_eq!(make_palindrome(\"xyz\"), \"xyzyx\");\n        assert_eq!(make_palindrome(\"xyx\"), \"xyx\");\n        assert_eq!(make_palindrome(\"jerry\"), \"jerryrrej\");\n    }\n\n}\n", "example_test": "None", "prompt_text": "Find the shortest palindrome that begins with a supplied string. Algorithm idea is simple: - Find the longest postfix of supplied string that is a palindrome. - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.", "prompt_explain": "Find the shortest palindrome that begins with a supplied string. Algorithm idea is simple: - Find the longest postfix of supplied string that is a palindrome. - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n        assert_eq!(make_palindrome(\"jerry\"), \"jerryrrej\")", "func_title": "fn is_palindrome_10(str: &str) -> bool {\n", "prompt_text_chinese": "找到以提供的字符串开头的最短回文。算法思想很简单:-找到所提供的字符串的最长后缀，这是一个回文。—附加到回文后缀前的字符串前缀的反转的字符串末尾。"}
{"task_id": "Rust/11", "prompt": "/*\n Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn string_xor(a:String, b:String) -> String{\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn string_xor(a:String, b:String) -> String{\n", "canonical_solution": "\n\n    let xor = |i:char, j:char| {if i == j{return \"0\".to_string()}else{return \"1\".to_string()}};\n    return a.chars().into_iter().zip(b.chars().into_iter()).map(|(i,j)| \"\".to_string() + &xor(i,j)).collect();   \n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n #[test]\n    fn test_string_xor() {\n        assert!(string_xor(\"111000\".to_string(), \"101010\".to_string()) == \"010010\");\n        assert!(string_xor(\"1\".to_string(), \"1\".to_string()) == \"0\");\n        assert!(string_xor(\"0101\".to_string(), \"0000\".to_string()) == \"0101\");\n    }\n\n}\n", "example_test": "None", "prompt_text": "Input are two strings a and b consisting only of 1s and 0s. Perform binary XOR on these inputs and return result also as a string.", "prompt_explain": "Input are two strings a and b consisting only of 1s and 0s. Perform binary XOR on these inputs and return result also as a string.\n        assert!(string_xor(\"0101\".to_string(), \"0000\".to_string()) == \"0101\")", "func_title": "fn string_xor(a:String, b:String) -> String{\n", "prompt_text_chinese": "输入是由1和0组成的两个字符串a和b。对这些输入执行二进制异或，并以字符串形式返回结果。"}
{"task_id": "Rust/12", "prompt": "/*\n Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn longest(strings:Vec<String>) -> Option<String>{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn longest(strings:Vec<String>) -> Option<String>{\n\n", "canonical_solution": "\n    if strings.is_empty(){\n        return None;\n    }\n    let mut max:i32 = 0;\n    let mut res:String = String::new();\n\n    for s in strings{\n        if s.len() as i32 > max {\n            res = s;\n            max = res.len() as i32;\n        }    \n    }\n     return Some(res);\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n#[test]\n    fn test_longest() {\n        assert!(longest(vec![]) == None);\n        assert!(\n            longest(vec![\"x\".to_string(), \"y\".to_string(), \"z\".to_string()])\n                == Some(\"x\".to_string())\n        );\n        assert!(\n            longest(vec![\n                \"x\".to_string(),\n                \"yyy\".to_string(),\n                \"zzzz\".to_string(),\n                \"www\".to_string(),\n                \"kkkk\".to_string(),\n                \"abc\".to_string()\n            ]) == Some(\"zzzz\".to_string())\n        );\n    }\n\n}\n", "example_test": "None", "prompt_text": "Out of list of strings, return the longest one. Return the first one in case of multiple strings of the same length. Return None in case the input list is empty.", "prompt_explain": "Out of list of strings, return the longest one. Return the first one in case of multiple strings of the same length. Return None in case the input list is empty.\n        assert!(\n            longest(vec![\n                \"x\".to_string(),\n                \"yyy\".to_string(),\n                \"zzzz\".to_string(),\n                \"www\".to_string(),\n                \"kkkk\".to_string(),\n                \"abc\".to_string()\n            ]) == Some(\"zzzz\".to_string())\n        )", "func_title": "fn longest(strings:Vec<String>) -> Option<String>{\n\n", "prompt_text_chinese": "在字符串列表中，返回最长的字符串。如果有多个相同长度的字符串，则返回第一个。如果输入列表为空，则返回None。"}
{"task_id": "Rust/13", "prompt": "/*\n Return a greatest common divisor of two integers a and b\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn greatest_common_divisor(mut a:i32,mut b:i32) -> i32{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn greatest_common_divisor(mut a:i32,mut b:i32) -> i32{\n\n", "canonical_solution": "\n    while b > 0 {\n        (a, b) = (b, a % b);\n    }\n    return a;\n}\n\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n#[test]\n    fn test_greatest_common_divisor() {\n        assert!(greatest_common_divisor(3, 7) == 1);\n        assert!(greatest_common_divisor(10, 15) == 5);\n        assert!(greatest_common_divisor(49, 14) == 7);\n        assert!(greatest_common_divisor(144, 60) == 12);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Return a greatest common divisor of two integers a and b", "prompt_explain": "Return a greatest common divisor of two integers a and b\n        assert!(greatest_common_divisor(144, 60) == 12)", "func_title": "fn greatest_common_divisor(mut a:i32,mut b:i32) -> i32{\n\n", "prompt_text_chinese": "返回两个整数a和b的最大公约数。"}
{"task_id": "Rust/14", "prompt": "/*\n Return list of all prefixes from shortest to longest of the input string\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn all_prefixes(string: String) -> Vec<String>{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn all_prefixes(string: String) -> Vec<String>{\n\n", "canonical_solution": "\n   let mut res:Vec<String> = vec![];\n   let mut res_str:String = String::new();\n\nfor c in string.chars(){\n    res_str.push(c);\n    res.push(res_str.clone());\n}\nreturn res;\n}\n\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n #[test]\n    fn test_all_prefixes() {\n        let v_empty: Vec<String> = vec![];\n        assert!(all_prefixes(String::from(\"\")) == v_empty);\n        assert!(\n            all_prefixes(String::from(\"asdfgh\"))\n                == vec![\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"]\n        );\n        assert!(all_prefixes(String::from(\"WWW\")) == vec![\"W\", \"WW\", \"WWW\"]);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Return list of all prefixes from shortest to longest of the input string", "prompt_explain": "Return list of all prefixes from shortest to longest of the input string\n        assert!(all_prefixes(String::from(\"WWW\")) == vec![\"W\", \"WW\", \"WWW\"])", "func_title": "fn all_prefixes(string: String) -> Vec<String>{\n\n", "prompt_text_chinese": "返回输入字符串中从最短到最长的所有前缀列表"}
{"task_id": "Rust/15", "prompt": "/*\n Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn string_sequence(n:i32) -> String{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn string_sequence(n:i32) -> String{\n\n", "canonical_solution": "\n    let mut res:String = String::new();\n\n    for number in 0..n + 1{\n        res = res + &number.to_string() + \" \";\n    }\n    \n    return res.trim_end().to_string();\n\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n #[test]\n    fn test_string_sequence() {\n        assert!(string_sequence(0) == \"0\".to_string());\n        assert!(string_sequence(3) == \"0 1 2 3\".to_string());\n        assert!(string_sequence(10) == \"0 1 2 3 4 5 6 7 8 9 10\".to_string());\n    }\n\n}\n", "example_test": "None", "prompt_text": "Return a string containing space-delimited numbers starting from 0 upto n inclusive.", "prompt_explain": "Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n        assert!(string_sequence(10) == \"0 1 2 3 4 5 6 7 8 9 10\".to_string())", "func_title": "fn string_sequence(n:i32) -> String{\n\n", "prompt_text_chinese": "返回一个字符串，包含以空格分隔的数字，从0到n(包括n)。"}
{"task_id": "Rust/16", "prompt": "/*\n Given a string, find out how many distinct characters (regardless of case) does it consist of\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn count_distinct_characters(str:String) -> i32{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn count_distinct_characters(str:String) -> i32{\n\n", "canonical_solution": "\n    let res:HashSet<char> = str.chars().into_iter().map(|x:char| x.to_ascii_lowercase()).collect();\n    return res.len() as i32;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n #[test]\n    fn test_count_distinct_characters() {\n        assert!(count_distinct_characters(\"\".to_string()) == 0);\n        assert!(count_distinct_characters(\"abcde\".to_string()) == 5);\n        assert!(\n            count_distinct_characters(\n                \"abcde\".to_string() + &\"cade\".to_string() + &\"CADE\".to_string()\n            ) == 5\n        );\n        assert!(count_distinct_characters(\"aaaaAAAAaaaa\".to_string()) == 1);\n        assert!(count_distinct_characters(\"Jerry jERRY JeRRRY\".to_string()) == 5);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Given a string, find out how many distinct characters (regardless of case) does it consist of", "prompt_explain": "Given a string, find out how many distinct characters (regardless of case) does it consist of\n        assert!(count_distinct_characters(\"Jerry jERRY JeRRRY\".to_string()) == 5)", "func_title": "fn count_distinct_characters(str:String) -> i32{\n\n", "prompt_text_chinese": "给定一个字符串，找出它由多少个不同的字符(不管大小写)组成"}
{"task_id": "Rust/17", "prompt": "/*\n Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn parse_music(music_string:String) -> Vec<i32>{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn parse_music(music_string:String) -> Vec<i32>{\n\n", "canonical_solution": "\n\n    let map = |x:&str| {match x {\n        \"o\" => 4,\n        \"o|\" => 2,\n        \".|\" =>  1,\n        _ => 0\n    } \n};\n    return music_string.split(\" \").map(|x:&str| map(&x.to_string())).filter(|x:&i32| x != &0).collect();\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n #[test]\n    fn test_parse_music() {\n        assert!(parse_music(\" \".to_string()) == []);\n        assert!(parse_music(\"o o o o\".to_string()) == vec![4, 4, 4, 4]);\n        assert!(parse_music(\".| .| .| .|\".to_string()) == vec![1, 1, 1, 1]);\n        assert!(parse_music(\"o| o| .| .| o o o o\".to_string()) == vec![2, 2, 1, 1, 4, 4, 4, 4]);\n        assert!(parse_music(\"o| .| o| .| o o| o o|\".to_string()) == vec![2, 1, 2, 1, 4, 2, 4, 2]);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Input to this function is a string representing musical notes in a special ASCII format. Your task is to parse this string and return list of integers corresponding to how many beats does each not last.  Here is a legend: 'o' - whole note, lasts four beats 'o|' - half note, lasts two beats '.|' - quater note, lasts one beat ", "prompt_explain": "Input to this function is a string representing musical notes in a special ASCII format. Your task is to parse this string and return list of integers corresponding to how many beats does each not last.  Here is a legend: 'o' - whole note, lasts four beats 'o|' - half note, lasts two beats '.|' - quater note, lasts one beat \n        assert!(parse_music(\"o| .| o| .| o o| o o|\".to_string()) == vec![2, 1, 2, 1, 4, 2, 4, 2])", "func_title": "fn parse_music(music_string:String) -> Vec<i32>{\n\n", "prompt_text_chinese": "这个函数的输入是一个字符串，以特殊的ASCII格式表示音符。您的任务是解析这个字符串并返回一个整数列表，该列表对应于每个节拍不持续的次数。这里有一个传说:'o' -全音，持续四拍'o|' -半音，持续两拍'。|' -四分音符，持续一拍"}
{"task_id": "Rust/18", "prompt": "/*\n Find how many times a given substring can be found in the original string. Count overlaping cases.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn how_many_times(string: String, substring:String) -> i32{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn how_many_times(string: String, substring:String) -> i32{\n\n", "canonical_solution": "\n    let mut times:i32 = 0;\n\n    for i in 0..(string.len() as i32 - substring.len() as i32 + 1){\n        if string.get(i as usize..(i + substring.len() as i32) as usize).unwrap().to_string() == substring {\n            times += 1;\n        }    \n    }\n    return times;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n#[test]\n    fn test_how_many_times() {\n        assert!(how_many_times(\"\".to_string(), \"x\".to_string()) == 0);\n        assert!(how_many_times(\"xyxyxyx\".to_string(), \"x\".to_string()) == 4);\n        assert!(how_many_times(\"cacacacac\".to_string(), \"cac\".to_string()) == 4);\n        assert!(how_many_times(\"john doe\".to_string(), \"john\".to_string()) == 1);\n    }\n\n\n}\n", "example_test": "None", "prompt_text": "Find how many times a given substring can be found in the original string. Count overlaping cases.", "prompt_explain": "Find how many times a given substring can be found in the original string. Count overlaping cases.\n        assert!(how_many_times(\"john doe\".to_string(), \"john\".to_string()) == 1)", "func_title": "fn how_many_times(string: String, substring:String) -> i32{\n\n", "prompt_text_chinese": "找出给定的子字符串在原始字符串中可以找到多少次。计算重叠的情况。"}
{"task_id": "Rust/19", "prompt": "/*\n Input is a space-delimited string of numberals from 'zero' to 'nine'.\n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n    Return the string with numbers sorted from smallest to largest\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn sort_numbers(numbers:String) -> String {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn sort_numbers(numbers:String) -> String {\n\n", "canonical_solution": "\n    let str_to_i32 = |x:&str| {match x{\n            \"zero\" => 0,\n            \"one\" => 1,\n            \"two\" => 2,\n            \"three\" => 3,\n            \"four\" => 4,\n            \"five\" => 5,\n            \"six\" => 6,\n            \"seven\" => 7,\n            \"eight\" => 8,\n            \"nine\" => 9,\n            _ => 1000\n    }};\n\n    let i32_to_str = |x:&i32| {match x{\n        0 => \"zero\".to_string(),\n        1 => \"one\".to_string(),\n        2 => \"two\".to_string(),\n        3 => \"three\".to_string(),\n        4 => \"four\".to_string(),\n        5 => \"five\".to_string(),\n        6 => \"six\".to_string(),\n        7 => \"seven\".to_string(),\n        8 => \"eight\".to_string(),\n        9 => \"nine\".to_string(),\n        _ => \"none\".to_string()\n}};\n\n    let mut nmbrs:Vec<i32> = numbers.split_ascii_whitespace().map(|x:&str| str_to_i32(x)).collect(); \n    nmbrs.sort();\n    let res:String = nmbrs.iter().map(|x:&i32| i32_to_str(x) + \" \").collect();\n    return res.trim_end().to_string();\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n#[test]\n    fn test_sort_numbers() {\n        assert!(sort_numbers(\"\".to_string()) == \"\".to_string());\n        assert!(sort_numbers(\"three\".to_string()) == \"three\".to_string());\n        assert!(sort_numbers(\"three five nine\".to_string()) == \"three five nine\");\n        assert!(\n            sort_numbers(\"five zero four seven nine eight\".to_string())\n                == \"zero four five seven eight nine\".to_string()\n        );\n        assert!(\n            sort_numbers(\"six five four three two one zero\".to_string())\n                == \"zero one two three four five six\".to_string()\n        );\n    }\n\n}\n", "example_test": "None", "prompt_text": "Input is a space-delimited string of numberals from 'zero' to 'nine'. Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'. Return the string with numbers sorted from smallest to largest", "prompt_explain": "Input is a space-delimited string of numberals from 'zero' to 'nine'. Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'. Return the string with numbers sorted from smallest to largest\n        assert!(\n            sort_numbers(\"six five four three two one zero\".to_string())\n                == \"zero one two three four five six\".to_string()\n        )", "func_title": "fn sort_numbers(numbers:String) -> String {\n\n", "prompt_text_chinese": "输入是一个空格分隔的数字字符串，从“0”到“9”。有效的选项是“0”、“1”、“2”、“3”、“4”、“5”、“6”、“7”、“8”和“9”。返回由小到大排序的字符串"}
{"task_id": "Rust/20", "prompt": "/*\n From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn find_closest_elements(numbers:Vec<f32>) -> (f32,f32){\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn find_closest_elements(numbers:Vec<f32>) -> (f32,f32){\n\n", "canonical_solution": "\n    let mut closest_pair = (0.0,0.0);\n    let mut distance:Option<f32> = None;\n\n    for (idx, elem) in numbers.iter().enumerate(){\n        for (idx2, elem2) in  numbers.iter().enumerate() {\n            if idx != idx2 {\n                if distance == None {\n                    distance = Some((elem - elem2).abs());\n                    if *elem < *elem2{\n                        closest_pair = (*elem, *elem2);\n                    }else{\n                        closest_pair = (*elem2, *elem);\n                    }\n\n                }else{\n                    let new_distance:f32= (elem - elem2).abs();\n                    if new_distance < distance.unwrap(){\n                        distance = Some(new_distance);\n\n                        if *elem < *elem2{\n                            closest_pair = (*elem, *elem2);\n                        }else{\n                            closest_pair = (*elem2, *elem);\n                        }\n                        \n    \n                    }\n                }\n            }\n        }\n    }\n    return closest_pair;\n\n\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n #[test]\n    fn test_find_closest_elements() {\n        assert!(find_closest_elements(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0));\n        assert!(find_closest_elements(vec![1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9));\n        assert!(find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2));\n        assert!(find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0));\n        assert!(find_closest_elements(vec![1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1));\n    }\n\n}\n", "example_test": "None", "prompt_text": "From a supplied list of numbers (of length at least two) select and return two that are the closest to each other and return them in order (smaller number, larger number).", "prompt_explain": "From a supplied list of numbers (of length at least two) select and return two that are the closest to each other and return them in order (smaller number, larger number).\n        assert!(find_closest_elements(vec![1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))", "func_title": "fn find_closest_elements(numbers:Vec<f32>) -> (f32,f32){\n\n", "prompt_text_chinese": "从提供的数字列表(长度至少为两个)中选择并返回两个彼此最接近的数字，并按顺序返回它们(较小的数字，较大的数字)。"}
{"task_id": "Rust/21", "prompt": "/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn rescale_to_unit(numbers:Vec<f32>) -> Vec<f32> {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn rescale_to_unit(numbers:Vec<f32>) -> Vec<f32> {\n\n", "canonical_solution": "\n    let min_number= *numbers.iter().min_by(|a, b| a.partial_cmp(b).unwrap()).unwrap();\n    let max_number=  *numbers.iter().max_by(|a, b| a.partial_cmp(b).unwrap()).unwrap();\n    return numbers.iter().map(|x:&f32| (x-min_number) / (max_number - min_number)).collect();\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n#[test]\n    fn test_rescale_to_unit() {\n        assert!(rescale_to_unit(vec![2.0, 49.9]) == [0.0, 1.0]);\n        assert!(rescale_to_unit(vec![100.0, 49.9]) == [1.0, 0.0]);\n        assert!(rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n        assert!(rescale_to_unit(vec![2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n        assert!(rescale_to_unit(vec![12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Given list of numbers (of at least two elements), apply a linear transform to that list, such that the smallest number will become 0 and the largest will become 1", "prompt_explain": "Given list of numbers (of at least two elements), apply a linear transform to that list, such that the smallest number will become 0 and the largest will become 1\n        assert!(rescale_to_unit(vec![12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])", "func_title": "fn rescale_to_unit(numbers:Vec<f32>) -> Vec<f32> {\n\n", "prompt_text_chinese": "给定一个数字列表(至少包含两个元素)，对该列表应用线性变换，使最小的数字变为0，最大的数字变为1"}
{"task_id": "Rust/22", "prompt": "/*\n Filter given list of any python values only for integers\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn filter_integers(values: Vec<Box<dyn Any>>) -> Vec<i32> {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn filter_integers(values: Vec<Box<dyn Any>>) -> Vec<i32> {\n\n", "canonical_solution": "\n        let mut out: Vec<i32> = Vec::new();\n        for value in values {\n            if let Some(i) = value.downcast_ref::<i32>() {\n                out.push(*i);\n            }\n        }\n        out\n    }\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n #[test]\n    fn test_filter_integers() {\n        assert_eq!(filter_integers(vec![]), vec![]);\n        let v_empty: Vec<Box<dyn Any>> = vec![];\n        assert_eq!(\n            filter_integers(vec![\n                Box::new(4),\n                Box::new(v_empty),\n                Box::new(23.2),\n                Box::new(9),\n                Box::new(String::from(\"adasd\"))\n            ]),\n            vec![4, 9]\n        );\n        assert_eq!(\n            filter_integers(vec![\n                Box::new(3),\n                Box::new('c'),\n                Box::new(3),\n                Box::new(3),\n                Box::new('a'),\n                Box::new('b')\n            ]),\n            vec![3, 3, 3]\n        );\n    }\n\n}\n", "example_test": "None", "prompt_text": "Filter given list of any python values only for integers", "prompt_explain": "Filter given list of any python values only for integers\n        assert_eq!(\n            filter_integers(vec![\n                Box::new(3),\n                Box::new('c'),\n                Box::new(3),\n                Box::new(3),\n                Box::new('a'),\n                Box::new('b')\n            ]),\n            vec![3, 3, 3]\n        )", "func_title": "fn filter_integers(values: Vec<Box<dyn Any>>) -> Vec<i32> {\n\n", "prompt_text_chinese": "仅为整数过滤给定的python值列表"}
{"task_id": "Rust/23", "prompt": "/*\n Return length of given string\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn strlen(strings:String) -> i32{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn strlen(strings:String) -> i32{\n\n", "canonical_solution": "\n    return strings.len() as i32;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n #[test]\n    fn test_strlen() {\n        assert!(strlen(\"\".to_string()) == 0);\n        assert!(strlen(\"x\".to_string()) == 1);\n        assert!(strlen(\"asdasnakj\".to_string()) == 9);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Return length of given string", "prompt_explain": "Return length of given string\n        assert!(strlen(\"asdasnakj\".to_string()) == 9)", "func_title": "fn strlen(strings:String) -> i32{\n\n", "prompt_text_chinese": "返回给定字符串的长度"}
{"task_id": "Rust/24", "prompt": "/*\n For a given number n, find the largest number that divides n evenly, smaller than n\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn largest_divisor(n:i32) -> i32{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn largest_divisor(n:i32) -> i32{\n\n", "canonical_solution": "\n    let mut res:i32 = 0;\n    let sqn = 1..n;\n    \n    for i in sqn.rev(){\n        if n % i == 0 {\n            res = i;\n            break;\n        }\n    }\n\n    return res;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n #[test]\n    fn test_largest_divisor() {\n        assert!(largest_divisor(3) == 1);\n        assert!(largest_divisor(7) == 1);\n        assert!(largest_divisor(10) == 5);\n        assert!(largest_divisor(100) == 50);\n        assert!(largest_divisor(49) == 7);\n    }\n\n}\n", "example_test": "None", "prompt_text": "For a given number n, find the largest number that divides n evenly, smaller than n", "prompt_explain": "For a given number n, find the largest number that divides n evenly, smaller than n\n        assert!(largest_divisor(49) == 7)", "func_title": "fn largest_divisor(n:i32) -> i32{\n\n", "prompt_text_chinese": "对于给定的数n，求出能将n整除且小于n的最大的数"}
{"task_id": "Rust/25", "prompt": "/*\n Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn factorize(n: i32) -> Vec<i32> {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn factorize(n: i32) -> Vec<i32> {\n\n", "canonical_solution": "\n    let mut n = n;\n    let mut factors = vec![];\n    let mut divisor = 2;\n    while divisor * divisor <= n {\n        while n % divisor == 0 {\n            factors.push(divisor);\n            n = n / divisor;\n        }\n        divisor = divisor + 1;\n    }\n    if n > 1 {\n        factors.push(n);\n    }\n    factors\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n #[test]\n    fn test_factorize() {\n        assert_eq!(factorize(2), vec![2]);\n        assert_eq!(factorize(4), vec![2, 2]);\n        assert_eq!(factorize(8), vec![2, 2, 2]);\n        assert_eq!(factorize(3 * 19), vec![3, 19]);\n        assert_eq!(factorize(3 * 19 * 3 * 19), vec![3, 3, 19, 19]);\n        assert_eq!(\n            factorize(3 * 19 * 3 * 19 * 3 * 19),\n            vec![3, 3, 3, 19, 19, 19]\n        );\n        assert_eq!(factorize(3 * 19 * 19 * 19), vec![3, 19, 19, 19]);\n        assert_eq!(factorize(3 * 2 * 3), vec![2, 3, 3]);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Return list of prime factors of given integer in the order from smallest to largest. Each of the factors should be listed number of times corresponding to how many times it appeares in factorization. Input number should be equal to the product of all factors", "prompt_explain": "Return list of prime factors of given integer in the order from smallest to largest. Each of the factors should be listed number of times corresponding to how many times it appeares in factorization. Input number should be equal to the product of all factors\n        assert_eq!(factorize(3 * 2 * 3), vec![2, 3, 3])", "func_title": "fn factorize(n: i32) -> Vec<i32> {\n\n", "prompt_text_chinese": "按从小到大的顺序返回给定整数的质因数列表。每一个因子都要列出它在因式分解中出现的次数。输入数应等于所有因子的乘积"}
{"task_id": "Rust/26", "prompt": "/*\n From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn remove_duplicates(numbers: Vec<i32>) -> Vec<i32>{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn remove_duplicates(numbers: Vec<i32>) -> Vec<i32>{\n\n", "canonical_solution": "\n    let mut m: HashMap<i32, i32> = HashMap::new();\n\n    for n in &numbers {\n        *m.entry(*n).or_default() += 1;\n    }\n    let res:Vec<i32> = numbers.into_iter().filter(|x| m.get(x) == Some(&1)).collect();\n    return res;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n #[test]\n    fn test_remove_duplicates() {\n        assert!(remove_duplicates(vec![]) == []);\n        assert!(remove_duplicates(vec![1, 2, 3, 4]) == vec![1, 2, 3, 4]);\n        assert!(remove_duplicates(vec![1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]);\n    }\n\n}\n", "example_test": "None", "prompt_text": "From a list of integers, remove all elements that occur more than once. Keep order of elements left the same as in the input.", "prompt_explain": "From a list of integers, remove all elements that occur more than once. Keep order of elements left the same as in the input.\n        assert!(remove_duplicates(vec![1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5])", "func_title": "fn remove_duplicates(numbers: Vec<i32>) -> Vec<i32>{\n\n", "prompt_text_chinese": "从整数列表中删除所有出现一次以上的元素。保持元素的顺序与输入相同。"}
{"task_id": "Rust/27", "prompt": "/*\n For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\npub fn flip_case(string: String) -> String{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\npub fn flip_case(string: String) -> String{\n\n", "canonical_solution": "\n    return string.chars().into_iter().fold(String::new(), |res:String, c:char| {if c.is_ascii_lowercase(){return res + &c.to_uppercase().to_string();}else{return res + &c.to_ascii_lowercase().to_string();}});\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n#[test]\n    fn test_flip_case() {\n        assert!(flip_case(\"\".to_string()) == \"\".to_string());\n        assert!(flip_case(\"Hello!\".to_string()) == \"hELLO!\".to_string());\n        assert!(\n            flip_case(\"These violent delights have violent ends\".to_string())\n                == \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\".to_string()\n        );\n    }\n\n}\n", "example_test": "None", "prompt_text": "For a given string, flip lowercase characters to uppercase and uppercase to lowercase.", "prompt_explain": "For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n        assert!(\n            flip_case(\"These violent delights have violent ends\".to_string())\n                == \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\".to_string()\n        )", "func_title": "fn flip_case(string: String) -> String{\n\n", "prompt_text_chinese": "对于给定的字符串，将小写字符转换为大写字符，将大写字符转换为小写字符。"}
{"task_id": "Rust/28", "prompt": "/*\n Concatenate list of strings into a single string\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn concatenate(strings:Vec<String>) -> String{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn concatenate(strings:Vec<String>) -> String{\n\n", "canonical_solution": "\n    return strings.iter().fold(String::new(),|res: String, x:&String| res + &x.to_string());\n\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n #[test]\n    fn test_concatenate() {\n        assert!(concatenate(vec![]) == \"\".to_string());\n        assert!(\n            concatenate(vec![\"x\".to_string(), \"y\".to_string(), \"z\".to_string()])\n                == \"xyz\".to_string()\n        );\n        assert!(\n            concatenate(vec![\n                \"x\".to_string(),\n                \"y\".to_string(),\n                \"z\".to_string(),\n                \"w\".to_string(),\n                \"k\".to_string()\n            ]) == \"xyzwk\".to_string()\n        );\n    }\n\n\n}\n", "example_test": "None", "prompt_text": "Concatenate list of strings into a single string", "prompt_explain": "Concatenate list of strings into a single string\n        assert!(\n            concatenate(vec![\n                \"x\".to_string(),\n                \"y\".to_string(),\n                \"z\".to_string(),\n                \"w\".to_string(),\n                \"k\".to_string()\n            ]) == \"xyzwk\".to_string()\n        )", "func_title": "fn concatenate(strings:Vec<String>) -> String{\n\n", "prompt_text_chinese": "串接字符串列表成一个单一的字符串"}
{"task_id": "Rust/29", "prompt": "/*\n Filter an input list of strings only for ones that start with a given prefix.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn filter_by_prefix(strings:Vec<String>, prefix:String)-> Vec<String>{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn filter_by_prefix(strings:Vec<String>, prefix:String)-> Vec<String>{\n\n", "canonical_solution": "\n    return strings.into_iter().filter(|s| s.starts_with(&prefix)).collect();\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n#[test]\n    fn test_filter_by_prefix() {\n        let v_empty: Vec<String> = vec![];\n        assert!(filter_by_prefix(vec![], \"john\".to_string()) == v_empty);\n        assert!(\n            filter_by_prefix(\n                vec![\n                    \"xxx\".to_string(),\n                    \"asd\".to_string(),\n                    \"xxy\".to_string(),\n                    \"john doe\".to_string(),\n                    \"xxxAAA\".to_string(),\n                    \"xxx\".to_string()\n                ],\n                \"xxx\".to_string()\n            ) == vec![\"xxx\", \"xxxAAA\", \"xxx\"]\n        );\n    }\n\n\n}\n", "example_test": "None", "prompt_text": "Filter an input list of strings only for ones that start with a given prefix.", "prompt_explain": "Filter an input list of strings only for ones that start with a given prefix.\n        assert!(\n            filter_by_prefix(\n                vec![\n                    \"xxx\".to_string(),\n                    \"asd\".to_string(),\n                    \"xxy\".to_string(),\n                    \"john doe\".to_string(),\n                    \"xxxAAA\".to_string(),\n                    \"xxx\".to_string()\n                ],\n                \"xxx\".to_string()\n            ) == vec![\"xxx\", \"xxxAAA\", \"xxx\"]\n        )", "func_title": "fn filter_by_prefix(strings:Vec<String>, prefix:String)-> Vec<String>{\n\n", "prompt_text_chinese": "仅过滤以给定前缀开头的字符串的输入列表。"}
{"task_id": "Rust/30", "prompt": "/*\nReturn only positive numbers in the list.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn get_positive(numbers:Vec<i32>) -> Vec<i32>{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn get_positive(numbers:Vec<i32>) -> Vec<i32>{\n\n", "canonical_solution": "\n    return numbers.into_iter().filter(|n| n.is_positive()).collect();\n\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n  #[test]\n    fn test_get_positive() {\n        assert!(get_positive(vec![-1, -2, 4, 5, 6]) == [4, 5, 6]);\n        assert!(\n            get_positive(vec![5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n        );\n        assert!(get_positive(vec![-1, -2]) == []);\n        assert!(get_positive(vec![]) == []);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Return only positive numbers in the list.", "prompt_explain": "Return only positive numbers in the list.\n        assert!(get_positive(vec![]) == [])", "func_title": "fn get_positive(numbers:Vec<i32>) -> Vec<i32>{\n\n", "prompt_text_chinese": "只返回列表中的正数。"}
{"task_id": "Rust/31", "prompt": "/*\nReturn true if a given number is prime, and false otherwise.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn is_prime(n:i32) -> bool{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn is_prime(n:i32) -> bool{\n\n", "canonical_solution": "\n    if n < 2{\n    return false;\n}\nfor k in 2..n-1 {\n    if n % k == 0{\n        return false;\n    }\n}\nreturn true;\n\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_is_prime() {\n        assert!(is_prime(6) == false);\n        assert!(is_prime(101) == true);\n        assert!(is_prime(11) == true);\n        assert!(is_prime(13441) == true);\n        assert!(is_prime(61) == true);\n        assert!(is_prime(4) == false);\n        assert!(is_prime(1) == false);\n        assert!(is_prime(5) == true);\n        assert!(is_prime(11) == true);\n        assert!(is_prime(17) == true);\n        assert!(is_prime(5 * 17) == false);\n        assert!(is_prime(11 * 7) == false);\n        assert!(is_prime(13441 * 19) == false);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Return true if a given number is prime, and false otherwise.", "prompt_explain": "Return true if a given number is prime, and false otherwise.\n        assert!(is_prime(13441 * 19) == false)", "func_title": "fn is_prime(n:i32) -> bool{\n\n", "prompt_text_chinese": "如果给定的数字是质数则返回true，否则返回false。"}
{"task_id": "Rust/32", "prompt": "/*\n xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn poly(xs: &Vec<f64>, x: f64) -> f64 {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn poly(xs: &Vec<f64>, x: f64) -> f64 {\n\n", "canonical_solution": "\n        let mut sum = 0.0;\n        for i in 0..xs.len() {\n            sum += xs[i] * x.powi(i as i32);\n        }\n        sum\n    }\n    \n    fn find_zero(xs: &Vec<f64>) -> f64 {\n        let mut ans = 0.0;\n        let mut value = poly(xs, ans);\n        while value.abs() > 1e-6 {\n            let mut driv = 0.0;\n            for i in 1..xs.len() {\n                driv += xs[i] * ans.powi((i - 1) as i32) * (i as f64);\n            }\n            ans = ans - value / driv;\n            value = poly(xs, ans);\n        }\n        ans\n    }\n", "test": "\n/*\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n#[test]\n    fn test_poly() {\n        let mut rng = rand::thread_rng();\n        let mut solution: f64;\n        let mut ncoeff: i32;\n        for _ in 0..100 {\n            ncoeff = 2 * (1 + rng.gen_range(0, 4));\n            let mut coeffs = vec![];\n            for _ in 0..ncoeff {\n                let coeff = -10 + rng.gen_range(0, 21);\n                if coeff == 0 {\n                    coeffs.push(1.0);\n                } else {\n                    coeffs.push(coeff as f64);\n                }\n            }\n            solution = find_zero(&coeffs);\n            assert!(poly(&coeffs, solution).abs() < 1e-3);\n        }\n    }\n\n}\n*/\n", "example_test": "None", "prompt_text": "xs are coefficients of a polynomial. find_zero find x such that poly(x) = 0. find_zero returns only only zero point, even if there are many. Moreover, find_zero only takes list xs having even number of coefficients and largest non zero coefficient as it guarantees a solution.", "prompt_explain": "xs are coefficients of a polynomial. find_zero find x such that poly(x) = 0. find_zero returns only only zero point, even if there are many. Moreover, find_zero only takes list xs having even number of coefficients and largest non zero coefficient as it guarantees a solution.\n            assert!(poly(&coeffs, solution).abs() < 1e-3)", "func_title": "fn poly(xs: &Vec<f64>, x: f64) -> f64 {\n\n", "prompt_text_chinese": "x是多项式的系数。求x使poly(x) = 0。Find_zero只返回0点，即使有很多。此外，find_zero只接受系数为偶数且系数最大非零的列表xs，因为它保证了一个解。"}
{"task_id": "Rust/33", "prompt": "/*\nThis function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn sort_third(l: Vec<i32>) -> Vec<i32> {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn sort_third(l: Vec<i32>) -> Vec<i32> {\n\n", "canonical_solution": "\n    let mut third = vec![];\n    let mut out:Vec<i32> = vec![];\n\n    for (indx,elem) in l.iter().enumerate(){\n        if indx%3 == 0 && indx != 0{\n            third.push(elem)\n        }\n    }\n    third.sort();\n    let mut indx_t:usize = 0;\n\n    for i in 0..l.len() {\n        if i%3 == 0 && i != 0{\n            if indx_t < third.len(){\n                out.push(*third[indx_t]);\n                indx_t += 1;\n        }\n        }else{\n            out.push(l[i]);\n        }\n        \n    }\n    return out;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n #[test]\n    fn test_sort_third() {\n        let mut l = vec![1, 2, 3];\n        assert_eq!(sort_third(l), vec![1, 2, 3]);\n        l = vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10];\n        assert_eq!(sort_third(l), vec![5, 3, -5, 1, -3, 3, 2, 0, 123, 9, -10]);\n        l = vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10];\n        assert_eq!(sort_third(l), vec![5, 8, -12, -10, 23, 2, 3, 11, 12, 4]);\n        l = vec![5, 6, 3, 4, 8, 9, 2];\n        assert_eq!(sort_third(l), vec![5, 6, 3, 2, 8, 9, 4]);\n        l = vec![5, 8, 3, 4, 6, 9, 2];\n        assert_eq!(sort_third(l), vec![5, 8, 3, 2, 6, 9, 4]);\n        l = vec![5, 6, 9, 4, 8, 3, 2];\n        assert_eq!(sort_third(l), vec![5, 6, 9, 2, 8, 3, 4]);\n        l = vec![5, 6, 3, 4, 8, 9, 2, 1];\n        assert_eq!(sort_third(l), vec![5, 6, 3, 2, 8, 9, 4, 1]);\n    }\n\n}\n", "example_test": "None", "prompt_text": "This function takes a list l and returns a list l' such that l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal to the values of the corresponding indicies of l, but sorted.", "prompt_explain": "This function takes a list l and returns a list l' such that l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal to the values of the corresponding indicies of l, but sorted.\n        assert_eq!(sort_third(l), vec![5, 6, 3, 2, 8, 9, 4, 1])", "func_title": "fn sort_third(l: Vec<i32>) -> Vec<i32> {\n\n", "prompt_text_chinese": "这个函数接受一个列表l并返回一个列表l'，使得l'在不能被3整除的下标处与l相同，而它在能被3整除的下标处的值等于l的相应下标处的值，但已排序。"}
{"task_id": "Rust/34", "prompt": "/*\nReturn sorted unique elements in a list\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn unique(nmbs:Vec<i32>)  -> Vec<i32>{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn unique(nmbs:Vec<i32>)  -> Vec<i32>{\n\n", "canonical_solution": "\n    let mut res:Vec<i32> = nmbs.clone();\n    res.sort();\n    res.dedup();\n    return res;\n }\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n  #[test]\n    fn test_unique() {\n        assert!(unique(vec![5, 3, 5, 2, 3, 3, 9, 0, 123]) == vec![0, 2, 3, 5, 9, 123]);\n    }\n\n\n}\n", "example_test": "None", "prompt_text": "Return sorted unique elements in a list", "prompt_explain": "Return sorted unique elements in a list\n\n  #[test]\n    fn test_unique() {\n        assert!(unique(vec![5, 3, 5, 2, 3, 3, 9, 0, 123]) == vec![0, 2, 3, 5, 9, 123])", "func_title": "fn unique(nmbs:Vec<i32>)  -> Vec<i32>{\n\n", "prompt_text_chinese": "返回列表中已排序的唯一元素"}
{"task_id": "Rust/35", "prompt": "/*\nReturn maximum element in the list.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn maximum(nmbs:Vec<i32>) -> i32{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn maximum(nmbs:Vec<i32>) -> i32{\n\n", "canonical_solution": "\n    return *nmbs.iter().max().unwrap();\n }\n\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n #[test]\n    fn test_maximum() {\n        assert!(maximum(vec![1, 2, 3]) == 3);\n        assert!(maximum(vec![5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124);\n    }\n\n\n}\n", "example_test": "None", "prompt_text": "Return maximum element in the list.", "prompt_explain": "Return maximum element in the list.\n        assert!(maximum(vec![5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)", "func_title": "fn maximum(nmbs:Vec<i32>) -> i32{\n\n", "prompt_text_chinese": "返回列表中最大的元素。"}
{"task_id": "Rust/36", "prompt": "/*\nReturn the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn fizz_buzz(n:i32) -> i32{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn fizz_buzz(n:i32) -> i32{\n\n", "canonical_solution": "\n    let mut ns:Vec<i32> = vec![];\n\n    for i in 0..n{\n        if i % 11 == 0 || i % 13 == 0{\n            ns.push(i);\n        }\n    }\n\n    let s:String = ns.into_iter().fold(String::new(),|s:String, n:i32| {s + &n.to_string()});\n    let mut ans:i32 = 0;\n\n    for c in s.chars(){\n        if c == '7'{\n        ans += 1;\n        }\n    }\n    return ans;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n\n    #[test]\n    fn test_fizz_buzz() {\n        assert!(fizz_buzz(50) == 0);\n        assert!(fizz_buzz(78) == 2);\n        assert!(fizz_buzz(79) == 3);\n        assert!(fizz_buzz(100) == 3);\n        assert!(fizz_buzz(200) == 6);\n        assert!(fizz_buzz(4000) == 192);\n        assert!(fizz_buzz(10000) == 639);\n        assert!(fizz_buzz(100000) == 8026);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.", "prompt_explain": "Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n        assert!(fizz_buzz(100000) == 8026)", "func_title": "fn fizz_buzz(n:i32) -> i32{\n\n", "prompt_text_chinese": "返回数字7在小于n且能被11或13整除的整数中出现的次数。"}
{"task_id": "Rust/37", "prompt": "/*\nThis function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn sort_even(nmbs:Vec<i32>) -> Vec<i32>{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn sort_even(nmbs:Vec<i32>) -> Vec<i32>{\n\n", "canonical_solution": "\n    let mut even = vec![];\n    let mut out:Vec<i32> = vec![];\n\n    for (indx,elem) in nmbs.iter().enumerate(){\n        if indx%2 == 0{\n            even.push(elem)\n        }\n    }\n    even.sort();\n    let mut indx_t:usize = 0;\n\n    for i in 0..nmbs.len() {\n        if i%2 == 0{\n            if indx_t < even.len(){\n                out.push(*even[indx_t]);\n                indx_t += 1;\n        }\n        }else{\n            out.push(nmbs[i]);\n        }\n        \n    }\n    return out;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n #[test]\n    fn test_sort_even() {\n        assert_eq!(sort_even(vec![1, 2, 3]), vec![1, 2, 3]);\n        assert_eq!(\n            sort_even(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\n            vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]\n        );\n        assert_eq!(\n            sort_even(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\n            vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]\n        );\n    }\n\n}\n", "example_test": "None", "prompt_text": "This function takes a list l and returns a list l' such that l' is identical to l in the odd indicies, while its values at the even indicies are equal to the values of the even indicies of l, but sorted.", "prompt_explain": "This function takes a list l and returns a list l' such that l' is identical to l in the odd indicies, while its values at the even indicies are equal to the values of the even indicies of l, but sorted.\n        assert_eq!(\n            sort_even(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\n            vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]\n        )", "func_title": "fn sort_even(nmbs:Vec<i32>) -> Vec<i32>{\n\n", "prompt_text_chinese": "这个函数接受一个列表l并返回一个列表l'，使得l'在奇数下标处与l相同，而它在偶数下标处的值等于l的偶数下标处的值，但已排序。"}
{"task_id": "Rust/38", "prompt": "/*\n\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn decode_cyclic(s: &str) -> String {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn decode_cyclic(s: &str) -> String {\n\n", "canonical_solution": "\n\n    let l = s.len();\n    let num = (l + 2) / 3;\n    let mut output = String::new();\n    for i in 0..num {\n        let group = &s[i * 3..std::cmp::min(l, (i + 1) * 3)];\n        // revert the cycle performed by the encode_cyclic function\n        if group.len() == 3 {\n            let x = format!(\"{}{}{}\", &group[2..3], &group[0..1], &group[1..2]);\n            output.push_str(&x);\n        } else {\n            output.push_str(group);\n        }\n    }\n    output\n}\n\npub fn encode_cyclic(s: &str) -> String {\n    // returns encoded string by cycling groups of three characters.\n    // split string to groups. Each of length 3.\n    let l = s.len();\n    let num = (l + 2) / 3;\n    let mut output = String::new();\n    for i in 0..num {\n        let group = &s[i * 3..std::cmp::min(l, (i + 1) * 3)];\n        // cycle elements in each group. Unless group has fewer elements than 3.\n        if group.len() == 3 {\n            let x = format!(\"{}{}{}\", &group[1..2], &group[2..3], &group[0..1]);\n            output.push_str(&x);\n        } else {\n            output.push_str(group);\n        }\n    }\n    output\n}\n\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n#[test]\n    fn test_decode_cyclic() {\n        for _ in 0..100 {\n            let l = 10 + rand::random::<u32>() % 11;\n            let mut str = String::new();\n            for _ in 0..l {\n                let chr = 97 + rand::random::<u32>() % 26;\n                str.push(chr as u8 as char);\n            }\n            let encoded_str = encode_cyclic(&str);\n            assert_eq!(decode_cyclic(&encoded_str), str);\n        }\n    }\n\n}\n", "example_test": "None", "prompt_text": "takes as input string encoded with encode_cyclic function. Returns decoded string.", "prompt_explain": "takes as input string encoded with encode_cyclic function. Returns decoded string.\n            assert_eq!(decode_cyclic(&encoded_str), str)", "func_title": "fn decode_cyclic(s: &str) -> String {\n\n", "prompt_text_chinese": "作为使用encode_cyclic函数编码的输入字符串。返回解码后的字符串。"}
{"task_id": "Rust/39", "prompt": "/*\n\n    prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn prime_fib(n: i32) -> i32 {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn prime_fib(n: i32) -> i32 {\n\n", "canonical_solution": "\n    let mut f1 = 1;\n    let mut f2 = 2;\n    let mut count = 0;\n    while count < n {\n        f1 = f1 + f2;\n        let m = f1;\n        f1 = f2;\n        f2 = m;\n        let mut isprime = true;\n        for w in 2..(f1 as f32).sqrt() as i32 + 1 {\n            if f1 % w == 0 {\n                isprime = false;\n                break;\n            }\n        }\n        if isprime {\n            count += 1;\n        }\n        if count == n {\n            return f1;\n        }\n    }\n    0\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n#[test]\n    fn test_prime_fib() {\n        assert_eq!(prime_fib(1), 2);\n        assert_eq!(prime_fib(2), 3);\n        assert_eq!(prime_fib(3), 5);\n        assert_eq!(prime_fib(4), 13);\n        assert_eq!(prime_fib(5), 89);\n        assert_eq!(prime_fib(6), 233);\n        assert_eq!(prime_fib(7), 1597);\n        assert_eq!(prime_fib(8), 28657);\n        assert_eq!(prime_fib(9), 514229);\n        assert_eq!(prime_fib(10), 433494437);\n    }\n\n}\n", "example_test": "None", "prompt_text": "prime_fib returns n-th number that is a Fibonacci number and it's also prime.", "prompt_explain": "prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n        assert_eq!(prime_fib(10), 433494437)", "func_title": "fn prime_fib(n: i32) -> i32 {\n\n", "prompt_text_chinese": "prime_fib返回第n个斐波那契数，也是素数。"}
{"task_id": "Rust/40", "prompt": "/*\n\n    triples_sum_to_zero takes a list of integers as an input.\n    it returns True if there are three distinct elements in the list that\n    sum to zero, and False otherwise.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn triples_sum_to_zero(nmbs:Vec<i32>) -> bool{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn triples_sum_to_zero(nmbs:Vec<i32>) -> bool{\n\n", "canonical_solution": "\n    for i in 0.. nmbs.len(){\n        for j in i + 1.. nmbs.len(){\n            for k in j + 1.. nmbs.len(){\n                if *nmbs.get(i).unwrap() + *nmbs.get(j).unwrap() + *nmbs.get(k).unwrap() == 0{\n                    return true;\n                }\n            }\n        }\n    }\nreturn false;\n\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n #[test]\n    fn test_triples_sum_to_zero() {\n        assert!(triples_sum_to_zero(vec![1, 3, 5, 0]) == false);\n        assert!(triples_sum_to_zero(vec![1, 3, 5, -1]) == false);\n        assert!(triples_sum_to_zero(vec![1, 3, -2, 1]) == true);\n        assert!(triples_sum_to_zero(vec![1, 2, 3, 7]) == false);\n        assert!(triples_sum_to_zero(vec![1, 2, 5, 7]) == false);\n        assert!(triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7]) == true);\n        assert!(triples_sum_to_zero(vec![1]) == false);\n        assert!(triples_sum_to_zero(vec![1, 3, 5, -100]) == false);\n        assert!(triples_sum_to_zero(vec![100, 3, 5, -100]) == false);\n    }\n\n}\n", "example_test": "None", "prompt_text": "triples_sum_to_zero takes a list of integers as an input. it returns True if there are three distinct elements in the list that sum to zero, and False otherwise. ", "prompt_explain": "triples_sum_to_zero takes a list of integers as an input. it returns True if there are three distinct elements in the list that sum to zero, and False otherwise. \n        assert!(triples_sum_to_zero(vec![100, 3, 5, -100]) == false)", "func_title": "fn triples_sum_to_zero(nmbs:Vec<i32>) -> bool{\n\n", "prompt_text_chinese": "Triples_sum_to_zero接受一个整数列表作为输入。如果列表中有三个不同的元素之和为0，则返回True，否则返回False。"}
{"task_id": "Rust/41", "prompt": "/*\n\n    Imagine a road that's a perfectly straight infinitely long line.\n    n cars are driving left to right;  simultaneously, a different set of n cars\n    are driving right to left.   The two sets of cars start out being very far from\n    each other.  All cars move in the same speed.  Two cars are said to collide\n    when a car that's moving left to right hits a car that's moving right to left.\n    However, the cars are infinitely sturdy and strong; as a result, they continue moving\n    in their trajectory as if they did not collide.\n\n    This function outputs the number of such collisions.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn car_race_collision(n:i32)-> i32{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn car_race_collision(n:i32)-> i32{\n\n", "canonical_solution": "\n    return n*n;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n #[test]\n    fn test_car_race_collision() {\n        assert!(car_race_collision(2) == 4);\n        assert!(car_race_collision(3) == 9);\n        assert!(car_race_collision(4) == 16);\n        assert!(car_race_collision(8) == 64);\n        assert!(car_race_collision(10) == 100);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Imagine a road that's a perfectly straight infinitely long line.\n    n cars are driving left to right;  simultaneously, a different set of n cars\n    are driving right to left.   The two sets of cars start out being very far from\n    each other.  All cars move in the same speed.  Two cars are said to collide\n    when a car that's moving left to right hits a car that's moving right to left.\n    However, the cars are infinitely sturdy and strong; as a result, they continue moving\n    in their trajectory as if they did not collide.\n\n    This function outputs the number of such collisions. ", "prompt_explain": "Imagine a road that's a perfectly straight infinitely long line.\n    n cars are driving left to right;  simultaneously, a different set of n cars\n    are driving right to left.   The two sets of cars start out being very far from\n    each other.  All cars move in the same speed.  Two cars are said to collide\n    when a car that's moving left to right hits a car that's moving right to left.\n    However, the cars are infinitely sturdy and strong; as a result, they continue moving\n    in their trajectory as if they did not collide.\n\n    This function outputs the number of such collisions. \n        assert!(car_race_collision(10) == 100)", "func_title": "fn car_race_collision(n:i32)-> i32{\n\n", "prompt_text_chinese": "想象一条无限长的直线。N辆车从左向右行驶;同时，另一组n辆车从右向左行驶。两组车一开始相距很远。所有的汽车都以相同的速度行驶。当一辆从左向右行驶的汽车撞上一辆从右向左行驶的汽车时，两辆汽车就会相撞。然而，汽车是无限坚固和强大;结果，它们继续沿着自己的轨道运动，就好像它们没有碰撞一样。这个函数输出这种碰撞的数量。"}
{"task_id": "Rust/42", "prompt": "/*\nReturn list with elements incremented by 1.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn incr_list(l:Vec<i32>) -> Vec<i32>{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn incr_list(l:Vec<i32>) -> Vec<i32>{\n\n", "canonical_solution": "\n    return l.into_iter().map(|n:i32| n + 1).collect();\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_incr_list() {\n        assert!(incr_list(vec![]) == vec![]);\n        assert!(incr_list(vec![3, 2, 1]) == [4, 3, 2]);\n        assert!(incr_list(vec![5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Return list with elements incremented by 1.", "prompt_explain": "Return list with elements incremented by 1.\n        assert!(incr_list(vec![5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])", "func_title": "fn incr_list(l:Vec<i32>) -> Vec<i32>{\n\n", "prompt_text_chinese": "返回元素加1的列表。"}
{"task_id": "Rust/43", "prompt": "/*\n\n    pairs_sum_to_zero takes a list of integers as an input.\n    it returns True if there are two distinct elements in the list that\n    sum to zero, and False otherwise.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn pairs_sum_to_zero(l:Vec<i32>) -> bool{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn pairs_sum_to_zero(l:Vec<i32>) -> bool{\n\n", "canonical_solution": "\n    for (i, l1) in l.iter().enumerate(){\n        for j in i + 1.. l.len(){\n            if l1 + l[j] == 0{\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_pairs_sum_to_zero() {\n        assert!(pairs_sum_to_zero(vec![1, 3, 5, 0]) == false);\n        assert!(pairs_sum_to_zero(vec![1, 3, -2, 1]) == false);\n        assert!(pairs_sum_to_zero(vec![1, 2, 3, 7]) == false);\n        assert!(pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7]) == true);\n        assert!(pairs_sum_to_zero(vec![1]) == false);\n        assert!(pairs_sum_to_zero(vec![-3, 9, -1, 3, 2, 30]) == true);\n        assert!(pairs_sum_to_zero(vec![-3, 9, -1, 3, 2, 31]) == true);\n        assert!(pairs_sum_to_zero(vec![-3, 9, -1, 4, 2, 30]) == false);\n        assert!(pairs_sum_to_zero(vec![-3, 9, -1, 4, 2, 31]) == false);\n    }\n\n}\n", "example_test": "None", "prompt_text": "pairs_sum_to_zero takes a list of integers as an input. it returns True if there are two distinct elements in the list that sum to zero, and False otherwise.", "prompt_explain": "pairs_sum_to_zero takes a list of integers as an input. it returns True if there are two distinct elements in the list that sum to zero, and False otherwise.\n        assert!(pairs_sum_to_zero(vec![-3, 9, -1, 4, 2, 31]) == false)", "func_title": "fn pairs_sum_to_zero(l:Vec<i32>) -> bool{\n\n", "prompt_text_chinese": "Pairs_sum_to_zero接受一个整数列表作为输入。如果列表中有两个不同的元素之和为0，则返回True，否则返回False。"}
{"task_id": "Rust/44", "prompt": "/*\nChange numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn change_base(x:i32, base:i32) -> String{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn change_base(x:i32, base:i32) -> String{\n\n", "canonical_solution": "\n    let mut ret:String = \"\".to_string();\n    let mut x1 = x;\n\n    while  x1 > 0{\n        ret = (x1 % base).to_string() + &ret;\n        x1 = x1 / base;\n    }\n    return ret;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_change_base() {\n        assert!(change_base(8, 3) == \"22\".to_string());\n        assert!(change_base(9, 3) == \"100\".to_string());\n        assert!(change_base(234, 2) == \"11101010\".to_string());\n        assert!(change_base(16, 2) == \"10000\".to_string());\n        assert!(change_base(8, 2) == \"1000\".to_string());\n        assert!(change_base(7, 2) == \"111\".to_string());\n    }\n\n}\n", "example_test": "None", "prompt_text": "Change numerical base of input number x to base. return string representation after the conversion. base numbers are less than 10.", "prompt_explain": "Change numerical base of input number x to base. return string representation after the conversion. base numbers are less than 10.\n        assert!(change_base(7, 2) == \"111\".to_string())", "func_title": "fn change_base(x:i32, base:i32) -> String{\n\n", "prompt_text_chinese": "将输入数字x的基数改为基数。转换后返回字符串表示形式。基数小于10。"}
{"task_id": "Rust/45", "prompt": "/*\n\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn triangle_area(a:i32, h:i32) -> f64{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn triangle_area(a:i32, h:i32) -> f64{\n\n", "canonical_solution": "\n    return (a * h) as f64 / 2.0;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_triangle_area() {\n        assert!(triangle_area(5, 3) == 7.5);\n        assert!(triangle_area(2, 2) == 2.0);\n        assert!(triangle_area(10, 8) == 40.0);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Given length of a side and high return area for a triangle.", "prompt_explain": "Given length of a side and high return area for a triangle.\n        assert!(triangle_area(10, 8) == 40.0)", "func_title": "fn triangle_area(a:i32, h:i32) -> f64{\n\n", "prompt_text_chinese": "给定三角形的边长和高返回面积。"}
{"task_id": "Rust/46", "prompt": "/*\nThe Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn fib4(n:i32) -> i32{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn fib4(n:i32) -> i32{\n\n", "canonical_solution": "\n    let mut results:Vec<i32> = vec![0, 0, 2, 0];\n\n    if n < 4 {\n        return *results.get(n as usize).unwrap();\n    }\n\n    for _ in 4.. n + 1{\n        results.push(results.get(results.len()-1).unwrap() + results.get(results.len()-2).unwrap()\n         + results.get(results.len()-3).unwrap() + results.get(results.len()-4).unwrap());\n        results.remove(0);\n    }\n\n    return *results.get(results.len()-1).unwrap();\n\n    \n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_fib4() {\n        assert!(fib4(5) == 4);\n        assert!(fib4(8) == 28);\n        assert!(fib4(10) == 104);\n        assert!(fib4(12) == 386);\n    }\n\n}\n", "example_test": "None", "prompt_text": "The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.", "prompt_explain": "The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n        assert!(fib4(12) == 386)", "func_title": "fn fib4(n:i32) -> i32{\n\n", "prompt_text_chinese": "Fib4数列与fibonacci数列类似，定义如下:Fib4 (0) -> 0 Fib4 (1) -> 0 Fib4 (2) -> 2 Fib4 (3) -> 0 Fib4 (n) -> Fib4 (n-1) + Fib4 (n-2) + Fib4 (n-3) + Fib4 (n-4)。请编写一个函数来有效地计算fib4数列的第n个元素。不要使用递归。"}
{"task_id": "Rust/47", "prompt": "/*\nReturn median of elements in the list l.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn median(l:Vec<i32>) -> f64{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn median(l:Vec<i32>) -> f64{\n\n", "canonical_solution": "\n    let mut res:Vec<i32> = l.clone();\n    res.sort();\n    if res.len() % 2 == 1{\n        return *res.get(res.len() / 2).unwrap() as f64;\n    }else{      \n        return (res.get(res.len() / 2 -1).unwrap() + res.get(res.len() / 2).unwrap()) as f64/ 2.0;\n    }\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_median() {\n        assert!(median(vec![3, 1, 2, 4, 5]) == 3.0);\n        assert!(median(vec![-10, 4, 6, 1000, 10, 20]) == 8.0);\n        assert!(median(vec![5]) == 5.0);\n        assert!(median(vec![6, 5]) == 5.5);\n        assert!(median(vec![8, 1, 3, 9, 9, 2, 7]) == 7.0);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Return median of elements in the list l.", "prompt_explain": "Return median of elements in the list l.\n        assert!(median(vec![8, 1, 3, 9, 9, 2, 7]) == 7.0)", "func_title": "fn median(l:Vec<i32>) -> f64{\n\n", "prompt_text_chinese": "返回列表l中元素的中值。"}
{"task_id": "Rust/48", "prompt": "/*\n\n    Checks if given string is a palindrome\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn is_palindrome(text: String) -> bool {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn is_palindrome(text: String) -> bool {\n\n", "canonical_solution": "\n    let pr: String = text.chars().rev().collect();\n    return pr == text;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n\n    #[test]\n    fn test_is_palindrome() {\n        assert!(is_palindrome(\"\".to_string()) == true);\n        assert!(is_palindrome(\"aba\".to_string()) == true);\n        assert!(is_palindrome(\"aaaaa\".to_string()) == true);\n        assert!(is_palindrome(\"zbcd\".to_string()) == false);\n        assert!(is_palindrome(\"xywyx\".to_string()) == true);\n        assert!(is_palindrome(\"xywyz\".to_string()) == false);\n        assert!(is_palindrome(\"xywzx\".to_string()) == false);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Checks if given string is a palindrome", "prompt_explain": "Checks if given string is a palindrome\n        assert!(is_palindrome(\"xywzx\".to_string()) == false)", "func_title": "fn is_palindrome(text: String) -> bool {\n\n", "prompt_text_chinese": "检查给定的字符串是否为回文"}
{"task_id": "Rust/49", "prompt": "/*\nReturn 2^n modulo p (be aware of numerics).\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn modp(n: i32, p: i32) -> i32 {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn modp(n: i32, p: i32) -> i32 {\n\n", "canonical_solution": "\n    if n == 0 {\n        return 1;\n    } else {\n        return (modp(n - 1, p) * 2) % p;\n    }\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_modp() {\n        assert!(modp(3, 5) == 3);\n        assert!(modp(1101, 101) == 2);\n        assert!(modp(0, 101) == 1);\n        assert!(modp(3, 11) == 8);\n        assert!(modp(100, 101) == 1);\n        assert!(modp(30, 5) == 4);\n        assert!(modp(31, 5) == 3);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Return 2^n modulo p (be aware of numerics).", "prompt_explain": "Return 2^n modulo p (be aware of numerics).\n        assert!(modp(31, 5) == 3)", "func_title": "fn modp(n: i32, p: i32) -> i32 {\n\n", "prompt_text_chinese": "返回2^n模p(注意数字)。"}
{"task_id": "Rust/50", "prompt": "/*\n\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn encode_shift(s: &str) -> String {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn encode_shift(s: &str) -> String {\n\n", "canonical_solution": "\n    let alphabet:Vec<&str> = vec![\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"\n    , \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut output = String::new();\n\n    for c in s.chars() {\n        let mut lower = false;\n        if c.is_ascii_lowercase(){\n            lower = true;\n        }\n        let mut c_shift:String = \"\".to_string();\n        if lower {\n            let index:usize = alphabet.iter().position(|&x| x == c.to_string()).unwrap();\n            c_shift = alphabet[(index + 5) % 26].to_string();\n        }else{\n            let c_lower:String = c.to_ascii_lowercase().to_string();\n            let index:usize = alphabet.iter().position(|&x| x == c_lower).unwrap();\n            c_shift = alphabet[(index + 5) % 26].to_string();\n            c_shift = c_shift.to_ascii_uppercase().to_string();\n            \n        }\n\n        output.push_str(&c_shift);\n    }\n    output\n}\n\npub fn decode_shift(s: &str) -> String {\n    let alphabet:Vec<&str> = vec![\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"\n    , \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut output = String::new();\n\n    for c in s.chars() {\n        let mut lower = false;\n        if c.is_ascii_lowercase(){\n            lower = true;\n        }\n        let mut c_shift:String = \"\".to_string();\n        if lower {\n            let index:usize = alphabet.iter().position(|&x| x == c.to_string()).unwrap();\n            c_shift = alphabet[((26 + (index as i32 - 5)) % 26) as usize].to_string();\n        }else{\n            let c_lower:String = c.to_ascii_lowercase().to_string();\n            let index:usize = alphabet.iter().position(|&x| x == c_lower).unwrap();\n            c_shift = alphabet[((26 + (index as i32 - 5)) % 26) as usize].to_string();\n            c_shift = c_shift.to_ascii_uppercase().to_string();\n            \n        }\n\n        output.push_str(&c_shift);\n    }\n    output\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n#[test]\n    //Imposing that random characters that can be generated are solely from the alphabet\n    fn test_decode_encode() {\n        fn random_char() -> char {\n            let mut rng = rand::thread_rng();\n            let letter: char = match rng.gen_range(0, 2) {\n                0 => rng.gen_range(b'a', b'z' + 1).into(),\n                1 => rng.gen_range(b'A', b'Z' + 1).into(),\n                _ => unreachable!(),\n            };\n            return letter;\n        }\n\n        let mut rng = rand::thread_rng();\n        for _ in 0..100 {\n            let r1: i32 = rng.gen();\n            let l: i32 = 10 + r1 % 11;\n            let mut str: String = \"\".to_string();\n\n            for _ in 0..l {\n                let chr: char = random_char();\n                println!(\"{}\", chr);\n                str.push(chr);\n            }\n\n            let encoded_str: String = encode_shift(&str);\n            assert!(decode_shift(&encoded_str) == str);\n        }\n    }\n\n}\n", "example_test": "None", "prompt_text": "takes as input string encoded with encode_shift function. Returns decoded string.", "prompt_explain": "takes as input string encoded with encode_shift function. Returns decoded string.\n            assert!(decode_shift(&encoded_str) == str)", "func_title": "fn encode_shift(s: &str) -> String {\n\n", "prompt_text_chinese": "接受用encode_shift函数编码的输入字符串。返回解码后的字符串。"}
{"task_id": "Rust/51", "prompt": "/*\n\n    remove_vowels is a function that takes string and returns string without vowels.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn remove_vowels(text: &str) -> String {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn remove_vowels(text: &str) -> String {\n\n", "canonical_solution": "\n    let vowels = \"AEIOUaeiou\";\n    let mut out = String::new();\n    for c in text.chars() {\n        if !vowels.contains(c) {\n            out.push(c);\n        }\n    }\n    out\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_remove_vowels() {\n        assert!(remove_vowels(\"\") == \"\");\n        assert!(remove_vowels(\"abcdef\\nghijklm\") == \"bcdf\\nghjklm\");\n        assert!(remove_vowels(\"fedcba\") == \"fdcb\");\n        assert!(remove_vowels(\"eeeee\") == \"\");\n        assert!(remove_vowels(\"acBAA\") == \"cB\");\n        assert!(remove_vowels(\"EcBOO\") == \"cB\");\n        assert!(remove_vowels(\"ybcd\") == \"ybcd\");\n    }\n\n}\n", "example_test": "None", "prompt_text": "remove_vowels is a function that takes string and returns string without vowels.", "prompt_explain": "remove_vowels is a function that takes string and returns string without vowels.\n        assert!(remove_vowels(\"ybcd\") == \"ybcd\")", "func_title": "fn remove_vowels(text: &str) -> String {\n\n", "prompt_text_chinese": "Remove_vowels是一个函数，它接受字符串并返回不带元音的字符串。"}
{"task_id": "Rust/52", "prompt": "/*\nReturn True if all numbers in the list l are below threshold t.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn below_threshold(l: Vec<i32>, t: i32) -> bool { \n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn below_threshold(l: Vec<i32>, t: i32) -> bool { \n\n", "canonical_solution": "\n    for i in l {\n        if i >= t {\n            return false;\n        }\n    }\n    return true;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_below_threshold() {\n        assert!(below_threshold(vec![1, 2, 4, 10], 100));\n        assert!(!below_threshold(vec![1, 20, 4, 10], 5));\n        assert!(below_threshold(vec![1, 20, 4, 10], 21));\n        assert!(below_threshold(vec![1, 20, 4, 10], 22));\n        assert!(below_threshold(vec![1, 8, 4, 10], 11));\n        assert!(!below_threshold(vec![1, 8, 4, 10], 10));\n    }\n\n}\n", "example_test": "None", "prompt_text": "Return True if all numbers in the list l are below threshold t.", "prompt_explain": "Return True if all numbers in the list l are below threshold t.\n        assert!(!below_threshold(vec![1, 8, 4, 10], 10))", "func_title": "fn below_threshold(l: Vec<i32>, t: i32) -> bool { \n\n", "prompt_text_chinese": "如果列表l中的所有数字都低于阈值t，则返回True。"}
{"task_id": "Rust/53", "prompt": "/*\nAdd two numbers x and y\n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn add(x:i32, y:i32) -> i32{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn add(x:i32, y:i32) -> i32{\n\n", "canonical_solution": "\n    return x + y;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_add() {\n        assert!(add(0, 1) == 1);\n        assert!(add(1, 0) == 1);\n        assert!(add(2, 3) == 5);\n        assert!(add(5, 7) == 12);\n        assert!(add(7, 5) == 12);\n        for _ in 0..100 {\n            let mut rng = rand::thread_rng();\n            let mut x: i32 = rng.gen();\n            x = x % 1000;\n            let mut y: i32 = rng.gen();\n            y = y % 1000;\n\n            assert!(add(x, y) == x + y);\n        }\n    }\n\n}\n", "example_test": "None", "prompt_text": "Add two numbers x and y", "prompt_explain": "Add two numbers x and y\n\n            assert!(add(x, y) == x + y)", "func_title": "fn add(x:i32, y:i32) -> i32{\n\n", "prompt_text_chinese": "把x和y两个数相加"}
{"task_id": "Rust/54", "prompt": "/*\n\n    Check if two words have the same characters.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn same_chars(str1:&str, str2:&str) -> bool{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn same_chars(str1:&str, str2:&str) -> bool{\n\n", "canonical_solution": "\n    let mut v1:Vec<char> = str1.chars().into_iter().collect();\n    v1.sort();\n    v1.dedup();\n\n    let mut v2:Vec<char> = str2.chars().into_iter().collect();\n    v2.sort();\n    v2.dedup();\n\n    return v1 == v2;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n\n    #[test]\n    fn test_same_chars() {\n        assert!(same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\") == true);\n        assert!(same_chars(\"abcd\", \"dddddddabc\") == true);\n        assert!(same_chars(\"dddddddabc\", \"abcd\") == true);\n        assert!(same_chars(\"eabcd\", \"dddddddabc\") == false);\n        assert!(same_chars(\"abcd\", \"dddddddabcf\") == false);\n        assert!(same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\") == false);\n        assert!(same_chars(\"aabb\", \"aaccc\") == false);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Check if two words have the same characters.", "prompt_explain": "Check if two words have the same characters.\n        assert!(same_chars(\"aabb\", \"aaccc\") == false)", "func_title": "fn same_chars(str1:&str, str2:&str) -> bool{\n\n", "prompt_text_chinese": "检查两个单词是否有相同的字符。"}
{"task_id": "Rust/55", "prompt": "/*\nReturn n-th Fibonacci number.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn fib(n:i32) -> i32{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn fib(n:i32) -> i32{\n\n", "canonical_solution": "\n    if n == 0{\n        return 0;\n    }\n    if n == 1{\n        return 1;\n    }\n\n    return fib(n-1) + fib(n-2);\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_fib() {\n        assert!(fib(10) == 55);\n        assert!(fib(1) == 1);\n        assert!(fib(8) == 21);\n        assert!(fib(11) == 89);\n        assert!(fib(12) == 144);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Return n-th Fibonacci number.", "prompt_explain": "Return n-th Fibonacci number.\n        assert!(fib(12) == 144)", "func_title": "fn fib(n:i32) -> i32{\n\n", "prompt_text_chinese": "返回第n个斐波那契数。"}
{"task_id": "Rust/56", "prompt": "/*\n brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn correct_bracketing(bkts:&str) -> bool{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn correct_bracketing(bkts:&str) -> bool{\n\n", "canonical_solution": "\n    let mut level:i32=0;\n\n    for i in 0..bkts.len(){\n\n        if bkts.chars().nth(i).unwrap()== '<' {level+=1;}\n        \n        if bkts.chars().nth(i).unwrap() == '>' {  level-=1;}\n      \n        if level<0 {return false;} \n    }\n    if level!=0 {return false;}\n    return true;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_correct_bracketing() {\n        assert!(correct_bracketing(\"<>\"));\n        assert!(correct_bracketing(\"<<><>>\"));\n        assert!(correct_bracketing(\"<><><<><>><>\"));\n        assert!(correct_bracketing(\"<><><<<><><>><>><<><><<>>>\"));\n        assert!(!(correct_bracketing(\"<<<><>>>>\")));\n        assert!(!(correct_bracketing(\"><<>\")));\n        assert!(!(correct_bracketing(\"<\")));\n        assert!(!(correct_bracketing(\"<<<<\")));\n        assert!(!(correct_bracketing(\">\")));\n        assert!(!(correct_bracketing(\"<<>\")));\n        assert!(!(correct_bracketing(\"<><><<><>><>><<>\")));\n        assert!(!(correct_bracketing(\"<><><<><>><>>><>\")));\n    }\n\n}\n", "example_test": "None", "prompt_text": "brackets is a string of \"<\" and \">\". return True if every opening bracket has a corresponding closing bracket. ", "prompt_explain": "brackets is a string of \"<\" and \">\". return True if every opening bracket has a corresponding closing bracket. \n        assert!(!(correct_bracketing(\"<><><<><>><>>><>\")))", "func_title": "fn correct_bracketing(bkts:&str) -> bool{\n\n", "prompt_text_chinese": "括号是由\"<\"和\">\"组成的字符串。如果每个左括号都有对应的右括号，则返回True。"}
{"task_id": "Rust/57", "prompt": "/*\nReturn True is list elements are monotonically increasing or decreasing.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn monotonic( l:Vec<i32>) -> bool{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn monotonic( l:Vec<i32>) -> bool{\n\n", "canonical_solution": "\n    let mut l1:Vec<i32> = l.clone();\n    let mut l2:Vec<i32> = l.clone();\n    l2.sort(); l2.reverse();\n    l1.sort();\n\n    if  l == l1 || l == l2 {return true}\n    return false;\n\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_monotonic() {\n        assert!(monotonic(vec![1, 2, 4, 10]) == true);\n        assert!(monotonic(vec![1, 2, 4, 20]) == true);\n        assert!(monotonic(vec![1, 20, 4, 10]) == false);\n        assert!(monotonic(vec![4, 1, 0, -10]) == true);\n        assert!(monotonic(vec![4, 1, 1, 0]) == true);\n        assert!(monotonic(vec![1, 2, 3, 2, 5, 60]) == false);\n        assert!(monotonic(vec![1, 2, 3, 4, 5, 60]) == true);\n        assert!(monotonic(vec![9, 9, 9, 9]) == true);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Return True is list elements are monotonically increasing or decreasing.", "prompt_explain": "Return True is list elements are monotonically increasing or decreasing.\n        assert!(monotonic(vec![9, 9, 9, 9]) == true)", "func_title": "fn monotonic( l:Vec<i32>) -> bool{\n\n", "prompt_text_chinese": "返回True表示列表元素是单调递增或递减的。"}
{"task_id": "Rust/58", "prompt": "/*\nReturn sorted unique common elements for two lists.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn common(l1:Vec<i32>, l2:Vec<i32>) -> Vec<i32>{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn common(l1:Vec<i32>, l2:Vec<i32>) -> Vec<i32>{\n\n", "canonical_solution": "\nlet mut res:Vec<i32> = l1.into_iter().filter(|n:&i32| l2.contains(n)).collect();\nres.sort();\nreturn res;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_common() {\n        assert!(\n            common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]) == vec![1, 5, 653]\n        );\n        assert!(common(vec![5, 3, 2, 8], vec![3, 2]) == vec![2, 3]);\n        assert!(common(vec![4, 3, 2, 8], vec![3, 2, 4]) == vec![2, 3, 4]);\n        assert!(common(vec![4, 3, 2, 8], vec![]) == vec![]);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Return sorted unique common elements for two lists.", "prompt_explain": "Return sorted unique common elements for two lists.\n        assert!(common(vec![4, 3, 2, 8], vec![]) == vec![])", "func_title": "fn common(l1:Vec<i32>, l2:Vec<i32>) -> Vec<i32>{\n\n", "prompt_text_chinese": "为两个列表返回已排序的唯一公共元素。"}
{"task_id": "Rust/59", "prompt": "/*\nReturn the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn largest_prime_factor(n:i32) -> i32{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn largest_prime_factor(n:i32) -> i32{\n\n", "canonical_solution": "\n    let mut n1 = n.clone();\n    for i in 2.. n1{\n        while n1%i == 0 && n1>i{n1 = n1/i;}\n    }\n    return n1;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_largest_prime_factor() {\n        assert!(largest_prime_factor(15) == 5);\n        assert!(largest_prime_factor(27) == 3);\n        assert!(largest_prime_factor(63) == 7);\n        assert!(largest_prime_factor(330) == 11);\n        assert!(largest_prime_factor(13195) == 29);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Return the largest prime factor of n. Assume n > 1 and is not a prime.", "prompt_explain": "Return the largest prime factor of n. Assume n > 1 and is not a prime.\n        assert!(largest_prime_factor(13195) == 29)", "func_title": "fn largest_prime_factor(n:i32) -> i32{\n\n", "prompt_text_chinese": "返回n的最大素数因子。假设n > 1不是素数。"}
{"task_id": "Rust/60", "prompt": "/*\nsum_to_n is a function that sums numbers from 1 to n.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn sum_to_n(n: i32) -> i32 {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn sum_to_n(n: i32) -> i32 {\n\n", "canonical_solution": "\n    n*(n+1)/2\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_sum_to_n() {\n        assert!(sum_to_n(1) == 1);\n        assert!(sum_to_n(6) == 21);\n        assert!(sum_to_n(11) == 66);\n        assert!(sum_to_n(30) == 465);\n        assert!(sum_to_n(100) == 5050);\n    }\n\n}\n", "example_test": "None", "prompt_text": "sum_to_n is a function that sums numbers from 1 to n.", "prompt_explain": "sum_to_n is a function that sums numbers from 1 to n.\n        assert!(sum_to_n(100) == 5050)", "func_title": "fn sum_to_n(n: i32) -> i32 {\n\n", "prompt_text_chinese": "Sum_to_n是一个从1到n求和的函数。"}
{"task_id": "Rust/61", "prompt": "/*\n brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn correct_bracketing_parenthesis(bkts:&str) -> bool{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn correct_bracketing_parenthesis(bkts:&str) -> bool{\n\n", "canonical_solution": "\n    let mut level:i32=0;\n\n    for i in 0..bkts.len(){\n\n        if bkts.chars().nth(i).unwrap()== '(' {level+=1;}\n        \n        if bkts.chars().nth(i).unwrap() == ')' {  level-=1;}\n        \n        if level<0 {return false;} \n    }\n    if level!=0 {return false;}\n    return true;\n    }\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_correct_bracketing_parenthesis() {\n        assert!(correct_bracketing_parenthesis(\"()\"));\n        assert!(correct_bracketing_parenthesis(\"(()())\"));\n        assert!(correct_bracketing_parenthesis(\"()()(()())()\"));\n        assert!(correct_bracketing_parenthesis(\"()()((()()())())(()()(()))\"));\n        assert!(!(correct_bracketing_parenthesis(\"((()())))\")));\n        assert!(!(correct_bracketing_parenthesis(\")(()\")));\n        assert!(!(correct_bracketing_parenthesis(\"(\")));\n        assert!(!(correct_bracketing_parenthesis(\"((((\")));\n        assert!(!(correct_bracketing_parenthesis(\")\")));\n        assert!(!(correct_bracketing_parenthesis(\"(()\")));\n        assert!(!(correct_bracketing_parenthesis(\"()()(()())())(()\")));\n        assert!(!(correct_bracketing_parenthesis(\"()()(()())()))()\")));\n    }\n\n}\n", "example_test": "None", "prompt_text": "brackets is a string of \"(\" and \")\". return True if every opening bracket has a corresponding closing bracket. ", "prompt_explain": "brackets is a string of \"(\" and \")\". return True if every opening bracket has a corresponding closing bracket. \n        assert!(!(correct_bracketing_parenthesis(\"()()(()())()))()\")))", "func_title": "fn correct_bracketing_parenthesis(bkts:&str) -> bool{\n\n", "prompt_text_chinese": "括号是由\"(\"和\")\"组成的字符串。如果每个左括号都有对应的右括号，则返回True。"}
{"task_id": "Rust/62", "prompt": "/*\n xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn derivative(xs:Vec<i32>) -> Vec<i32>{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn derivative(xs:Vec<i32>) -> Vec<i32>{\n\n", "canonical_solution": "\n    let mut res:Vec<i32> =vec![];\n    for i in 1..xs.len(){\n        res.push(i as i32 * xs.get(i).unwrap());\n    }\n    return res;\n\n} \n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_derivative() {\n        assert!(derivative(vec![3, 1, 2, 4, 5]) == vec![1, 4, 12, 20]);\n        assert!(derivative(vec![1, 2, 3]) == vec![2, 6]);\n        assert!(derivative(vec![3, 2, 1]) == vec![2, 2]);\n        assert!(derivative(vec![3, 2, 1, 0, 4]) == vec![2, 2, 0, 16]);\n        assert!(derivative(vec![1]) == vec![]);\n    }\n\n}\n", "example_test": "None", "prompt_text": "xs represent coefficients of a polynomial. xs[0] + xs[1] * x + xs[2] * x^2 + .... Return derivative of this polynomial in the same form.", "prompt_explain": "xs represent coefficients of a polynomial. xs[0] + xs[1] * x + xs[2] * x^2 + .... Return derivative of this polynomial in the same form.\n        assert!(derivative(vec![1]) == vec![])", "func_title": "fn derivative(xs:Vec<i32>) -> Vec<i32>{\n\n", "prompt_text_chinese": "x表示多项式的系数。Xs [0] + Xs [1] * x + Xs [2] * x^2 + ....以同样的形式返回这个多项式的导数。"}
{"task_id": "Rust/63", "prompt": "/*\nThe FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn fibfib(n:i32) -> i32{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn fibfib(n:i32) -> i32{\n\n", "canonical_solution": "\n    if n == 0 || n == 1{\n        return 0;\n    }\n    if n == 2{\n        return 1;\n    }\n\n    return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n #[test]\n    fn test_fibfib() {\n        assert!(fibfib(2) == 1);\n        assert!(fibfib(1) == 0);\n        assert!(fibfib(5) == 4);\n        assert!(fibfib(8) == 24);\n        assert!(fibfib(10) == 81);\n        assert!(fibfib(12) == 274);\n        assert!(fibfib(14) == 927);\n    }\n\n}\n", "example_test": "None", "prompt_text": "The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). Please write a function to efficiently compute the n-th element of the fibfib number sequence.", "prompt_explain": "The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n        assert!(fibfib(14) == 927)", "func_title": "fn fibfib(n:i32) -> i32{\n\n", "prompt_text_chinese": "FibFib数列与fibonacci数列类似，定义如下:FibFib (0) == 0 FibFib (1) == 0 FibFib (2) == 1 FibFib (n) == FibFib (n-1) + FibFib (n-2) + FibFib (n-3)。请编写一个函数来有效地计算fibfib数列的第n个元素。"}
{"task_id": "Rust/64", "prompt": "/*\nWrite a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn vowels_count(s:&str) -> i32 {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn vowels_count(s:&str) -> i32 {\n\n", "canonical_solution": "\n    let vowels:&str = \"aeiouAEIOU\";\n    let mut count:i32 = 0;\n\n    for i in 0..s.len() {\n       let c:char = s.chars().nth(i).unwrap();\n       if vowels.contains(c){\n        count += 1;\n       } \n    }\n    if s.chars().nth(s.len() -1).unwrap() == 'y' || s.chars().nth(s.len() -1).unwrap() == 'Y' {count+=1;}\n\n    return count;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n #[test]\n    fn test_vowels_count() {\n        assert!(vowels_count(\"abcde\") == 2);\n        assert!(vowels_count(\"Alone\") == 3);\n        assert!(vowels_count(\"key\") == 2);\n        assert!(vowels_count(\"bye\") == 1);\n        assert!(vowels_count(\"keY\") == 2);\n        assert!(vowels_count(\"bYe\") == 1);\n        assert!(vowels_count(\"ACEDY\") == 3);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Write a function vowels_count which takes a string representing a word as input and returns the number of vowels in the string. Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a vowel, but only when it is at the end of the given word.  Example:", "prompt_explain": "Write a function vowels_count which takes a string representing a word as input and returns the number of vowels in the string. Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a vowel, but only when it is at the end of the given word.  Example:\n        assert!(vowels_count(\"ACEDY\") == 3)", "func_title": "fn vowels_count(s:&str) -> i32 {\n\n", "prompt_text_chinese": "编写一个函数vowels_count，它接受一个表示单词的字符串作为输入，并返回字符串中元音的数量。元音字母“a”在这种情况下,‘e’,‘我’,‘o’,‘u’。在这里，“y”也是一个元音，但只有当它位于给定单词的末尾时。"}
{"task_id": "Rust/65", "prompt": "/*\nCircular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn circular_shift(x:i32, shift:i32) -> String{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn circular_shift(x:i32, shift:i32) -> String{\n\n", "canonical_solution": "\n    let mut xcp:Vec<char> = x.to_string().chars().into_iter().collect();\n    let mut res:Vec<char> = x.to_string().chars().into_iter().collect();\n\n    for (indx,c) in xcp.iter().enumerate(){\n    let despl =  (indx as i32 + shift) % x.to_string().len() as i32;\n    replace(&mut res[despl as usize], *c);\n    }\n\n   return res.into_iter().collect();\n\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n #[test]\n    fn test_circular_shift() {\n        assert!(circular_shift(100, 2) == \"001\");\n        assert!(circular_shift(12, 8) == \"12\");\n        // original test   asert (circular_shift(97, 8) == \"79\"); DATASET ERROR\n        assert!(circular_shift(97, 8) == \"97\");\n        assert!(circular_shift(12, 1) == \"21\");\n        assert!(circular_shift(11, 101) == \"11\");\n    }\n\n}\n", "example_test": "None", "prompt_text": "Circular shift the digits of the integer x, shift the digits right by shift and return the result as a string. If shift > number of digits, return digits reversed.", "prompt_explain": "Circular shift the digits of the integer x, shift the digits right by shift and return the result as a string. If shift > number of digits, return digits reversed.\n        assert!(circular_shift(11, 101) == \"11\")", "func_title": "fn circular_shift(x:i32, shift:i32) -> String{\n\n", "prompt_text_chinese": "对整数x的数字进行循环移位，将数字逐shift右移，并将结果作为字符串返回。如果shift >位数，则返回颠倒的数字。"}
{"task_id": "Rust/66", "prompt": "/*\nTask\n    Write a function that takes a string as input and returns the sum of the upper characters only'\n    ASCII codes.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn digitSum(s:&str) -> i32{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn digitSum(s:&str) -> i32{\n\n", "canonical_solution": "\n    return s.chars().into_iter().filter(|c:&char| c.is_uppercase()).map(|c:char| c as i32).sum();\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_digitSum() {\n        assert!(digitSum(\"\") == 0);\n        assert!(digitSum(\"abAB\") == 131);\n        assert!(digitSum(\"abcCd\") == 67);\n        assert!(digitSum(\"helloE\") == 69);\n        assert!(digitSum(\"woArBld\") == 131);\n        assert!(digitSum(\"aAaaaXa\") == 153);\n        assert!(digitSum(\" How are yOu?\") == 151);\n        assert!(digitSum(\"You arE Very Smart\") == 327);\n    }\n\n\n}\n", "example_test": "None", "prompt_text": "Task\n    Write a function that takes a string as input and returns the sum of the upper characters only'\n    ASCII codes.", "prompt_explain": "Task\n    Write a function that takes a string as input and returns the sum of the upper characters only'\n    ASCII codes.\n        assert!(digitSum(\"You arE Very Smart\") == 327)", "func_title": "fn digitSum(s:&str) -> i32{\n\n", "prompt_text_chinese": "编写一个函数，该函数接受字符串作为输入，并返回上面字符的和，只返回ASCII码。"}
{"task_id": "Rust/67", "prompt": "/*\n\n    In this task, you will be given a string that represents a number of apples and oranges \n    that are distributed in a basket of fruit this basket contains \n    apples, oranges, and mango fruits. Given the string that represents the total number of \n    the oranges and apples and an integer that represent the total number of the fruits \n    in the basket return the number of the mango fruits in the basket.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn fruit_distribution(s:&str, n:i32) -> i32 {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn fruit_distribution(s:&str, n:i32) -> i32 {\n\n", "canonical_solution": "\n    let sub:i32 = s.split_ascii_whitespace().into_iter().filter(|c| c.parse::<i32>().is_ok()).map(|c| c.parse::<i32>().unwrap()).sum();\n    return n-sub;\n}\n\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_fruit_distribution() {\n        assert!(fruit_distribution(\"5 apples and 6 oranges\", 19) == 8);\n        assert!(fruit_distribution(\"5 apples and 6 oranges\", 21) == 10);\n        assert!(fruit_distribution(\"0 apples and 1 oranges\", 3) == 2);\n        assert!(fruit_distribution(\"1 apples and 0 oranges\", 3) == 2);\n        assert!(fruit_distribution(\"2 apples and 3 oranges\", 100) == 95);\n        assert!(fruit_distribution(\"2 apples and 3 oranges\", 5) == 0);\n        assert!(fruit_distribution(\"1 apples and 100 oranges\", 120) == 19);\n    }\n\n\n}\n", "example_test": "None", "prompt_text": "In this task, you will be given a string that represents a number of apples and oranges \n    that are distributed in a basket of fruit this basket contains \n    apples, oranges, and mango fruits. Given the string that represents the total number of \n    the oranges and apples and an integer that represent the total number of the fruits \n    in the basket return the number of the mango fruits in the basket.", "prompt_explain": "In this task, you will be given a string that represents a number of apples and oranges \n    that are distributed in a basket of fruit this basket contains \n    apples, oranges, and mango fruits. Given the string that represents the total number of \n    the oranges and apples and an integer that represent the total number of the fruits \n    in the basket return the number of the mango fruits in the basket.\n        assert!(fruit_distribution(\"1 apples and 100 oranges\", 120) == 19)", "func_title": "fn fruit_distribution(s:&str, n:i32) -> i32 {\n\n", "prompt_text_chinese": "在这个任务中，你会得到一个字符串，它代表了苹果和橘子的数量，这些苹果和橘子分布在一个水果篮子里，这个篮子里有苹果、橘子和芒果。给定一个表示橘子和苹果总数的字符串和一个表示篮子中水果总数的整数，返回篮子中芒果水果的数量。"}
{"task_id": "Rust/68", "prompt": "/*\n\n    \"Given an array representing a branch of a tree that has non-negative integer nodes\n    your task is to pluck one of the nodes and return it.\n    The plucked node should be the node with the smallest even value.\n    If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n    The plucked node should be returned in a list, [ smalest_value, its index ],\n    If there are no even values or the given array is empty, return [].\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn pluck(arr:Vec<i32>) -> Vec<i32> {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn pluck(arr:Vec<i32>) -> Vec<i32> {\n\n", "canonical_solution": "\n    let mut out:Vec<i32> = vec![];\n\n    for i in 0.. arr.len(){\n        if arr[i]%2 == 0 && (out.len() == 0 || arr[i]<out[0]){\n        out = vec![arr[i], i as i32];\n        }\n       \n    }\n    return out;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_pluck() {\n        assert!(pluck(vec![4, 2, 3]) == vec![2, 1]);\n        assert!(pluck(vec![1, 2, 3]) == vec![2, 1]);\n        assert!(pluck(vec![]) == vec![]);\n        assert!(pluck(vec![5, 0, 3, 0, 4, 2]) == vec![0, 1]);\n        assert!(pluck(vec![1, 2, 3, 0, 5, 3]) == vec![0, 3]);\n        assert!(pluck(vec![5, 4, 8, 4, 8]) == vec![4, 1]);\n        assert!(pluck(vec![7, 6, 7, 1]) == vec![6, 1]);\n        assert!(pluck(vec![7, 9, 7, 1]) == vec![]);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Given an array representing a branch of a tree that has non-negative integer nodes\n    your task is to pluck one of the nodes and return it.\n    The plucked node should be the node with the smallest even value.\n    If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n    The plucked node should be returned in a list, [ smalest_value, its index ],\n    If there are no even values or the given array is empty, return [].", "prompt_explain": "Given an array representing a branch of a tree that has non-negative integer nodes\n    your task is to pluck one of the nodes and return it.\n    The plucked node should be the node with the smallest even value.\n    If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n    The plucked node should be returned in a list, [ smalest_value, its index ],\n    If there are no even values or the given array is empty, return [].\n        assert!(pluck(vec![7, 9, 7, 1]) == vec![])", "func_title": "fn pluck(arr:Vec<i32>) -> Vec<i32> {\n\n", "prompt_text_chinese": "“给定一个表示具有非负整数节点的树的分支的数组，您的任务是提取其中一个节点并返回它。选中的节点应该是偶数值最小的节点。如果找到多个具有相同最小偶数值的节点，则返回索引最小的节点。选中的节点应该以列表[smallest_value，其索引]的形式返回，如果没有偶数值或给定数组为空，则返回[]。"}
{"task_id": "Rust/69", "prompt": "/*\n\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn search(lst: Vec<i32>) -> i32 {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn search(lst: Vec<i32>) -> i32 {\n\n", "canonical_solution": "\n    let mut freq: Vec<Vec<i32>> = Vec::new();\n    let mut max = -1;\n    for i in 0..lst.len() {\n        let mut has = false;\n        for j in 0..freq.len() {\n            if lst[i] == freq[j][0] {\n                freq[j][1] += 1;\n                has = true;\n                if freq[j][1] >= freq[j][0] && freq[j][0] > max {\n                    max = freq[j][0];\n                }\n            }\n        }\n        if !has {\n            freq.push(vec![lst[i], 1]);\n            if max == -1 && lst[i] == 1 {\n                max = 1;\n            }\n        }\n    }\n    return max;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_search() {\n        assert!(search(vec![5, 5, 5, 5, 1]) == 1);\n        assert!(search(vec![4, 1, 4, 1, 4, 4]) == 4);\n        assert!(search(vec![3, 3]) == -1);\n        assert!(search(vec![8, 8, 8, 8, 8, 8, 8, 8]) == 8);\n        assert!(search(vec![2, 3, 3, 2, 2]) == 2);\n        assert!(\n            search(vec![\n                2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1\n            ]) == 1\n        );\n        assert!(search(vec![3, 2, 8, 2]) == 2);\n        assert!(search(vec![6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1);\n        assert!(search(vec![8, 8, 3, 6, 5, 6, 4]) == -1);\n        assert!(\n            search(vec![\n                6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9\n            ]) == 1\n        );\n        assert!(search(vec![1, 9, 10, 1, 3]) == 1);\n        assert!(\n            search(vec![\n                6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10\n            ]) == 5\n        );\n        assert!(search(vec![1]) == 1);\n        assert!(\n            search(vec![\n                8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5\n            ]) == 4\n        );\n        assert!(\n            search(vec![\n                2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10\n            ]) == 2\n        );\n        assert!(search(vec![1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1);\n        assert!(\n            search(vec![\n                9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8,\n                10, 9, 4\n            ]) == 4\n        );\n        assert!(\n            search(vec![\n                2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7\n            ]) == 4\n        );\n        assert!(\n            search(vec![\n                9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1\n            ]) == 2\n        );\n        assert!(\n            search(vec![\n                5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8\n            ]) == -1\n        );\n        assert!(search(vec![10]) == -1);\n        assert!(search(vec![9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2);\n        assert!(search(vec![5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1);\n        assert!(\n            search(vec![\n                7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6\n            ]) == 1\n        );\n        assert!(search(vec![3, 10, 10, 9, 2]) == -1);\n    }\n\n}\n", "example_test": "None", "prompt_text": "You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.", "prompt_explain": "You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n        assert!(search(vec![3, 10, 10, 9, 2]) == -1)", "func_title": "fn search(lst: Vec<i32>) -> i32 {\n\n", "prompt_text_chinese": "给你一个非空的正整数列表。返回大于零的最大整数，并且频率大于或等于整数本身的值。整数出现的频率是指它在列表中出现的次数。如果不存在，则返回-1。"}
{"task_id": "Rust/70", "prompt": "/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn strange_sort_list(lst: Vec<i32>) -> Vec<i32>{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn strange_sort_list(lst: Vec<i32>) -> Vec<i32>{\n\n", "canonical_solution": "\n    let mut cp:Vec<i32> = lst.clone();\n    let mut res:Vec<i32> = vec![];\n\n    for (indx, _) in lst.iter().enumerate(){\n        if indx%2 == 1 {\n            let max:i32 = *cp.iter().max().unwrap();\n            res.push(max);\n            cp.remove(cp.iter().position(|x| *x == max).unwrap());\n        }\n        else{\n            let min:i32 = *cp.iter().min().unwrap();\n            res.push(min);\n            cp.remove(cp.iter().position(|x| *x == min).unwrap());\n        }\n    }\n    return res;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n#[test]\n    fn test_strange_sort_list() {\n        assert!(strange_sort_list(vec![1, 2, 3, 4]) == vec![1, 4, 2, 3]);\n        assert!(strange_sort_list(vec![5, 6, 7, 8, 9]) == vec![5, 9, 6, 8, 7]);\n        assert!(strange_sort_list(vec![1, 2, 3, 4, 5]) == vec![1, 5, 2, 4, 3]);\n        assert!(strange_sort_list(vec![5, 6, 7, 8, 9, 1]) == vec![1, 9, 5, 8, 6, 7]);\n        assert!(strange_sort_list(vec![5, 5, 5, 5]) == vec![5, 5, 5, 5]);\n        assert!(strange_sort_list(vec![]) == vec![]);\n        assert!(strange_sort_list(vec![1, 2, 3, 4, 5, 6, 7, 8]) == vec![1, 8, 2, 7, 3, 6, 4, 5]);\n        assert!(\n            strange_sort_list(vec![0, 2, 2, 2, 5, 5, -5, -5]) == vec![-5, 5, -5, 5, 0, 2, 2, 2]\n        );\n        assert!(strange_sort_list(vec![111111]) == vec![111111]);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.", "prompt_explain": "Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n        assert!(strange_sort_list(vec![111111]) == vec![111111])", "func_title": "fn strange_sort_list(lst: Vec<i32>) -> Vec<i32>{\n\n", "prompt_text_chinese": "给定整数列表，以奇怪的顺序返回列表。奇怪排序，就是从最小值开始，然后是剩余整数中的最大值，然后是最小值，以此类推。"}
{"task_id": "Rust/71", "prompt": "/*\n\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn triangle_area_f64(a:f64, b:f64, c:f64) -> f64{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn triangle_area_f64(a:f64, b:f64, c:f64) -> f64{\n\n", "canonical_solution": "\n    if a+b<=c || a+c<=b || b+c<=a {return -1.0;}\n    let h:f64=(a+b+c) / 2.0;\n    let mut area:f64;\n    area = f64::powf(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_triangle_area_f64() {\n        assert!(f64::abs(triangle_area_f64(3.0, 4.0, 5.0) - 6.00) < 0.01);\n        assert!(f64::abs(triangle_area_f64(1.0, 2.0, 10.0) + 1.0) < 0.01);\n        assert!(f64::abs(triangle_area_f64(4.0, 8.0, 5.0) - 8.18) < 0.01);\n        assert!(f64::abs(triangle_area_f64(2.0, 2.0, 2.0) - 1.73) < 0.01);\n        assert!(f64::abs(triangle_area_f64(1.0, 2.0, 3.0) + 1.0) < 0.01);\n        assert!(f64::abs(triangle_area_f64(10.0, 5.0, 7.0) - 16.25) < 0.01);\n        assert!(f64::abs(triangle_area_f64(2.0, 6.0, 3.0) + 1.0) < 0.01);\n        assert!(f64::abs(triangle_area_f64(1.0, 1.0, 1.0) - 0.43) < 0.01);\n        assert!(f64::abs(triangle_area_f64(2.0, 2.0, 10.0) + 1.0) < 0.01);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.", "prompt_explain": "Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n        assert!(f64::abs(triangle_area_f64(2.0, 2.0, 10.0) + 1.0) < 0.01)", "func_title": "fn triangle_area_f64(a:f64, b:f64, c:f64) -> f64{\n\n", "prompt_text_chinese": "已知三角形三条边的长度。如果三角形的三条边组成一个有效的三角形，则返回三角形的面积四舍五入到小数点后两位。否则返回-1当任意两条边之和大于第三条边时，三条边构成有效三角形。"}
{"task_id": "Rust/72", "prompt": "/*\n\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn will_it_fly(q:Vec<i32>, w:i32) -> bool{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn will_it_fly(q:Vec<i32>, w:i32) -> bool{\n\n", "canonical_solution": "\n    if q.iter().sum::<i32>() > w {\n        return false;\n    }\n    let mut i = 0;\n    let mut j = q.len() - 1;\n\n    while i < j {\n        if q[i] != q[j] {\n            return false;\n        }\n        i += 1;\n        j -= 1;\n    }\n    return true;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_will_it_fly() {\n        assert!(will_it_fly(vec![3, 2, 3], 9) == true);\n        assert!(will_it_fly(vec![1, 2], 5) == false);\n        assert!(will_it_fly(vec![3], 5) == true);\n        assert!(will_it_fly(vec![3, 2, 3], 1) == false);\n        assert!(will_it_fly(vec![1, 2, 3], 6) == false);\n        assert!(will_it_fly(vec![5], 5) == true);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.", "prompt_explain": "Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n        assert!(will_it_fly(vec![5], 5) == true)", "func_title": "fn will_it_fly(q:Vec<i32>, w:i32) -> bool{\n\n", "prompt_text_chinese": "编写一个函数，如果对象q将飞，则返回True，否则返回False。如果对象q是平衡的(它是一个回文列表)，并且其元素的和小于或等于最大可能的权值w，则对象q将飞起来。"}
{"task_id": "Rust/73", "prompt": "/*\n\n    Given an array arr of integers, find the minimum number of elements that\n    need to be changed to make the array palindromic. A palindromic array is an array that\n    is read the same backwards and forwards. In one change, you can change one element to any other element.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn smallest_change(arr:Vec<i32>) -> i32{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn smallest_change(arr:Vec<i32>) -> i32{\n\n", "canonical_solution": "\n    let mut ans: i32 = 0;\n    for i in 0..arr.len() / 2 {\n        if arr[i] != arr[arr.len() - i - 1] {\n            ans += 1\n        }\n    }\n    return ans;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_smallest_change() {\n        assert!(smallest_change(vec![1, 2, 3, 5, 4, 7, 9, 6]) == 4);\n        assert!(smallest_change(vec![1, 2, 3, 4, 3, 2, 2]) == 1);\n        assert!(smallest_change(vec![1, 4, 2]) == 1);\n        assert!(smallest_change(vec![1, 4, 4, 2]) == 1);\n        assert!(smallest_change(vec![1, 2, 3, 2, 1]) == 0);\n        assert!(smallest_change(vec![3, 1, 1, 3]) == 0);\n        assert!(smallest_change(vec![1]) == 0);\n        assert!(smallest_change(vec![0, 1]) == 1);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Given an array arr of integers, find the minimum number of elements that\n    need to be changed to make the array palindromic. A palindromic array is an array that\n    is read the same backwards and forwards. In one change, you can change one element to any other element.", "prompt_explain": "Given an array arr of integers, find the minimum number of elements that\n    need to be changed to make the array palindromic. A palindromic array is an array that\n    is read the same backwards and forwards. In one change, you can change one element to any other element.\n        assert!(smallest_change(vec![0, 1]) == 1)", "func_title": "fn smallest_change(arr:Vec<i32>) -> i32{\n\n", "prompt_text_chinese": "给定一个整数数组arr，找出为了使数组回文而需要更改的最小元素数。回文数组是前后读取相同的数组。在一次更改中，您可以将一个元素更改为任何其他元素。"}
{"task_id": "Rust/74", "prompt": "/*\n\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn total_match(lst1:Vec<&str>, lst2:Vec<&str>) -> Vec<String>{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn total_match(lst1:Vec<&str>, lst2:Vec<&str>) -> Vec<String>{\n\n", "canonical_solution": "\n    let total_1: usize = lst1\n        .iter()\n        .fold(0, |acc: usize, str: &&str| acc + str.chars().count());\n    let total_2: usize = lst2\n        .iter()\n        .fold(0, |acc: usize, str: &&str| acc + str.chars().count());\n\n    if total_1 <= total_2 {\n        return lst1.into_iter().map(|x| x.to_string()).collect();\n    } else {\n        return lst2.into_iter().map(|x| x.to_string()).collect();\n    }\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_total_match() {\n        let v_empty: Vec<String> = vec![];\n        assert!(total_match(vec![], vec![]) == v_empty);\n        assert!(total_match(vec![\"hi\", \"admin\"], vec![\"hi\", \"hi\"]) == vec![\"hi\", \"hi\"]);\n        assert!(\n            total_match(vec![\"hi\", \"admin\"], vec![\"hi\", \"hi\", \"admin\", \"project\"])\n                == vec![\"hi\", \"admin\"]\n        );\n        assert!(total_match(vec![\"4\"], vec![\"1\", \"2\", \"3\", \"4\", \"5\"]) == vec![\"4\"]);\n        assert!(total_match(vec![\"hi\", \"admin\"], vec![\"hI\", \"Hi\"]) == vec![\"hI\", \"Hi\"]);\n        assert!(total_match(vec![\"hi\", \"admin\"], vec![\"hI\", \"hi\", \"hi\"]) == vec![\"hI\", \"hi\", \"hi\"]);\n        assert!(total_match(vec![\"hi\", \"admin\"], vec![\"hI\", \"hi\", \"hii\"]) == vec![\"hi\", \"admin\"]);\n        assert!(total_match(vec![], vec![\"this\"]) == v_empty);\n        assert!(total_match(vec![\"this\"], vec![]) == v_empty);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.", "prompt_explain": "Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n        assert!(total_match(vec![\"this\"], vec![]) == v_empty)", "func_title": "fn total_match(lst1:Vec<&str>, lst2:Vec<&str>) -> Vec<String>{\n\n", "prompt_text_chinese": "编写一个函数，接受两个字符串列表，并返回列表中所有字符串的总字符数小于另一个列表的列表。如果两个列表的字符数相同，则返回第一个列表。"}
{"task_id": "Rust/75", "prompt": "/*\nWrite a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn is_multiply_prime(a: i32) -> bool {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn is_multiply_prime(a: i32) -> bool {\n\n", "canonical_solution": "\n    let mut a1 = a;\n    let mut num = 0;\n    for i in 2..a {\n        while a1 % i == 0 && a1 > i {\n            a1 /= i;\n            num += 1;\n        }\n    }\n    if num == 2 {\n        return true;\n    }\n    return false;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_is_multiply_prime() {\n        assert!(is_multiply_prime(5) == false);\n        assert!(is_multiply_prime(30) == true);\n        assert!(is_multiply_prime(8) == true);\n        assert!(is_multiply_prime(10) == false);\n        assert!(is_multiply_prime(125) == true);\n        assert!(is_multiply_prime(3 * 5 * 7) == true);\n        assert!(is_multiply_prime(3 * 6 * 7) == false);\n        assert!(is_multiply_prime(9 * 9 * 9) == false);\n        assert!(is_multiply_prime(11 * 9 * 9) == false);\n        assert!(is_multiply_prime(11 * 13 * 7) == true);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100.", "prompt_explain": "Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100.\n        assert!(is_multiply_prime(11 * 13 * 7) == true)", "func_title": "fn is_multiply_prime(a: i32) -> bool {\n\n", "prompt_text_chinese": "写一个函数，如果给定的数字是3个质数的乘法，则返回true，否则返回false。知道a小于100。"}
{"task_id": "Rust/76", "prompt": "/*\nYour task is to write a function that returns true if a number x is a simple\n    power of n and false in other cases.\n    x is a simple power of n if n**int=x\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn is_simple_power(x:i32, n:i32) -> bool{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn is_simple_power(x:i32, n:i32) -> bool{\n\n", "canonical_solution": "\n    let mut p: i32 = 1;\n    let mut count: i32 = 0;\n\n    while p <= x && count < 100 {\n        if p == x {\n            return true;\n        };\n        p = p * n;\n        count += 1;\n    }\n    return false;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n  #[test]\n    fn test_is_simple_power() {\n        assert!(is_simple_power(1, 4) == true);\n        assert!(is_simple_power(2, 2) == true);\n        assert!(is_simple_power(8, 2) == true);\n        assert!(is_simple_power(3, 2) == false);\n        assert!(is_simple_power(3, 1) == false);\n        assert!(is_simple_power(5, 3) == false);\n        assert!(is_simple_power(16, 2) == true);\n        assert!(is_simple_power(143214, 16) == false);\n        assert!(is_simple_power(4, 2) == true);\n        assert!(is_simple_power(9, 3) == true);\n        assert!(is_simple_power(16, 4) == true);\n        assert!(is_simple_power(24, 2) == false);\n        assert!(is_simple_power(128, 4) == false);\n        assert!(is_simple_power(12, 6) == false);\n        assert!(is_simple_power(1, 1) == true);\n        assert!(is_simple_power(1, 12) == true);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Your task is to write a function that returns true if a number x is a simple\n    power of n and false in other cases.\n    x is a simple power of n if n**int=x", "prompt_explain": "Your task is to write a function that returns true if a number x is a simple\n    power of n and false in other cases.\n    x is a simple power of n if n**int=x\n        assert!(is_simple_power(1, 12) == true)", "func_title": "fn is_simple_power(x:i32, n:i32) -> bool{\n\n", "prompt_text_chinese": "你的任务是编写一个函数，如果一个数字x是n的简单幂则返回true，其他情况则返回false。如果n**int= X, X是n的简单幂"}
{"task_id": "Rust/77", "prompt": "/*\n\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn iscuber(a:i32) -> bool{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn iscuber(a:i32) -> bool{\n\n", "canonical_solution": "\n    let a1: f64 = i32::abs(a) as f64;\n    let sqrt_3 = f64::powf(a1, 1.0 / 3.0).ceil();\n\n    return i32::pow(sqrt_3 as i32, 3) == a1 as i32;\n}\n\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_iscuber() {\n        assert!(iscuber(1) == true);\n        assert!(iscuber(2) == false);\n        assert!(iscuber(-1) == true);\n        assert!(iscuber(64) == true);\n        assert!(iscuber(180) == false);\n        assert!(iscuber(1000) == true);\n        assert!(iscuber(0) == true);\n        assert!(iscuber(1729) == false);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.", "prompt_explain": "Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n        assert!(iscuber(1729) == false)", "func_title": "fn iscuber(a:i32) -> bool{\n\n", "prompt_text_chinese": "编写一个函数，该函数接受一个整数a，如果这个整数是某个整数的立方体，则返回True。注意:你可以假设输入总是有效的。"}
{"task_id": "Rust/78", "prompt": "/*\nYou have been tasked to write a function that receives \n    a hexadecimal number as a string and counts the number of hexadecimal \n    digits that are primes (prime number, or a prime, is a natural number \n    greater than 1 that is not a product of two smaller natural numbers).\n    Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    So you have to determine a number of the following digits: 2, 3, 5, 7, \n    B (=decimal 11), D (=decimal 13).\n    Note: you may assume the input is always correct or empty string, \n    and symbols A,B,C,D,E,F are always uppercase.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn hex_key(num:&str) -> i32{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn hex_key(num:&str) -> i32{\n\n", "canonical_solution": "\n    let primes: Vec<&str> = vec![\"2\", \"3\", \"5\", \"7\", \"B\", \"D\"];\n    let mut total: i32 = 0;\n    for i in 0..num.len() {\n        if primes.contains(&num.get(i..i + 1).unwrap()) {\n            total += 1;\n        }\n    }\n    return total;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n\n    #[test]\n    fn test_hex_key() {\n        assert!(hex_key(\"AB\") == 1);\n        assert!(hex_key(\"1077E\") == 2);\n        assert!(hex_key(\"ABED1A33\") == 4);\n        assert!(hex_key(\"2020\") == 2);\n        assert!(hex_key(\"123456789ABCDEF0\") == 6);\n        assert!(hex_key(\"112233445566778899AABBCCDDEEFF00\") == 12);\n        assert!(hex_key(\"\") == 0);\n    }\n\n}\n", "example_test": "None", "prompt_text": "You have been tasked to write a function that receives \n    a hexadecimal number as a string and counts the number of hexadecimal \n    digits that are primes (prime number, or a prime, is a natural number \n    greater than 1 that is not a product of two smaller natural numbers).\n    Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    So you have to determine a number of the following digits: 2, 3, 5, 7, \n    B (=decimal 11), D (=decimal 13).\n    Note: you may assume the input is always correct or empty string, \n    and symbols A,B,C,D,E,F are always uppercase.", "prompt_explain": "You have been tasked to write a function that receives \n    a hexadecimal number as a string and counts the number of hexadecimal \n    digits that are primes (prime number, or a prime, is a natural number \n    greater than 1 that is not a product of two smaller natural numbers).\n    Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    So you have to determine a number of the following digits: 2, 3, 5, 7, \n    B (=decimal 11), D (=decimal 13).\n    Note: you may assume the input is always correct or empty string, \n    and symbols A,B,C,D,E,F are always uppercase.\n        assert!(hex_key(\"\") == 0)", "func_title": "fn hex_key(num:&str) -> i32{\n\n", "prompt_text_chinese": "您的任务是编写一个函数，该函数接收一个十六进制数作为字符串，并计算作为质数的十六进制数字的数目(质数或素数是大于1的自然数，而不是两个较小自然数的乘积)。十六进制数字为0,1,2,3,4,5,6,7,8,9,A, B, C, D, E, f，素数为2,3,5,7,11,13,17，…因此，您必须确定以下数字中的一个数:2,3,5,7,B(=十进制11)，D(=十进制13)。注意:您可以假设输入始终是正确的或空字符串，符号A,B,C,D,E,F始终是大写的。"}
{"task_id": "Rust/79", "prompt": "/*\nYou will be given a number in decimal form and your task is to convert it to\n    binary format. The function should return a string, with each character representing a binary\n    number. Each character in the string will be '0' or '1'.\n\n    There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    The extra characters are there to help with the format.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn decimal_to_binary(decimal:i32) -> String{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn decimal_to_binary(decimal:i32) -> String{\n\n", "canonical_solution": "\n    let mut d_cp = decimal;\n    let mut out: String = String::from(\"\");\n    if d_cp == 0 {\n        return \"db0db\".to_string();\n    }\n    while d_cp > 0 {\n        out = (d_cp % 2).to_string() + &out;\n        d_cp = d_cp / 2;\n    }\n    out = \"db\".to_string() + &out + &\"db\".to_string();\n    return out;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_decimal_to_binary() {\n        assert!(decimal_to_binary(0) == \"db0db\".to_string());\n        assert!(decimal_to_binary(32) == \"db100000db\".to_string());\n        assert!(decimal_to_binary(103) == \"db1100111db\".to_string());\n        assert!(decimal_to_binary(15) == \"db1111db\".to_string());\n    }\n\n}\n", "example_test": "None", "prompt_text": "You will be given a number in decimal form and your task is to convert it to\n    binary format. The function should return a string, with each character representing a binary\n    number. Each character in the string will be '0' or '1'.\n\n    There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    The extra characters are there to help with the format.", "prompt_explain": "You will be given a number in decimal form and your task is to convert it to\n    binary format. The function should return a string, with each character representing a binary\n    number. Each character in the string will be '0' or '1'.\n\n    There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    The extra characters are there to help with the format.\n        assert!(decimal_to_binary(15) == \"db1111db\".to_string())", "func_title": "fn decimal_to_binary(decimal:i32) -> String{\n\n", "prompt_text_chinese": "你会得到一个十进制形式的数字，你的任务是把它转换成二进制格式。该函数应返回一个字符串，每个字符表示一个二进制数。字符串中的每个字符都是'0'或'1'。在字符串的开头和结尾会有两个额外的字符'db'。额外的字符是用来帮助格式化的。"}
{"task_id": "Rust/80", "prompt": "/*\nYou are given a string s.\n    Your task is to check if the string is happy or not.\n    A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn is_happy(s:&str) -> bool{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn is_happy(s:&str) -> bool{\n\n", "canonical_solution": "\n    let str: Vec<char> = s.chars().into_iter().collect();\n    if str.len() < 3 {\n        return false;\n    }\n    for i in 2..str.len() {\n        if str[i] == str[i - 1] || str[i] == str[i - 2] {\n            return false;\n        }\n    }\n    return true;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_is_happy() {\n        assert!(is_happy(\"a\") == false);\n        assert!(is_happy(\"aa\") == false);\n        assert!(is_happy(\"abcd\") == true);\n        assert!(is_happy(\"aabb\") == false);\n        assert!(is_happy(\"adb\") == true);\n        assert!(is_happy(\"xyy\") == false);\n        assert!(is_happy(\"iopaxpoi\") == true);\n        assert!(is_happy(\"iopaxioi\") == false);\n    }\n\n}\n", "example_test": "None", "prompt_text": "You are given a string s.\n    Your task is to check if the string is happy or not.\n    A string is happy if its length is at least 3 and every 3 consecutive letters are distinct", "prompt_explain": "You are given a string s.\n    Your task is to check if the string is happy or not.\n    A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n        assert!(is_happy(\"iopaxioi\") == false)", "func_title": "fn is_happy(s:&str) -> bool{\n\n", "prompt_text_chinese": "给你一个字符串s。你的任务是检查这个字符串是否快乐。如果一个字符串的长度至少为3，并且每3个连续的字母都是不同的，则该字符串是有效的"}
{"task_id": "Rust/81", "prompt": "/*\nIt is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write \n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn numerical_letter_grade(grades:Vec<f64>) -> Vec<String>{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn numerical_letter_grade(grades:Vec<f64>) -> Vec<String>{\n\n", "canonical_solution": "\n    let mut res: Vec<String> = vec![];\n    for (i, gpa) in grades.iter().enumerate() {\n        if gpa == &4.0 {\n            res.push(\"A+\".to_string());\n        } else if gpa > &3.7 {\n            res.push(\"A\".to_string());\n        } else if gpa > &3.3 {\n            res.push(\"A-\".to_string());\n        } else if gpa > &3.0 {\n            res.push(\"B+\".to_string());\n        } else if gpa > &2.7 {\n            res.push(\"B\".to_string());\n        } else if gpa > &2.3 {\n            res.push(\"B-\".to_string());\n        } else if gpa > &2.0 {\n            res.push(\"C+\".to_string());\n        } else if gpa > &1.7 {\n            res.push(\"C\".to_string());\n        } else if gpa > &1.3 {\n            res.push(\"C-\".to_string());\n        } else if gpa > &1.0 {\n            res.push(\"D+\".to_string());\n        } else if gpa > &0.7 {\n            res.push(\"D\".to_string());\n        } else if gpa > &0.0 {\n            res.push(\"D-\".to_string());\n        } else {\n            res.push(\"E\".to_string());\n        }\n    }\n    return res;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_numerical_letter_grade() {\n        assert!(\n            numerical_letter_grade(vec![4.0, 3.0, 1.7, 2.0, 3.5])\n                == vec![\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\n        );\n        assert!(numerical_letter_grade(vec![1.2]) == vec![\"D+\"]);\n        assert!(numerical_letter_grade(vec![0.5]) == vec![\"D-\"]);\n        assert!(numerical_letter_grade(vec![0.0]) == vec![\"E\"]);\n        assert!(\n            numerical_letter_grade(vec![1.0, 0.3, 1.5, 2.8, 3.3])\n                == vec![\"D\", \"D-\", \"C-\", \"B\", \"B+\"]\n        );\n        assert!(numerical_letter_grade(vec![0.0, 0.7]) == vec![\"E\", \"D-\"]);\n    }\n\n}\n", "example_test": "None", "prompt_text": "It is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write \n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n ", "prompt_explain": "It is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write \n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n \n        assert!(numerical_letter_grade(vec![0.0, 0.7]) == vec![\"E\", \"D-\"])", "func_title": "fn numerical_letter_grade(grades:Vec<f64>) -> Vec<String>{\n\n", "prompt_text_chinese": "这是学期的最后一周，老师要给学生打分。老师一直在制定她自己的评分算法。唯一的问题是，她把评分用的代码弄丢了。她给了你一些学生的gpa列表，你必须写一个函数，可以输出一个字母等级列表，使用下表:GPA |信级4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E"}
{"task_id": "Rust/82", "prompt": "/*\nWrite a function that takes a string and returns True if the string\n    length is a prime number or False otherwise\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn prime_length(str:&str) -> bool{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn prime_length(str:&str) -> bool{\n\n", "canonical_solution": "\n    let l: usize = str.len();\n    if l == 0 || l == 1 {\n        return false;\n    }\n\n    for i in 2..l {\n        if l % i == 0 {\n            return false;\n        }\n    }\n    return true;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_prime_length() {\n        assert!(prime_length(\"Hello\") == true);\n        assert!(prime_length(\"abcdcba\") == true);\n        assert!(prime_length(\"kittens\") == true);\n        assert!(prime_length(\"orange\") == false);\n        assert!(prime_length(\"wow\") == true);\n        assert!(prime_length(\"world\") == true);\n        assert!(prime_length(\"MadaM\") == true);\n        assert!(prime_length(\"Wow\") == true);\n        assert!(prime_length(\"\") == false);\n        assert!(prime_length(\"HI\") == true);\n        assert!(prime_length(\"go\") == true);\n        assert!(prime_length(\"gogo\") == false);\n        assert!(prime_length(\"aaaaaaaaaaaaaaa\") == false);\n        assert!(prime_length(\"Madam\") == true);\n        assert!(prime_length(\"M\") == false);\n        assert!(prime_length(\"0\") == false);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Write a function that takes a string and returns True if the string\n    length is a prime number or False otherwise", "prompt_explain": "Write a function that takes a string and returns True if the string\n    length is a prime number or False otherwise\n        assert!(prime_length(\"0\") == false)", "func_title": "fn prime_length(str:&str) -> bool{\n\n", "prompt_text_chinese": "编写一个函数，该函数接受一个字符串，如果字符串长度是质数则返回True，否则返回False。"}
{"task_id": "Rust/83", "prompt": "/*\n\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn starts_one_ends(n:i32) -> i32{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn starts_one_ends(n:i32) -> i32{\n\n", "canonical_solution": "\n    if n == 1 {\n        return 1;\n    };\n    return 18 * i32::pow(10, (n - 2) as u32);\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_starts_one_ends() {\n        assert!(starts_one_ends(1) == 1);\n        assert!(starts_one_ends(2) == 18);\n        assert!(starts_one_ends(3) == 180);\n        assert!(starts_one_ends(4) == 1800);\n        assert!(starts_one_ends(5) == 18000);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.", "prompt_explain": "Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n        assert!(starts_one_ends(5) == 18000)", "func_title": "fn starts_one_ends(n:i32) -> i32{\n\n", "prompt_text_chinese": "给定一个正整数n，返回以1开始或以1结束的n位正整数的个数的计数。"}
{"task_id": "Rust/84", "prompt": "/*\nGiven a positive integer N, return the total sum of its digits in binary.\n    \n    Variables:\n        @N integer\n             Constraints: 0 ≤ N ≤ 10000.\n    Output:\n         a string of binary number\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn solve(n:i32) -> String{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn solve(n:i32) -> String{\n\n", "canonical_solution": "\n    let sum: i32 = n\n        .to_string()\n        .chars()\n        .into_iter()\n        .fold(0, |acc, c| acc + c.to_digit(10).unwrap() as i32);\n    return format!(\"{sum:b}\");\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_solve() {\n        assert!(solve(1000) == \"1\");\n        assert!(solve(150) == \"110\");\n        assert!(solve(147) == \"1100\");\n        assert!(solve(333) == \"1001\");\n        assert!(solve(963) == \"10010\");\n    }\n\n}\n", "example_test": "None", "prompt_text": "Given a positive integer N, return the total sum of its digits in binary.", "prompt_explain": "Given a positive integer N, return the total sum of its digits in binary.\n        assert!(solve(963) == \"10010\")", "func_title": "fn solve(n:i32) -> String{\n\n", "prompt_text_chinese": "给定一个正整数N，返回其二进制数字的总和。"}
{"task_id": "Rust/85", "prompt": "/*\nGiven a non-empty list of integers lst. add the even elements that are at odd indices..\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn add_even_odd(lst: Vec<i32>) -> i32{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn add_even_odd(lst: Vec<i32>) -> i32{\n\n", "canonical_solution": "\n    let mut sum: i32 = 0;\n\n    for (indx, elem) in lst.iter().enumerate() {\n        if indx % 2 == 1 {\n            if elem % 2 == 0 {\n                sum += elem\n            }\n        }\n    }\n    return sum;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_add_even_odd() {\n        assert!(add_even_odd(vec![4, 88]) == 88);\n        assert!(add_even_odd(vec![4, 5, 6, 7, 2, 122]) == 122);\n        assert!(add_even_odd(vec![4, 0, 6, 7]) == 0);\n        assert!(add_even_odd(vec![4, 4, 6, 8]) == 12);\n    }\n\n\n}\n", "example_test": "None", "prompt_text": "Given a non-empty list of integers lst. add the even elements that are at odd indices.", "prompt_explain": "Given a non-empty list of integers lst. add the even elements that are at odd indices.\n        assert!(add_even_odd(vec![4, 4, 6, 8]) == 12)", "func_title": "fn add_even_odd(lst: Vec<i32>) -> i32{\n\n", "prompt_text_chinese": "给定一个非空的整数列表lst。将奇数下标处的偶数元素相加。"}
{"task_id": "Rust/86", "prompt": "/*\n\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn anti_shuffle(s:&str) -> String{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn anti_shuffle(s:&str) -> String{\n\n", "canonical_solution": "\n    let mut res: String = String::new();\n\n    for i in s.split_ascii_whitespace() {\n        let mut str: Vec<char> = i.chars().into_iter().collect();\n        str.sort_by(|a, b| (*a as u32).cmp(&(*b as u32)));\n        let str_sorted: String = str.into_iter().collect();\n        res.push_str(&(str_sorted + &\" \".to_string()));\n    }\n    res = res.trim_end().to_string();\n    return res;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n\n    #[test]\n    fn test_anti_shuffle() {\n        assert!(anti_shuffle(\"Hi\") == \"Hi\".to_string());\n        assert!(anti_shuffle(\"hello\") == \"ehllo\".to_string());\n        assert!(anti_shuffle(\"number\") == \"bemnru\".to_string());\n        assert!(anti_shuffle(\"abcd\") == \"abcd\".to_string());\n        assert!(anti_shuffle(\"Hello World!!!\") == \"Hello !!!Wdlor\".to_string());\n        assert!(anti_shuffle(\"\") == \"\".to_string());\n        assert!(\n            anti_shuffle(\"Hi. My name is Mister Robot. How are you?\")\n                == \".Hi My aemn is Meirst .Rboot How aer ?ouy\".to_string()\n        );\n    }\n\n}\n", "example_test": "None", "prompt_text": "Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.", "prompt_explain": "Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n        assert!(\n            anti_shuffle(\"Hi. My name is Mister Robot. How are you?\")\n                == \".Hi My aemn is Meirst .Rboot How aer ?ouy\".to_string()\n        )", "func_title": "fn anti_shuffle(s:&str) -> String{\n\n", "prompt_text_chinese": "编写一个函数，该函数接受一个字符串并返回该字符串的有序版本。字符串的有序版本，是一个字符串，其中所有单词(由空格分隔)都被一个新单词替换，其中所有字符根据ascii值升序排列。注意:你应该保持句子中单词的顺序和空格。"}
{"task_id": "Rust/87", "prompt": "/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn get_row(lst:Vec<Vec<i32>>, x:i32) -> Vec<Vec<i32>>{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn get_row(lst:Vec<Vec<i32>>, x:i32) -> Vec<Vec<i32>>{\n\n", "canonical_solution": "\n    let mut out: Vec<Vec<i32>> = vec![];\n    for (indxi, elem1) in lst.iter().enumerate() {\n        for (indxj, _) in elem1.iter().rev().enumerate() {\n            if lst[indxi][indxj] == x {\n                out.push(vec![indxi as i32, indxj as i32]);\n            }\n        }\n    }\n    return out;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_get_row() {\n        assert!(\n            get_row(\n                vec![\n                    vec![1, 2, 3, 4, 5, 6],\n                    vec![1, 2, 3, 4, 1, 6],\n                    vec![1, 2, 3, 4, 5, 1]\n                ],\n                1\n            ) == vec![vec![0, 0], vec![1, 0], vec![1, 4], vec![2, 0], vec![2, 5]]\n        );\n        assert!(\n            get_row(\n                vec![\n                    vec![1, 2, 3, 4, 5, 6],\n                    vec![1, 2, 3, 4, 5, 6],\n                    vec![1, 2, 3, 4, 5, 6],\n                    vec![1, 2, 3, 4, 5, 6],\n                    vec![1, 2, 3, 4, 5, 6],\n                    vec![1, 2, 3, 4, 5, 6]\n                ],\n                2\n            ) == vec![\n                vec![0, 1],\n                vec![1, 1],\n                vec![2, 1],\n                vec![3, 1],\n                vec![4, 1],\n                vec![5, 1]\n            ]\n        );\n        assert!(\n            get_row(\n                vec![\n                    vec![1, 2, 3, 4, 5, 6],\n                    vec![1, 2, 3, 4, 5, 6],\n                    vec![1, 1, 3, 4, 5, 6],\n                    vec![1, 2, 1, 4, 5, 6],\n                    vec![1, 2, 3, 1, 5, 6],\n                    vec![1, 2, 3, 4, 1, 6],\n                    vec![1, 2, 3, 4, 5, 1]\n                ],\n                1\n            ) == vec![\n                vec![0, 0],\n                vec![1, 0],\n                vec![2, 0],\n                vec![2, 1],\n                vec![3, 0],\n                vec![3, 2],\n                vec![4, 0],\n                vec![4, 3],\n                vec![5, 0],\n                vec![5, 4],\n                vec![6, 0],\n                vec![6, 5]\n            ]\n        );\n        let v: Vec<Vec<i32>> = vec![];\n        assert!(get_row(vec![], 1) == v);\n        assert!(get_row(vec![vec![1]], 2) == v);\n        assert!(get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3) == vec![vec![2, 2]]);\n    }\n\n}\n", "example_test": "None", "prompt_text": "You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.", "prompt_explain": "You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n        assert!(get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3) == vec![vec![2, 2]])", "func_title": "fn get_row(lst:Vec<Vec<i32>>, x:i32) -> Vec<Vec<i32>>{\n\n", "prompt_text_chinese": "给定一个二维数据，作为一个嵌套列表，它类似于矩阵，但与矩阵不同的是，每行可能包含不同数量的列。给定lst和整数x，在列表中找到整数x，并返回元组列表，[(x1, y1)， (x2, y2)…]这样每个元组都是一个坐标-(行，列)，从0开始。最初按行升序对坐标排序。此外，按列降序排序行坐标。"}
{"task_id": "Rust/88", "prompt": "/*\n\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn sort_array(array:Vec<i32>) -> Vec<i32>{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn sort_array(array:Vec<i32>) -> Vec<i32>{\n\n", "canonical_solution": "\n    let mut res: Vec<i32> = array.clone();\n\n    if array.len() == 0 {\n        return res;\n    }\n\n    if (array[0] + array[array.len() - 1]) % 2 == 0 {\n        res.sort();\n        return res.into_iter().rev().collect();\n    } else {\n        res.sort();\n        return res;\n    }\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n  #[test]\n    fn test_sort_array() {\n        assert!(sort_array(vec![]) == vec![]);\n        assert!(sort_array(vec![5]) == vec![5]);\n        assert!(sort_array(vec![2, 4, 3, 0, 1, 5]) == vec![0, 1, 2, 3, 4, 5]);\n        assert!(sort_array(vec![2, 4, 3, 0, 1, 5, 6]) == vec![6, 5, 4, 3, 2, 1, 0]);\n        assert!(sort_array(vec![2, 1]) == vec![1, 2]);\n        assert!(sort_array(vec![15, 42, 87, 32, 11, 0]) == vec![0, 11, 15, 32, 42, 87]);\n        assert!(sort_array(vec![21, 14, 23, 11]) == vec![23, 21, 14, 11]);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Given an array of non-negative integers, return a copy of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.", "prompt_explain": "Given an array of non-negative integers, return a copy of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n        assert!(sort_array(vec![21, 14, 23, 11]) == vec![23, 21, 14, 11])", "func_title": "fn sort_array(array:Vec<i32>) -> Vec<i32>{\n\n", "prompt_text_chinese": "给定一个非负整数数组，在排序后返回给定数组的副本，如果和(第一个索引值，最后一个索引值)是奇数，则按升序排序，如果和(第一个索引值，最后一个索引值)是偶数，则按降序排序。注意:*不要改变给定的数组。"}
{"task_id": "Rust/89", "prompt": "/*\nCreate a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn encrypt(s:&str) -> String{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn encrypt(s:&str) -> String{\n\n", "canonical_solution": "\n    let d: Vec<char> = \"abcdefghijklmnopqrstuvwxyz\"\n        .to_string()\n        .chars()\n        .into_iter()\n        .collect();\n    let mut out: String = String::new();\n    for c in s.chars() {\n        if d.contains(&c) {\n            let indx: usize = (d.iter().position(|x| c == *x).unwrap() + 2 * 2) % 26;\n            out += &d[indx].to_string();\n        } else {\n            out += &c.to_string();\n        }\n    }\n\n    return out;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_encrypt() {\n        assert!(encrypt(\"hi\") == \"lm\");\n        assert!(encrypt(\"asdfghjkl\") == \"ewhjklnop\");\n        assert!(encrypt(\"gf\") == \"kj\");\n        assert!(encrypt(\"et\") == \"ix\");\n        assert!(encrypt(\"faewfawefaewg\") == \"jeiajeaijeiak\");\n        assert!(encrypt(\"hellomyfriend\") == \"lippsqcjvmirh\");\n        assert!(\n            encrypt(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")\n                == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\n        );\n        assert!(encrypt(\"a\") == \"e\");\n    }\n\n}\n", "example_test": "None", "prompt_text": "Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.", "prompt_explain": "Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n        assert!(encrypt(\"a\") == \"e\")", "func_title": "fn encrypt(s:&str) -> String{\n\n", "prompt_text_chinese": "创建一个函数encrypt，该函数以字符串作为参数，并返回一个以旋转字母加密的字符串。字母表应该以这样的方式旋转，即字母向下移动两个乘到两个位置。"}
{"task_id": "Rust/90", "prompt": "/*\n\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn next_smallest(lst:Vec<i32>) -> i32{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn next_smallest(lst:Vec<i32>) -> i32{\n\n", "canonical_solution": "\n    let mut res = 0;\n    let mut lst_cp = lst.clone();\n    let mut first: i32 = 0;\n    let mut second: i32 = 0;\n\n    if lst.iter().min() == None {\n        res = -1;\n    } else {\n        if lst.iter().min() != None {\n            first = *lst.iter().min().unwrap();\n            let indx = lst.iter().position(|x| *x == first).unwrap();\n            lst_cp.remove(indx);\n\n            if lst_cp.iter().min() != None {\n                second = *lst_cp.iter().min().unwrap();\n            }\n            if first != second {\n                res = second;\n            } else {\n                res = -1;\n            }\n        }\n    }\n    return res;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_next_smallest() {\n        assert!(next_smallest(vec![1, 2, 3, 4, 5]) == 2);\n        assert!(next_smallest(vec![5, 1, 4, 3, 2]) == 2);\n        assert!(next_smallest(vec![]) == -1);\n        assert!(next_smallest(vec![1, 1]) == -1);\n        assert!(next_smallest(vec![1, 1, 1, 1, 0]) == 1);\n        assert!(next_smallest(vec![-35, 34, 12, -45]) == -35);\n    }\n\n}\n", "example_test": "None", "prompt_text": "You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.", "prompt_explain": "You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n        assert!(next_smallest(vec![-35, 34, 12, -45]) == -35)", "func_title": "fn next_smallest(lst:Vec<i32>) -> i32{\n\n", "prompt_text_chinese": "给你一个整数列表。编写一个函数next_minimal()，返回列表中第2小的元素。如果没有这样的元素，则返回None。"}
{"task_id": "Rust/91", "prompt": "/*\n\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\".\n    Sentences are delimited by '.', '?' or '!'.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn is_bored(s:&str) -> i32 {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn is_bored(s:&str) -> i32 {\n\n", "canonical_solution": "\n    let mut count = 0;\n    let regex = Regex::new(r\"[.?!]\\s*\").expect(\"Invalid regex\");\n    let sqn: Vec<&str> = regex.split(s).into_iter().collect();\n    for s in sqn {\n        if s.starts_with(\"I \") {\n            count += 1;\n        }\n    }\n    return count;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_is_bored() {\n        assert!(is_bored(\"Hello world\") == 0);\n        assert!(is_bored(\"Is the sky blue?\") == 0);\n        assert!(is_bored(\"I love It !\") == 1);\n        assert!(is_bored(\"bIt\") == 0);\n        assert!(is_bored(\"I feel good today. I will be productive. will kill It\") == 2);\n        assert!(is_bored(\"You and I are going for a walk\") == 0);\n    }\n\n}\n", "example_test": "None", "prompt_text": "You'll be given a string of words, and your task is to count the number of boredoms. A boredom is a sentence that starts with the word \"I\". Sentences are delimited by '.', '?' or '!'.  For example:", "prompt_explain": "You'll be given a string of words, and your task is to count the number of boredoms. A boredom is a sentence that starts with the word \"I\". Sentences are delimited by '.', '?' or '!'.  For example:\n        assert!(is_bored(\"You and I are going for a walk\") == 0)", "func_title": "fn is_bored(s:&str) -> i32 {\n\n", "prompt_text_chinese": "给你一串单词，你的任务是数无聊的东西有多少。无聊是以“I”开头的句子。句子用'分隔。“,”?'或'!'。"}
{"task_id": "Rust/92", "prompt": "/*\n\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn any_int(a:f64, b:f64, c:f64) -> bool{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn any_int(a:f64, b:f64, c:f64) -> bool{\n\n", "canonical_solution": "\n    if a.fract() == 0.0 && b.fract() == 0.0 && c.fract() == 0.0 {\n        return a + b == c || a + c == b || b + c == a;\n    } else {\n        return false;\n    }\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_any_int() {\n        assert!(any_int(2.0, 3.0, 1.0) == true);\n        assert!(any_int(2.5, 2.0, 3.0) == false);\n        assert!(any_int(1.5, 5.0, 3.5) == false);\n        assert!(any_int(2.0, 6.0, 2.0) == false);\n        assert!(any_int(4.0, 2.0, 2.0) == true);\n        assert!(any_int(2.2, 2.2, 2.2) == false);\n        assert!(any_int(-4.0, 6.0, 2.0) == true);\n        assert!(any_int(2.0, 1.0, 1.0) == true);\n        assert!(any_int(3.0, 4.0, 7.0) == true);\n        assert!(any_int(3.01, 4.0, 7.0) == false);\n    }\n\n\n}\n", "example_test": "None", "prompt_text": "Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.", "prompt_explain": "Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n        assert!(any_int(3.01, 4.0, 7.0) == false)", "func_title": "fn any_int(a:f64, b:f64, c:f64) -> bool{\n\n", "prompt_text_chinese": "创建一个带有3个数字的函数。如果其中一个数字等于其他两个数字的和，并且所有数字都是整数，则返回true。在任何其他情况下返回false。"}
{"task_id": "Rust/93", "prompt": "/*\n\n    Write a function that takes a message, and encodes in such a \n    way that it swaps case of all letters, replaces all vowels in \n    the message with the letter that appears 2 places ahead of that \n    vowel in the english alphabet. \n    Assume only letters. \n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn encode(message:&str) -> String{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn encode(message:&str) -> String{\n\n", "canonical_solution": "\n    let mut res: String = String::new();\n    let v: Vec<char> = \"aeiouAEIOU\".to_string().chars().into_iter().collect();\n    let d: Vec<char> = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        .to_string()\n        .chars()\n        .into_iter()\n        .collect();\n\n    for (indx, elem) in message.chars().into_iter().enumerate() {\n        let mut c = elem.to_string();\n\n        if v.contains(&elem) {\n            let indx: usize = d.iter().position(|x| &elem == x).unwrap();\n            c = d[indx + 2 as usize].to_string();\n        }\n\n        if elem.is_uppercase() {\n            c = c.to_lowercase().to_string();\n        } else {\n            c = c.to_uppercase().to_string();\n        }\n        res.push_str(&c);\n    }\n    return res;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_encode() {\n        assert!(encode(\"TEST\") == \"tgst\");\n        assert!(encode(\"Mudasir\") == \"mWDCSKR\");\n        assert!(encode(\"YES\") == \"ygs\");\n        assert!(encode(\"This is a message\") == \"tHKS KS C MGSSCGG\");\n        assert!(encode(\"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\");\n    }\n\n}\n", "example_test": "None", "prompt_text": "Write a function that takes a message, and encodes in such a way that it swaps case of all letters, replaces all vowels in the message with the letter that appears 2 places ahead of that vowel in the english alphabet. Assume only letters.  Examples:", "prompt_explain": "Write a function that takes a message, and encodes in such a way that it swaps case of all letters, replaces all vowels in the message with the letter that appears 2 places ahead of that vowel in the english alphabet. Assume only letters.  Examples:\n        assert!(encode(\"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")", "func_title": "fn encode(message:&str) -> String{\n\n", "prompt_text_chinese": "编写一个函数，接受一个消息，并以这样一种方式进行编码:交换所有字母的大小写，将消息中的所有元音替换为在英语字母表中出现在该元音前面2位的字母。假设只有字母。"}
{"task_id": "Rust/94", "prompt": "/*\nYou are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn skjkasdkd(lst:Vec<i32>) -> i32{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn skjkasdkd(lst:Vec<i32>) -> i32{\n\n", "canonical_solution": "\n    let mut largest = 0;\n    for i in 0..lst.len() {\n        if lst[i] > largest {\n            let mut prime = true;\n            let mut j = 2;\n            while j * j <= lst[i] {\n                if lst[i] % j == 0 {\n                    prime = false;\n                }\n                j += 1;\n            }\n\n            if prime {\n                largest = lst[i];\n            }\n        }\n    }\n    let mut sum: i32 = 0;\n    let mut s: String = String::new();\n    s = largest.to_string();\n\n    for n in s.chars().into_iter() {\n        sum += n.to_digit(10).unwrap() as i32;\n    }\n    return sum;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_skjkasdkd() {\n        assert!(\n            skjkasdkd(vec![\n                0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3\n            ]) == 10\n        );\n        assert!(\n            skjkasdkd(vec![\n                1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1\n            ]) == 25\n        );\n        assert!(\n            skjkasdkd(vec![\n                1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3\n            ]) == 13\n        );\n        assert!(skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) == 11);\n        assert!(skjkasdkd(vec![0, 81, 12, 3, 1, 21]) == 3);\n        assert!(skjkasdkd(vec![0, 8, 1, 2, 1, 7]) == 7);\n        assert!(skjkasdkd(vec![8191]) == 19);\n        assert!(skjkasdkd(vec![8191, 123456, 127, 7]) == 19);\n        assert!(skjkasdkd(vec![127, 97, 8192]) == 10);\n    }\n\n\n}\n", "example_test": "None", "prompt_text": "You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.", "prompt_explain": "You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n        assert!(skjkasdkd(vec![127, 97, 8192]) == 10)", "func_title": "fn skjkasdkd(lst:Vec<i32>) -> i32{\n\n", "prompt_text_chinese": "给你一个整数列表。您需要找到最大的质数，并返回其数字的和。"}
{"task_id": "Rust/95", "prompt": "/*\n\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn check_dict_case(dict:HashMap<&str, &str>) -> bool{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn check_dict_case(dict:HashMap<&str, &str>) -> bool{\n\n", "canonical_solution": "\n    if dict.is_empty() {\n        return false;\n    }\n    let string_lower: fn(str: &str) -> bool = |str: &str| {\n        return str.chars().into_iter().all(|c| c.is_ascii_lowercase());\n    };\n    let string_upper: fn(str: &str) -> bool = |str: &str| {\n        return str.chars().into_iter().all(|c| c.is_ascii_uppercase());\n    };\n\n    let lower: bool = dict.keys().into_iter().all(|str| string_lower(str));\n    let upper: bool = dict.keys().into_iter().all(|str| string_upper(str));\n    return lower || upper;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_check_dict_case() {\n        assert!(check_dict_case(HashMap::from([(\"p\", \"pineapple\"), (\"b\", \"banana\")])) == true);\n        assert!(\n            check_dict_case(HashMap::from([\n                (\"p\", \"pineapple\"),\n                (\"A\", \"banana\"),\n                (\"B\", \"banana\")\n            ])) == false\n        );\n        assert!(\n            check_dict_case(HashMap::from([\n                (\"p\", \"pineapple\"),\n                (\"5\", \"banana\"),\n                (\"a\", \"apple\")\n            ])) == false\n        );\n        assert!(\n            check_dict_case(HashMap::from([\n                (\"Name\", \"John\"),\n                (\"Age\", \"36\"),\n                (\"City\", \"Houston\")\n            ])) == false\n        );\n        assert!(check_dict_case(HashMap::from([(\"STATE\", \"NC\"), (\"ZIP\", \"12345\")])) == true);\n        assert!(check_dict_case(HashMap::from([(\"fruit\", \"Orange\"), (\"taste\", \"Sweet\")])) == true);\n        assert!(check_dict_case(HashMap::new()) == false);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.", "prompt_explain": "Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n        assert!(check_dict_case(HashMap::new()) == false)", "func_title": "fn check_dict_case(dict:HashMap<&str, &str>) -> bool{\n\n", "prompt_text_chinese": "给定一个字典，如果所有键都是小写字符串或所有键都是大写字符串，则返回True，否则返回False。如果给定的字典为空，则函数应返回False。"}
{"task_id": "Rust/96", "prompt": "/*\nImplement a function that takes an non-negative integer and returns an array of the first n\n    integers that are prime numbers and less than n.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn count_up_to(n:i32) -> Vec<i32> {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn count_up_to(n:i32) -> Vec<i32> {\n\n", "canonical_solution": "\n    let mut primes: Vec<i32> = vec![];\n\n    for i in 2..n {\n        let mut is_prime: bool = true;\n\n        for j in 2..i {\n            if i % j == 0 {\n                is_prime = false;\n                break;\n            }\n        }\n        if is_prime {\n            primes.push(i);\n        }\n    }\n    return primes;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n\n    #[test]\n    fn test_count_up_to() {\n        assert!(count_up_to(5) == vec![2, 3]);\n        assert!(count_up_to(6) == vec![2, 3, 5]);\n        assert!(count_up_to(7) == vec![2, 3, 5]);\n        assert!(count_up_to(10) == vec![2, 3, 5, 7]);\n        assert!(count_up_to(0) == vec![]);\n        assert!(count_up_to(22) == vec![2, 3, 5, 7, 11, 13, 17, 19]);\n        assert!(count_up_to(1) == vec![]);\n        assert!(count_up_to(18) == vec![2, 3, 5, 7, 11, 13, 17]);\n        assert!(count_up_to(47) == vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]);\n        assert!(\n            count_up_to(101)\n                == vec![\n                    2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\n                    79, 83, 89, 97\n                ]\n        );\n    }\n\n}\n", "example_test": "None", "prompt_text": "Implement a function that takes an non-negative integer and returns an array of the first n\n    integers that are prime numbers and less than n.", "prompt_explain": "Implement a function that takes an non-negative integer and returns an array of the first n\n    integers that are prime numbers and less than n.\n        assert!(\n            count_up_to(101)\n                == vec![\n                    2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\n                    79, 83, 89, 97\n                ]\n        )", "func_title": "fn count_up_to(n:i32) -> Vec<i32> {\n\n", "prompt_text_chinese": "实现一个函数，该函数接受一个非负整数，并返回一个由前n个小于n的素数组成的数组。"}
{"task_id": "Rust/97", "prompt": "/*\nComplete the function that takes two integers and returns \n    the product of their unit digits.\n    Assume the input is always valid.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn multiply(a:i32, b:i32) -> i32{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn multiply(a:i32, b:i32) -> i32{\n\n", "canonical_solution": "\n    return (i32::abs(a) % 10) * (i32::abs(b) % 10);\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_multiply() {\n        assert!(multiply(148, 412) == 16);\n        assert!(multiply(19, 28) == 72);\n        assert!(multiply(2020, 1851) == 0);\n        assert!(multiply(14, -15) == 20);\n        assert!(multiply(76, 67) == 42);\n        assert!(multiply(17, 27) == 49);\n        assert!(multiply(0, 1) == 0);\n        assert!(multiply(0, 0) == 0);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Complete the function that takes two integers and returns \n    the product of their unit digits.\n    Assume the input is always valid.", "prompt_explain": "Complete the function that takes two integers and returns \n    the product of their unit digits.\n    Assume the input is always valid.\n        assert!(multiply(0, 0) == 0)", "func_title": "fn multiply(a:i32, b:i32) -> i32{\n\n", "prompt_text_chinese": "完成接受两个整数并返回其个位数乘积的函数。假设输入总是有效的。"}
{"task_id": "Rust/98", "prompt": "/*\n\n    Given a string s, count the number of uppercase vowels in even indices.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn count_upper(s:&str) -> i32 {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn count_upper(s:&str) -> i32 {\n\n", "canonical_solution": "\n    let uvowel: &str = \"AEIOU\";\n    let mut count: i32 = 0;\n\n    for (indx, elem) in s.chars().into_iter().enumerate() {\n        if indx % 2 == 0 {\n            if uvowel.contains(elem) {\n                count += 1;\n            }\n        }\n    }\n    return count;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_count_upper() {\n        assert!(count_upper(\"aBCdEf\") == 1);\n        assert!(count_upper(\"abcdefg\") == 0);\n        assert!(count_upper(\"dBBE\") == 0);\n        assert!(count_upper(\"B\") == 0);\n        assert!(count_upper(\"U\") == 1);\n        assert!(count_upper(\"\") == 0);\n        assert!(count_upper(\"EEEE\") == 2);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Given a string s, count the number of uppercase vowels in even indices.", "prompt_explain": "Given a string s, count the number of uppercase vowels in even indices.\n        assert!(count_upper(\"EEEE\") == 2)", "func_title": "fn count_upper(s:&str) -> i32 {\n\n", "prompt_text_chinese": "给定一个字符串s，数偶数下标中大写元音的个数。"}
{"task_id": "Rust/99", "prompt": "/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn closest_integer(value:&str) -> i32 {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn closest_integer(value:&str) -> i32 {\n\n", "canonical_solution": "\n    return value.parse::<f64>().unwrap().round() as i32;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n\n    #[test]\n    fn test_closest_integer() {\n        assert!(closest_integer(\"10\") == 10);\n        assert!(closest_integer(\"14.5\") == 15);\n        assert!(closest_integer(\"-15.5\") == -16);\n        assert!(closest_integer(\"15.3\") == 15);\n        assert!(closest_integer(\"0\") == 0);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Create a function that takes a value (string) representing a number and returns the closest integer to it. If the number is equidistant from two integers, round it away from zero.  Examples", "prompt_explain": "Create a function that takes a value (string) representing a number and returns the closest integer to it. If the number is equidistant from two integers, round it away from zero.  Examples\n        assert!(closest_integer(\"0\") == 0)", "func_title": "fn closest_integer(value:&str) -> i32 {\n\n", "prompt_text_chinese": "创建一个函数，接受一个表示数字的值(字符串)，并返回与之最接近的整数。如果数字与两个整数等距，则将其舍入至零。"}
{"task_id": "Rust/100", "prompt": "/*\n\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn make_a_pile(n:i32) -> Vec<i32>{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn make_a_pile(n:i32) -> Vec<i32>{\n\n", "canonical_solution": "\n    let mut out: Vec<i32> = vec![n];\n\n    for i in 1..n {\n        out.push(out[out.len() - 1] + 2);\n    }\n\n    return out;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_make_a_pile() {\n        assert!(make_a_pile(3) == vec![3, 5, 7]);\n        assert!(make_a_pile(4) == vec![4, 6, 8, 10]);\n        assert!(make_a_pile(5) == vec![5, 7, 9, 11, 13]);\n        assert!(make_a_pile(6) == vec![6, 8, 10, 12, 14, 16]);\n        assert!(make_a_pile(8) == vec![8, 10, 12, 14, 16, 18, 20, 22]);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Given a positive integer n, you have to make a pile of n levels of stones. The first level has n stones. The number of stones in the next level is: - the next odd number if n is odd. - the next even number if n is even. Return the number of stones in each level in a list, where element at index i represents the number of stones in the level (i+1).  Examples:", "prompt_explain": "Given a positive integer n, you have to make a pile of n levels of stones. The first level has n stones. The number of stones in the next level is: - the next odd number if n is odd. - the next even number if n is even. Return the number of stones in each level in a list, where element at index i represents the number of stones in the level (i+1).  Examples:\n        assert!(make_a_pile(8) == vec![8, 10, 12, 14, 16, 18, 20, 22])", "func_title": "fn make_a_pile(n:i32) -> Vec<i32>{\n\n", "prompt_text_chinese": "给定正整数n，你要堆n层石头。第一关有n个石头。下一层的石头数量是:-如果n是奇数，则下一个奇数。-如果n是偶数，则下一个偶数。返回列表中每一层的石头数量，其中元素索引i表示该层的石头数量(i+1)。"}
{"task_id": "Rust/101", "prompt": "/*\n\n    You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words and return an array of the words.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn words_string(s:&str) -> Vec<String> {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn words_string(s:&str) -> Vec<String> {\n\n", "canonical_solution": "\n    return s\n        .to_string()\n        .split(|c: char| c == ',' || c.is_whitespace())\n        .into_iter()\n        .filter(|x| x != &\"\")\n        .map(|x| x.to_string())\n        .collect();\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_words_string() {\n        assert!(words_string(\"Hi, my name is John\") == vec![\"Hi\", \"my\", \"name\", \"is\", \"John\"]);\n        assert!(\n            words_string(\"One, two, three, four, five, six\")\n                == vec![\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n        );\n        assert!(words_string(\"Hi, my name\") == vec![\"Hi\", \"my\", \"name\"]);\n        assert!(\n            words_string(\"One,, two, three, four, five, six,\")\n                == vec![\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n        );\n        let v_empty: Vec<String> = vec![];\n        assert!(words_string(\"\") == v_empty);\n        assert!(words_string(\"ahmed , gamal\") == vec![\"ahmed\", \"gamal\"]);\n    }\n\n}\n", "example_test": "None", "prompt_text": "You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words and return an array of the words.", "prompt_explain": "You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words and return an array of the words.\n        assert!(words_string(\"ahmed , gamal\") == vec![\"ahmed\", \"gamal\"])", "func_title": "fn words_string(s:&str) -> Vec<String> {\n\n", "prompt_text_chinese": "你将得到一串由逗号或空格分隔的单词。您的任务是将字符串拆分为单词并返回单词数组。"}
{"task_id": "Rust/102", "prompt": "/*\nThis function takes two positive numbers x and y and returns the\n    biggest even integer number that is in the range [x, y] inclusive. If \n    there's no such number, then the function should return -1.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn choose_num(x:i32, y:i32) -> i32{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn choose_num(x:i32, y:i32) -> i32{\n\n", "canonical_solution": "\n    if y < x {\n        return -1;\n    }\n    if y == x && y % 2 == 1 {\n        return -1;\n    }\n    if y % 2 == 1 {\n        return y - 1;\n    }\n    return y;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_choose_num() {\n        assert!(choose_num(12, 15) == 14);\n        assert!(choose_num(13, 12) == -1);\n        assert!(choose_num(33, 12354) == 12354);\n        assert!(choose_num(6, 29) == 28);\n        assert!(choose_num(27, 10) == -1);\n        assert!(choose_num(7, 7) == -1);\n        assert!(choose_num(546, 546) == 546);\n    }\n\n}\n", "example_test": "None", "prompt_text": "This function takes two positive numbers x and y and returns the\n    biggest even integer number that is in the range [x, y] inclusive. If \n    there's no such number, then the function should return -1.", "prompt_explain": "This function takes two positive numbers x and y and returns the\n    biggest even integer number that is in the range [x, y] inclusive. If \n    there's no such number, then the function should return -1.\n        assert!(choose_num(546, 546) == 546)", "func_title": "fn choose_num(x:i32, y:i32) -> i32{\n\n", "prompt_text_chinese": "此函数接受两个正数x和y，并返回包含[x, y]的范围内最大的偶数。如果没有这样的数字，那么函数应该返回-1。"}
{"task_id": "Rust/103", "prompt": "/*\nYou are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn rounded_avg(n:i32, m:i32) -> String{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn rounded_avg(n:i32, m:i32) -> String{\n\n", "canonical_solution": "\n    if n > m {\n        return \"-1\".to_string();\n    };\n    let mut num: i32 = (m + n) / 2;\n    let mut out: String = String::from(\"\");\n    while num > 0 {\n        out = (num % 2).to_string() + &out;\n        num = num / 2;\n    }\n    return out;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_rounded_avg() {\n        assert!(rounded_avg(1, 5) == \"11\");\n        assert!(rounded_avg(7, 13) == \"1010\");\n        assert!(rounded_avg(964, 977) == \"1111001010\");\n        assert!(rounded_avg(996, 997) == \"1111100100\");\n        assert!(rounded_avg(560, 851) == \"1011000001\");\n        assert!(rounded_avg(185, 546) == \"101101101\");\n        assert!(rounded_avg(362, 496) == \"110101101\");\n        assert!(rounded_avg(350, 902) == \"1001110010\");\n        assert!(rounded_avg(197, 233) == \"11010111\");\n        assert!(rounded_avg(7, 5) == \"-1\");\n        assert!(rounded_avg(5, 1) == \"-1\");\n        assert!(rounded_avg(5, 5) == \"101\");\n    }\n\n}\n", "example_test": "None", "prompt_text": "You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.", "prompt_explain": "You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n        assert!(rounded_avg(5, 5) == \"101\")", "func_title": "fn rounded_avg(n:i32, m:i32) -> String{\n\n", "prompt_text_chinese": "你有两个正整数n和m，你的任务是计算从n到m的整数的平均值(包括n和m)。四舍五入到最接近的整数并将其转换为二进制。如果n大于m，则返回-1。"}
{"task_id": "Rust/104", "prompt": "/*\nGiven a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn unique_digits(x:Vec<i32>) -> Vec<i32>{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn unique_digits(x:Vec<i32>) -> Vec<i32>{\n\n", "canonical_solution": "\n    let mut res: Vec<i32> = vec![];\n    for (_, elem) in x.into_iter().enumerate() {\n        let mut elem_cp: i32 = elem;\n        let mut u: bool = true;\n        if elem == 0 {\n            u = false;\n        }\n        while elem_cp > 0 && u {\n            if elem_cp % 2 == 0 {\n                u = false;\n            }\n            elem_cp = elem_cp / 10;\n        }\n        if u {\n            res.push(elem)\n        };\n    }\n    res.sort();\n    return res;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_unique_digits() {\n        assert!(unique_digits(vec![15, 33, 1422, 1]) == vec![1, 15, 33]);\n        assert!(unique_digits(vec![152, 323, 1422, 10]) == vec![]);\n        assert!(unique_digits(vec![12345, 2033, 111, 151]) == vec![111, 151]);\n        assert!(unique_digits(vec![135, 103, 31]) == vec![31, 135]);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Given a list of positive integers x. return a sorted list of all elements that hasn't any even digit.  Note: Returned list should be sorted in increasing order.  For example:", "prompt_explain": "Given a list of positive integers x. return a sorted list of all elements that hasn't any even digit.  Note: Returned list should be sorted in increasing order.  For example:\n        assert!(unique_digits(vec![135, 103, 31]) == vec![31, 135])", "func_title": "fn unique_digits(x:Vec<i32>) -> Vec<i32>{\n\n", "prompt_text_chinese": "给定一个正整数列表，x返回一个由所有不含偶数的元素组成的有序列表。备注:返回的列表应按递增顺序排序。"}
{"task_id": "Rust/105", "prompt": "/*\n\n    Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn by_length(arr:Vec<i32>) -> Vec<String>{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn by_length(arr:Vec<i32>) -> Vec<String>{\n\n", "canonical_solution": "\n    let mut res: Vec<String> = vec![];\n    let mut arr_cp: Vec<i32> = arr.clone();\n    arr_cp.sort();\n    arr_cp.reverse();\n    let map: HashMap<i32, &str> = HashMap::from([\n        (0, \"Zero\"),\n        (1, \"One\"),\n        (2, \"Two\"),\n        (3, \"Three\"),\n        (4, \"Four\"),\n        (5, \"Five\"),\n        (6, \"Six\"),\n        (7, \"Seven\"),\n        (8, \"Eight\"),\n        (9, \"Nine\"),\n    ]);\n\n    for elem in arr_cp {\n        if elem >= 1 && elem <= 9 {\n            res.push(map.get(&elem).unwrap().to_string());\n        }\n    }\n\n    return res;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_by_length() {\n        assert!(\n            by_length(vec![2, 1, 1, 4, 5, 8, 2, 3])\n                == vec![\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n        );\n        let v_empty: Vec<String> = vec![];\n        assert!(by_length(vec![]) == v_empty);\n        assert!(by_length(vec![1, -1, 55]) == vec![\"One\"]);\n        assert!(by_length(vec![1, -1, 3, 2]) == vec![\"Three\", \"Two\", \"One\"]);\n        assert!(by_length(vec![9, 4, 8]) == vec![\"Nine\", \"Eight\", \"Four\"]);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".", "prompt_explain": "Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n        assert!(by_length(vec![9, 4, 8]) == vec![\"Nine\", \"Eight\", \"Four\"])", "func_title": "fn by_length(arr:Vec<i32>) -> Vec<String>{\n\n", "prompt_text_chinese": "给定一个整数数组，对1到9之间的整数进行排序，反转结果数组，然后将每个数字替换为对应的名称，从“One”，“Two”，“Three”，“Four”，“Five”，“Six”，“Seven”，“Eight”，“Nine”。"}
{"task_id": "Rust/106", "prompt": "/*\n Implement the function f that takes n as a parameter,\n    and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n    or the sum of numbers from 1 to i otherwise.\n    i starts from 1.\n    the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn f(n:i32) -> Vec<i32>{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn f(n:i32) -> Vec<i32>{\n\n", "canonical_solution": "\n    let mut sum: i32 = 0;\n    let mut prod: i32 = 1;\n    let mut out: Vec<i32> = vec![];\n\n    for i in 1..n + 1 {\n        sum += i;\n        prod *= i;\n\n        if i % 2 == 0 {\n            out.push(prod);\n        } else {\n            out.push(sum)\n        };\n    }\n    return out;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_f() {\n        assert!(f(5) == vec![1, 2, 6, 24, 15]);\n        assert!(f(7) == vec![1, 2, 6, 24, 15, 720, 28]);\n        assert!(f(1) == vec![1]);\n        assert!(f(3) == vec![1, 2, 6]);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Implement the function f that takes n as a parameter,\n    and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n    or the sum of numbers from 1 to i otherwise.\n    i starts from 1.\n    the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).", "prompt_explain": "Implement the function f that takes n as a parameter,\n    and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n    or the sum of numbers from 1 to i otherwise.\n    i starts from 1.\n    the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n        assert!(f(3) == vec![1, 2, 6])", "func_title": "fn f(n:i32) -> Vec<i32>{\n\n", "prompt_text_chinese": "实现以n为参数的函数f，并返回一个大小为n的列表，如果i是偶数，则索引i处元素的值为i的阶乘，否则为从1到i的数字的和。I从1开始。I的阶乘是从1到I的数的乘法(1 * 2 *…*我)。"}
{"task_id": "Rust/107", "prompt": "/*\n\n    Given a positive integer n, return a tuple that has the number of even and odd\n    integer palindromes that fall within the range(1, n), inclusive.\n\n    Note:\n        1. 1 <= n <= 10^3\n        2. returned tuple has the number of even and odd integer palindromes respectively.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn even_odd_palindrome(n: i32) -> (i32, i32) {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn even_odd_palindrome(n: i32) -> (i32, i32) {\n\n", "canonical_solution": "\n    let mut even = 0;\n    let mut odd = 0;\n\n    for i in 1..n + 1 {\n        let mut w: String = i.to_string();\n        let mut p: String = w.chars().rev().collect();\n\n        if w == p && i % 2 == 1 {\n            odd += 1;\n        }\n        if w == p && i % 2 == 0 {\n            even += 1;\n        }\n    }\n    (even, odd)\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_even_odd_palindrome() {\n        assert!(even_odd_palindrome(123) == (8, 13));\n        assert!(even_odd_palindrome(12) == (4, 6));\n        assert!(even_odd_palindrome(3) == (1, 2));\n        assert!(even_odd_palindrome(63) == (6, 8));\n        assert!(even_odd_palindrome(25) == (5, 6));\n        assert!(even_odd_palindrome(19) == (4, 6));\n        assert!(even_odd_palindrome(9) == (4, 5));\n        assert!(even_odd_palindrome(1) == (0, 1));\n    }\n\n}\n", "example_test": "None", "prompt_text": "Given a positive integer n, return a tuple that has the number of even and odd\n    integer palindromes that fall within the range(1, n), inclusive.", "prompt_explain": "Given a positive integer n, return a tuple that has the number of even and odd\n    integer palindromes that fall within the range(1, n), inclusive.\n        assert!(even_odd_palindrome(1) == (0, 1))", "func_title": "fn even_odd_palindrome(n: i32) -> (i32, i32) {\n\n", "prompt_text_chinese": "给定一个正整数n，返回一个元组，其中包含(1,n)范围内的偶数和奇数整数回文。"}
{"task_id": "Rust/108", "prompt": "/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn count_nums(n:Vec<i32>) -> i32{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn count_nums(n:Vec<i32>) -> i32{\n\n", "canonical_solution": "\n    let mut num: i32 = 0;\n\n    for nmbr in n {\n        if nmbr > 0 {\n            num += 1;\n        } else {\n            let mut sum: i32 = 0;\n            let mut w: i32;\n            w = i32::abs(nmbr);\n\n            while w >= 10 {\n                sum += w % 10;\n                w = w / 10;\n            }\n            sum -= w;\n            if sum > 0 {\n                num += 1;\n            }\n        }\n    }\n    return num;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_count_nums() {\n        assert!(count_nums(vec![]) == 0);\n        assert!(count_nums(vec![-1, -2, 0]) == 0);\n        assert!(count_nums(vec![1, 1, 2, -2, 3, 4, 5]) == 6);\n        assert!(count_nums(vec![1, 6, 9, -6, 0, 1, 5]) == 5);\n        assert!(count_nums(vec![1, 100, 98, -7, 1, -1]) == 4);\n        assert!(count_nums(vec![12, 23, 34, -45, -56, 0]) == 5);\n        assert!(count_nums(vec![-0, 1]) == 1);\n        assert!(count_nums(vec![1]) == 1);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Write a function count_nums which takes an array of integers and returns the number of elements which has a sum of digits > 0. If a number is negative, then its first signed digit will be negative: e.g. -123 has signed digits -1, 2, and 3.", "prompt_explain": "Write a function count_nums which takes an array of integers and returns the number of elements which has a sum of digits > 0. If a number is negative, then its first signed digit will be negative: e.g. -123 has signed digits -1, 2, and 3.\n        assert!(count_nums(vec![1]) == 1)", "func_title": "fn count_nums(n:Vec<i32>) -> i32{\n\n", "prompt_text_chinese": "编写一个函数count_nums，它接受一个整数数组，并返回具有数字和> 0的元素数。如果一个数字是负的，那么它的第一个有符号的数字将是负的:例如-123有符号的数字-1、2和3。"}
{"task_id": "Rust/109", "prompt": "/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return True else return False.\n    If the given array is empty then return True.\n\n    Note: The given list is guaranteed to have unique elements.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn move_one_ball(arr:Vec<i32>) -> bool{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn move_one_ball(arr:Vec<i32>) -> bool{\n\n", "canonical_solution": "\n    let mut num = 0;\n    if arr.len() == 0 {\n        return true;\n    }\n    for i in 1..arr.len() {\n        if arr[i] < arr[i - 1] {\n            num += 1;\n        }\n    }\n    if arr[arr.len() - 1] > arr[0] {\n        num += 1;\n    }\n    if num < 2 {\n        return true;\n    }\n    return false;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_move_one_ball() {\n        assert!(move_one_ball(vec![3, 4, 5, 1, 2]) == true);\n        assert!(move_one_ball(vec![3, 5, 10, 1, 2]) == true);\n        assert!(move_one_ball(vec![4, 3, 1, 2]) == false);\n        assert!(move_one_ball(vec![3, 5, 4, 1, 2]) == false);\n        assert!(move_one_ball(vec![]) == true);\n    }\n\n}\n", "example_test": "None", "prompt_text": "We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return True else return False.\n    If the given array is empty then return True.\n\n    Note: The given list is guaranteed to have unique elements.", "prompt_explain": "We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return True else return False.\n    If the given array is empty then return True.\n\n    Note: The given list is guaranteed to have unique elements.\n        assert!(move_one_ball(vec![]) == true)", "func_title": "fn move_one_ball(arr:Vec<i32>) -> bool{\n\n", "prompt_text_chinese": "我们有一个N个整数的数组'arr' arr[1]， arr[2]，…, arr [N]。数组中的数字将是随机排序的。您的任务是确定是否有可能通过对给定数组执行以下操作以非递减顺序排序数组:您被允许执行右移操作任意次数。一次右移操作意味着将数组的所有元素向右移动一个位置。数组的最后一个元素将被移动到数组的起始位置，即第0个索引。如果可以通过执行上述操作获得排序后的数组，则返回True否则返回False。如果给定数组为空，则返回True。注意:给定的列表保证有唯一的元素。"}
{"task_id": "Rust/110", "prompt": "/*\nIn this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n\n    It is assumed that the input lists will be non-empty.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn exchange(lst1:Vec<i32>, lst2:Vec<i32>) -> String{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn exchange(lst1:Vec<i32>, lst2:Vec<i32>) -> String{\n\n", "canonical_solution": "\n    let mut num = 0;\n    for i in 0..lst1.len() {\n        if lst1[i] % 2 == 0 {\n            num += 1;\n        }\n    }\n    for i in 0..lst2.len() {\n        if lst2[i] % 2 == 0 {\n            num += 1;\n        }\n    }\n    if num >= lst1.len() {\n        return \"YES\".to_string();\n    }\n    return \"NO\".to_string();\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_exchange() {\n        assert!(exchange(vec![1, 2, 3, 4], vec![1, 2, 3, 4]) == \"YES\");\n        assert!(exchange(vec![1, 2, 3, 4], vec![1, 5, 3, 4]) == \"NO\");\n        assert!(exchange(vec![1, 2, 3, 4], vec![2, 1, 4, 3]) == \"YES\");\n        assert!(exchange(vec![5, 7, 3], vec![2, 6, 4]) == \"YES\");\n        assert!(exchange(vec![5, 7, 3], vec![2, 6, 3]) == \"NO\");\n        assert!(exchange(vec![3, 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1, 1]) == \"NO\");\n        assert!(exchange(vec![100, 200], vec![200, 200]) == \"YES\");\n    }\n\n}\n", "example_test": "None", "prompt_text": "In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".", "prompt_explain": "In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n        assert!(exchange(vec![100, 200], vec![200, 200]) == \"YES\")", "func_title": "fn exchange(lst1:Vec<i32>, lst2:Vec<i32>) -> String{\n\n", "prompt_text_chinese": "在这个问题中，您将实现一个函数，该函数接受两个数字列表，并确定是否可以在它们之间执行元素交换，以使lst1成为仅包含偶数的列表。lst1和lst2之间交换的元素数量没有限制。如果可以在lst1和lst2之间交换元素，使lst1的所有元素为偶数，则返回\"YES\"。否则，返回“NO”。"}
{"task_id": "Rust/111", "prompt": "/*\nGiven a string representing a space separated lowercase letters, return a dictionary\n    of the letter with the most repetition and containing the corresponding count.\n    If several letters have the same occurrence, return all of them.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn histogram(test:&str) -> HashMap<char, i32>{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn histogram(test:&str) -> HashMap<char, i32>{\n\n", "canonical_solution": "\n    let mut res: HashMap<char, i32> = HashMap::new();\n    if test == \"\" {\n        return res;\n    }\n    for c in test.split_ascii_whitespace() {\n        if res.contains_key(&c.chars().next().unwrap()) {\n            res.entry(c.chars().next().unwrap()).and_modify(|n| {\n                *n += 1;\n            });\n        } else {\n            res.insert(c.chars().next().unwrap(), 1);\n        }\n    }\n    let max: i32 = *res.values().max().unwrap();\n    let non_maxs: Vec<char> = res\n        .keys()\n        .filter(|k: &&char| *res.get(k).unwrap() != max)\n        .map(|c| *c)\n        .collect();\n    non_maxs.iter().for_each(|c| {\n        res.remove(c);\n    });\n\n    return res;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_histogram() {\n        assert!(histogram(\"a b b a\") == HashMap::from([('a', 2), ('b', 2)]));\n        assert!(histogram(\"a b c a b\") == HashMap::from([('a', 2), ('b', 2)]));\n        assert!(\n            histogram(\"a b c d g\")\n                == HashMap::from([('a', 1), ('b', 1), ('c', 1), ('d', 1), ('g', 1)])\n        );\n        assert!(histogram(\"r t g\") == HashMap::from([('r', 1), ('t', 1), ('g', 1)]));\n        assert!(histogram(\"b b b b a\") == HashMap::from([('b', 4)]));\n        assert!(histogram(\"r t g\") == HashMap::from([('r', 1), ('t', 1), ('g', 1)]));\n        assert!(histogram(\"\") == HashMap::new());\n        assert!(histogram(\"a\") == HashMap::from([(('a', 1))]));\n    }\n\n}\n", "example_test": "None", "prompt_text": "Given a string representing a space separated lowercase letters, return a dictionary\n    of the letter with the most repetition and containing the corresponding count.\n    If several letters have the same occurrence, return all of them.", "prompt_explain": "Given a string representing a space separated lowercase letters, return a dictionary\n    of the letter with the most repetition and containing the corresponding count.\n    If several letters have the same occurrence, return all of them.\n        assert!(histogram(\"a\") == HashMap::from([(('a', 1))]))", "func_title": "fn histogram(test:&str) -> HashMap<char, i32>{\n\n", "prompt_text_chinese": "给定一个表示空格分隔的小写字母的字符串，返回重复次数最多且包含相应计数的字母字典。如果有几个字母出现相同的情况，则返回所有字母。"}
{"task_id": "Rust/112", "prompt": "/*\nTask\n    We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n    then check if the result string is palindrome.\n    A string is called palindrome if it reads the same backward as forward.\n    You should return a tuple containing the result string and True/False for the check.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn reverse_delete(s:&str, c:&str) -> Vec<String> {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn reverse_delete(s:&str, c:&str) -> Vec<String> {\n\n", "canonical_solution": "\n    let mut n = String::new();\n    for i in 0..s.len() {\n        if !c.contains(s.chars().nth(i).unwrap()) {\n            n.push(s.chars().nth(i).unwrap());\n        }\n    }\n    if n.len() == 0 {\n        return vec![n, \"True\".to_string()];\n    }\n    let w: String = n.chars().rev().collect();\n    if w == n {\n        return vec![n, \"True\".to_string()];\n    }\n    return vec![n, \"False\".to_string()];\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_reverse_delete() {\n        assert!(reverse_delete(\"abcde\", \"ae\") == [\"bcd\", \"False\"]);\n        assert!(reverse_delete(\"abcdef\", \"b\") == [\"acdef\", \"False\"]);\n        assert!(reverse_delete(\"abcdedcba\", \"ab\") == [\"cdedc\", \"True\"]);\n        assert!(reverse_delete(\"dwik\", \"w\") == [\"dik\", \"False\"]);\n        assert!(reverse_delete(\"a\", \"a\") == [\"\", \"True\"]);\n        assert!(reverse_delete(\"abcdedcba\", \"\") == [\"abcdedcba\", \"True\"]);\n        assert!(reverse_delete(\"abcdedcba\", \"v\") == [\"abcdedcba\", \"True\"]);\n        assert!(reverse_delete(\"vabba\", \"v\") == [\"abba\", \"True\"]);\n        assert!(reverse_delete(\"mamma\", \"mia\") == [\"\", \"True\"]);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Task\n    We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n    then check if the result string is palindrome.\n    A string is called palindrome if it reads the same backward as forward.\n    You should return a tuple containing the result string and True/False for the check.", "prompt_explain": "Task\n    We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n    then check if the result string is palindrome.\n    A string is called palindrome if it reads the same backward as forward.\n    You should return a tuple containing the result string and True/False for the check.\n        assert!(reverse_delete(\"mamma\", \"mia\") == [\"\", \"True\"])", "func_title": "fn reverse_delete(s:&str, c:&str) -> Vec<String> {\n\n", "prompt_text_chinese": "我们有两个字符串s和c，你必须删除s中所有等于c中的任何字符的字符，然后检查结果字符串是否为回文。一个字符串如果向前和向后读是一样的，就叫做回文。您应该返回一个元组，其中包含检查的结果字符串和True/False。"}
{"task_id": "Rust/113", "prompt": "/*\nGiven a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn odd_count(lst:Vec<&str>) -> Vec<String>{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn odd_count(lst:Vec<&str>) -> Vec<String>{\n\n", "canonical_solution": "\n    let mut out: Vec<String> = Vec::new();\n    for i in 0..lst.len() {\n        let mut sum = 0;\n        for j in 0..lst[i].len() {\n            if lst[i].chars().nth(j).unwrap() >= '0'\n                && lst[i].chars().nth(j).unwrap() <= '9'\n                && lst[i].chars().nth(j).unwrap().to_digit(10).unwrap() % 2 == 1\n            {\n                sum += 1;\n            }\n        }\n        let mut s = \"the number of odd elements in the string i of the input.\".to_string();\n        let mut s2 = \"\".to_string();\n        for j in 0..s.len() {\n            if s.chars().nth(j).unwrap() == 'i' {\n                s2.push_str(&sum.to_string());\n            } else {\n                s2.push(s.chars().nth(j).unwrap());\n            }\n        }\n        out.push(s2);\n    }\n    return out;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_odd_count() {\n        assert!(\n            odd_count(vec![\"1234567\"])\n                == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n        );\n        assert!(\n            odd_count(vec![\"3\", \"11111111\"])\n                == [\n                    \"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n                    \"the number of odd elements 8n the str8ng 8 of the 8nput.\"\n                ]\n        );\n        assert!(\n            odd_count(vec![\"271\", \"137\", \"314\"])\n                == [\n                    \"the number of odd elements 2n the str2ng 2 of the 2nput.\",\n                    \"the number of odd elements 3n the str3ng 3 of the 3nput.\",\n                    \"the number of odd elements 2n the str2ng 2 of the 2nput.\"\n                ]\n        );\n    }\n\n}\n", "example_test": "None", "prompt_text": "Given a list of strings, where each string consists of only digits, return a list. Each element i of the output should be \"the number of odd elements in the string i of the input.\" where all the i's should be replaced by the number of odd digits in the i'th string of the input. ", "prompt_explain": "Given a list of strings, where each string consists of only digits, return a list. Each element i of the output should be \"the number of odd elements in the string i of the input.\" where all the i's should be replaced by the number of odd digits in the i'th string of the input. \n        assert!(\n            odd_count(vec![\"271\", \"137\", \"314\"])\n                == [\n                    \"the number of odd elements 2n the str2ng 2 of the 2nput.\",\n                    \"the number of odd elements 3n the str3ng 3 of the 3nput.\",\n                    \"the number of odd elements 2n the str2ng 2 of the 2nput.\"\n                ]\n        )", "func_title": "fn odd_count(lst:Vec<&str>) -> Vec<String>{\n\n", "prompt_text_chinese": "给定一个字符串列表，其中每个字符串仅由数字组成，返回一个列表。输出的每个元素i应该是输入的字符串i中奇数元素的数量。其中所有的i都应该被输入的第i个字符串中的奇数位数所取代。"}
{"task_id": "Rust/114", "prompt": "/*\n\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn min_sub_array_sum(nums: Vec<i64>) -> i64 {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn min_sub_array_sum(nums: Vec<i64>) -> i64 {\n\n", "canonical_solution": "\n    let mut current = nums[0];\n    let mut min = nums[0];\n    for i in 1..nums.len() {\n        if current < 0 {\n            current = current + nums[i];\n        } else {\n            current = nums[i];\n        }\n        if current < min {\n            min = current;\n        }\n    }\n    min\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_min_sub_array_sum() {\n        assert!(min_sub_array_sum(vec![2, 3, 4, 1, 2, 4]) == 1);\n        assert!(min_sub_array_sum(vec![-1, -2, -3]) == -6);\n        assert!(min_sub_array_sum(vec![-1, -2, -3, 2, -10]) == -14);\n        assert!(min_sub_array_sum(vec![-9999999999999999]) == -9999999999999999);\n        assert!(min_sub_array_sum(vec![0, 10, 20, 1000000]) == 0);\n        assert!(min_sub_array_sum(vec![-1, -2, -3, 10, -5]) == -6);\n        assert!(min_sub_array_sum(vec![100, -1, -2, -3, 10, -5]) == -6);\n        assert!(min_sub_array_sum(vec![10, 11, 13, 8, 3, 4]) == 3);\n        assert!(min_sub_array_sum(vec![100, -33, 32, -1, 0, -2]) == -33);\n        assert!(min_sub_array_sum(vec![-10]) == -10);\n        assert!(min_sub_array_sum(vec![7]) == 7);\n        assert!(min_sub_array_sum(vec![1, -1]) == -1);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums. ", "prompt_explain": "Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums. \n        assert!(min_sub_array_sum(vec![1, -1]) == -1)", "func_title": "fn min_sub_array_sum(nums: Vec<i64>) -> i64 {\n\n", "prompt_text_chinese": "给定一个整数数组nums，找出nums的任何非空子数组的最小和。"}
{"task_id": "Rust/115", "prompt": "/*\n    You are given a rectangular grid of wells. Each row represents a single well,\n    and each 1 in a row represents a single unit of water.\n    Each well has a corresponding bucket that can be used to extract water from it, \n    and all buckets have the same capacity.\n    Your task is to use the buckets to empty the wells.\n    Output the number of times you need to lower the buckets.\n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn max_fill(grid:Vec<Vec<i32>>, capacity:i32) -> i32{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn max_fill(grid:Vec<Vec<i32>>, capacity:i32) -> i32{\n\n", "canonical_solution": "\n    let mut out: i32 = 0;\n\n    for i in 0..grid.len() {\n        let mut sum: i32 = 0;\n\n        for j in 0..grid[i].len() {\n            sum += grid[i][j];\n        }\n        if sum > 0 {\n            out += (sum - 1) / capacity + 1;\n        }\n    }\n    return out;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_max_fill() {\n        assert!(\n            max_fill(\n                vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]],\n                1\n            ) == 6\n        );\n        assert!(\n            max_fill(\n                vec![\n                    vec![0, 0, 1, 1],\n                    vec![0, 0, 0, 0],\n                    vec![1, 1, 1, 1],\n                    vec![0, 1, 1, 1]\n                ],\n                2\n            ) == 5\n        );\n        assert!(max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5) == 0);\n        assert!(max_fill(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 2) == 4);\n        assert!(max_fill(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 9) == 2);\n    }\n\n}\n", "example_test": "None", "prompt_text": "You are given a rectangular grid of wells. Each row represents a single well,\n    and each 1 in a row represents a single unit of water.\n    Each well has a corresponding bucket that can be used to extract water from it, \n    and all buckets have the same capacity.\n    Your task is to use the buckets to empty the wells.\n    Output the number of times you need to lower the buckets. ", "prompt_explain": "You are given a rectangular grid of wells. Each row represents a single well,\n    and each 1 in a row represents a single unit of water.\n    Each well has a corresponding bucket that can be used to extract water from it, \n    and all buckets have the same capacity.\n    Your task is to use the buckets to empty the wells.\n    Output the number of times you need to lower the buckets. \n        assert!(max_fill(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 9) == 2)", "func_title": "fn max_fill(grid:Vec<Vec<i32>>, capacity:i32) -> i32{\n\n", "prompt_text_chinese": "给你一个矩形网格的井。每一行代表一口井，每一行中的每一个1代表一个单位的水。每口井都有一个对应的桶，可以用来从井里取水，所有的桶都有相同的容量。你的任务是用水桶把井里的水倒空。输出需要降低桶的次数。"}
{"task_id": "Rust/116", "prompt": "/*\n\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn sort_array_1(arr:Vec<i32>) -> Vec<i32>{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn sort_array_1(arr:Vec<i32>) -> Vec<i32>{\n\n", "canonical_solution": "\n    let mut arr_cp = arr.clone();\n    let mut bin = vec![];\n    let mut m;\n\n    for i in 0..arr_cp.len() {\n        let mut b = 0;\n        let mut n = arr_cp[i].abs();\n        while n > 0 {\n            b += n % 2;\n            n = n / 2;\n        }\n        bin.push(b);\n    }\n    for i in 0..arr_cp.len() {\n        for j in 1..arr_cp.len() {\n            if bin[j] < bin[j - 1] || (bin[j] == bin[j - 1] && arr_cp[j] < arr_cp[j - 1]) {\n                m = arr_cp[j];\n                arr_cp[j] = arr_cp[j - 1];\n                arr_cp[j - 1] = m;\n                m = bin[j];\n                bin[j] = bin[j - 1];\n                bin[j - 1] = m;\n            }\n        }\n    }\n    return arr_cp;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_sort_array_1() {\n        assert!(sort_array_1(vec![1, 5, 2, 3, 4]) == vec![1, 2, 4, 3, 5]);\n        assert!(sort_array_1(vec![-2, -3, -4, -5, -6]) == vec![-4, -2, -6, -5, -3]);\n        assert!(sort_array_1(vec![1, 0, 2, 3, 4]) == vec![0, 1, 2, 4, 3]);\n        assert!(sort_array_1(vec![]) == vec![]);\n        assert!(\n            sort_array_1(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])\n                == vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n        );\n        assert!(sort_array_1(vec![3, 6, 44, 12, 32, 5]) == vec![32, 3, 5, 6, 12, 44]);\n        assert!(sort_array_1(vec![2, 4, 8, 16, 32]) == vec![2, 4, 8, 16, 32]);\n        assert!(sort_array_1(vec![2, 4, 8, 16, 32]) == vec![2, 4, 8, 16, 32]);\n    }\n\n}\n", "example_test": "None", "prompt_text": "In this Kata, you have to sort an array of non-negative integers according to number of ones in their binary representation in ascending order. For similar number of ones, sort based on decimal value.  It must be implemented like this:", "prompt_explain": "In this Kata, you have to sort an array of non-negative integers according to number of ones in their binary representation in ascending order. For similar number of ones, sort based on decimal value.  It must be implemented like this:\n        assert!(sort_array_1(vec![2, 4, 8, 16, 32]) == vec![2, 4, 8, 16, 32])", "func_title": "fn sort_array_1(arr:Vec<i32>) -> Vec<i32>{\n\n", "prompt_text_chinese": "在这个型中，您必须根据二进制表示中的1的数量对非负整数数组进行升序排序。对于相同数量的1，根据十进制值排序。"}
{"task_id": "Rust/117", "prompt": "/*\nGiven a string s and a natural number n, you have been tasked to implement \n    a function that returns a list of all words from string s that contain exactly \n    n consonants, in order these words appear in the string s.\n    If the string s is empty then the function should return an empty list.\n    Note: you may assume the input string contains only letters and spaces.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn select_words(s:&str, n:i32) -> Vec<String>{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn select_words(s:&str, n:i32) -> Vec<String>{\n\n", "canonical_solution": "\n    let vowels = \"aeiouAEIOU\";\n    let mut current = String::new();\n    let mut out = Vec::new();\n    let mut numc = 0;\n    let mut s = s.to_string();\n    s.push(' ');\n    for i in 0..s.len() {\n        if s.chars().nth(i).unwrap() == ' ' {\n            if numc == n {\n                out.push(current);\n            }\n            current = String::new();\n            numc = 0;\n        } else {\n            current.push(s.chars().nth(i).unwrap());\n            if (s.chars().nth(i).unwrap() >= 'A' && s.chars().nth(i).unwrap() <= 'Z')\n                || (s.chars().nth(i).unwrap() >= 'a' && s.chars().nth(i).unwrap() <= 'z')\n            {\n                if !vowels.contains(s.chars().nth(i).unwrap()) {\n                    numc += 1;\n                }\n            }\n        }\n    }\n    out\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_select_words() {\n        assert_eq!(select_words(\"Mary had a little lamb\", 4), vec![\"little\"]);\n        assert_eq!(\n            select_words(\"Mary had a little lamb\", 3),\n            vec![\"Mary\", \"lamb\"]\n        );\n        let v_empty: Vec<&str> = vec![];\n        assert_eq!(select_words(\"simple white space\", 2), v_empty);\n        assert_eq!(select_words(\"Hello world\", 4), vec![\"world\"]);\n        assert_eq!(select_words(\"Uncle sam\", 3), vec![\"Uncle\"]);\n        assert_eq!(select_words(\"\", 4), v_empty);\n        assert_eq!(select_words(\"a b c d e f\", 1), vec![\"b\", \"c\", \"d\", \"f\"]);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Given a string s and a natural number n, you have been tasked to implement \n    a function that returns a list of all words from string s that contain exactly \n    n consonants, in order these words appear in the string s.\n    If the string s is empty then the function should return an empty list.\n    Note: you may assume the input string contains only letters and spaces.", "prompt_explain": "Given a string s and a natural number n, you have been tasked to implement \n    a function that returns a list of all words from string s that contain exactly \n    n consonants, in order these words appear in the string s.\n    If the string s is empty then the function should return an empty list.\n    Note: you may assume the input string contains only letters and spaces.\n        assert_eq!(select_words(\"a b c d e f\", 1), vec![\"b\", \"c\", \"d\", \"f\"])", "func_title": "fn select_words(s:&str, n:i32) -> Vec<String>{\n\n", "prompt_text_chinese": "给定一个字符串s和一个自然数n，你的任务是实现一个函数，返回字符串s中包含n个辅音的所有单词的列表，按照这些单词出现在字符串s中的顺序。如果字符串s是空的，那么函数应该返回一个空列表。注意:您可以假设输入字符串只包含字母和空格。"}
{"task_id": "Rust/118", "prompt": "/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn get_closest_vowel(word: &str) -> String {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn get_closest_vowel(word: &str) -> String {\n\n", "canonical_solution": "\n    let vowels = \"AEIOUaeiou\";\n    let mut out = \"\".to_string();\n    for i in (1..word.len() - 1).rev() {\n        if vowels.contains(word.chars().nth(i).unwrap()) {\n            if !vowels.contains(word.chars().nth(i + 1).unwrap()) {\n                if !vowels.contains(word.chars().nth(i - 1).unwrap()) {\n                    out.push(word.chars().nth(i).unwrap());\n                    return out;\n                }\n            }\n        }\n    }\n    out\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_get_closest_vowel() {\n        assert_eq!(get_closest_vowel(\"yogurt\"), \"u\");\n        assert_eq!(get_closest_vowel(\"full\"), \"u\");\n        assert_eq!(get_closest_vowel(\"easy\"), \"\");\n        assert_eq!(get_closest_vowel(\"eAsy\"), \"\");\n        assert_eq!(get_closest_vowel(\"ali\"), \"\");\n        assert_eq!(get_closest_vowel(\"bad\"), \"a\");\n        assert_eq!(get_closest_vowel(\"most\"), \"o\");\n        assert_eq!(get_closest_vowel(\"ab\"), \"\");\n        assert_eq!(get_closest_vowel(\"ba\"), \"\");\n        assert_eq!(get_closest_vowel(\"quick\"), \"\");\n        assert_eq!(get_closest_vowel(\"anime\"), \"i\");\n        assert_eq!(get_closest_vowel(\"Asia\"), \"\");\n        assert_eq!(get_closest_vowel(\"Above\"), \"o\");\n    }\n\n}\n", "example_test": "None", "prompt_text": "You are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.", "prompt_explain": "You are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n        assert_eq!(get_closest_vowel(\"Above\"), \"o\")", "func_title": "fn get_closest_vowel(word: &str) -> String {\n\n", "prompt_text_chinese": "给你一个词。你的任务是找到距离单词右边两个辅音之间最近的元音(区分大小写)。开头和结尾的元音不算数。如果没有找到符合上述条件的元音，则返回空字符串。您可以假设给定的字符串只包含英文字母。"}
{"task_id": "Rust/119", "prompt": "/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn match_parens(lst: Vec<&str>) -> &str {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn match_parens(lst: Vec<&str>) -> &str {\n\n", "canonical_solution": "\n    let l1 = lst[0].to_string() + lst[1];\n    let mut count = 0;\n    let mut can = true;\n    for i in 0..l1.len() {\n        if l1.chars().nth(i).unwrap() == '(' {\n            count += 1;\n        }\n        if l1.chars().nth(i).unwrap() == ')' {\n            count -= 1;\n        }\n        if count < 0 {\n            can = false;\n        }\n    }\n    if count != 0 {\n        return \"No\";\n    }\n    if can == true {\n        return \"Yes\";\n    }\n    let l1 = lst[1].to_string() + lst[0];\n    let mut can = true;\n    for i in 0..l1.len() {\n        if l1.chars().nth(i).unwrap() == '(' {\n            count += 1;\n        }\n        if l1.chars().nth(i).unwrap() == ')' {\n            count -= 1;\n        }\n        if count < 0 {\n            can = false;\n        }\n    }\n    if can == true {\n        return \"Yes\";\n    }\n    return \"No\";\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_parens() {\n        assert_eq!(match_parens(vec![\"()(\", \")\"]), \"Yes\");\n        assert_eq!(match_parens(vec![\")\", \")\"]), \"No\");\n        assert_eq!(match_parens(vec![\"(()(())\", \"())())\"],), \"No\");\n        assert_eq!(match_parens(vec![\")())\", \"(()()(\"]), \"Yes\");\n        assert_eq!(match_parens(vec![\"(())))\", \"(()())((\"]), \"Yes\");\n        assert_eq!(match_parens(vec![\"()\", \"())\"],), \"No\");\n        assert_eq!(match_parens(vec![\"(()(\", \"()))()\"]), \"Yes\");\n        assert_eq!(match_parens(vec![\"((((\", \"((())\"],), \"No\");\n        assert_eq!(match_parens(vec![\")(()\", \"(()(\"]), \"No\");\n        assert_eq!(match_parens(vec![\")(\", \")(\"]), \"No\");\n        assert_eq!(match_parens(vec![\"(\", \")\"]), \"Yes\");\n        assert_eq!(match_parens(vec![\")\", \"(\"]), \"Yes\");\n    }\n\n}\n", "example_test": "None", "prompt_text": "You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced.", "prompt_explain": "You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced.\n        assert_eq!(match_parens(vec![\")\", \"(\"]), \"Yes\")", "func_title": "fn match_parens(lst: Vec<&str>) -> &str {\n\n", "prompt_text_chinese": "给你一个包含两个字符串的列表，两个字符串都只由开括号'('或闭括号')'组成。您的工作是检查是否有可能以某种顺序连接这两个字符串，以确保得到的字符串是正确的。字符串S被认为是好的，当且仅当S中的所有括号都是平衡的。"}
{"task_id": "Rust/120", "prompt": "/*\n\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn maximum_120(arr: Vec<i32>, k: i32) -> Vec<i32> {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn maximum_120(arr: Vec<i32>, k: i32) -> Vec<i32> {\n\n", "canonical_solution": "\n    let mut arr = arr;\n    arr.sort();\n    let mut arr_res: Vec<i32> = arr.iter().rev().take(k as usize).cloned().collect();\n    arr_res.sort();\n    return arr_res;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_maximum_120() {\n        assert_eq!(maximum_120(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n        assert_eq!(maximum_120(vec![4, -4, 4], 2), vec![4, 4]);\n        assert_eq!(maximum_120(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n        assert_eq!(\n            maximum_120(vec![123, -123, 20, 0, 1, 2, -3], 3),\n            vec![2, 20, 123]\n        );\n        assert_eq!(\n            maximum_120(vec![-123, 20, 0, 1, 2, -3], 4),\n            vec![0, 1, 2, 20]\n        );\n        assert_eq!(\n            maximum_120(vec![5, 15, 0, 3, -13, -8, 0], 7),\n            vec![-13, -8, 0, 0, 3, 5, 15]\n        );\n        assert_eq!(maximum_120(vec![-1, 0, 2, 5, 3, -10], 2), vec![3, 5]);\n        assert_eq!(maximum_120(vec![1, 0, 5, -7], 1), vec![5]);\n        assert_eq!(maximum_120(vec![4, -4], 2), vec![-4, 4]);\n        assert_eq!(maximum_120(vec![-10, 10], 2), vec![-10, 10]);\n        assert_eq!(maximum_120(vec![1, 2, 3, -23, 243, -400, 0], 0), vec![]);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.", "prompt_explain": "Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n        assert_eq!(maximum_120(vec![1, 2, 3, -23, 243, -400, 0], 0), vec![])", "func_title": "fn maximum_120(arr: Vec<i32>, k: i32) -> Vec<i32> {\n\n", "prompt_text_chinese": "给定一个整数数组arr和一个正整数k，返回一个长度为k且arr中最大k个数字的排序列表。"}
{"task_id": "Rust/121", "prompt": "/*\nGiven a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn solutions(lst: Vec<i32>) -> i32 {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn solutions(lst: Vec<i32>) -> i32 {\n\n", "canonical_solution": "\n    let mut sum = 0;\n    for (indx, elem) in lst.iter().enumerate() {\n        if indx % 2 == 0 {\n            if elem % 2 == 1 {\n                sum += elem;\n            }\n        }\n    }\n    return sum;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_solutions() {\n        assert_eq!(solutions(vec![5, 8, 7, 1]), 12);\n        assert_eq!(solutions(vec![3, 3, 3, 3, 3]), 9);\n        assert_eq!(solutions(vec![30, 13, 24, 321]), 0);\n        assert_eq!(solutions(vec![5, 9]), 5);\n        assert_eq!(solutions(vec![2, 4, 8]), 0);\n        assert_eq!(solutions(vec![30, 13, 23, 32]), 23);\n        assert_eq!(solutions(vec![3, 13, 2, 9]), 3);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.", "prompt_explain": "Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n        assert_eq!(solutions(vec![3, 13, 2, 9]), 3)", "func_title": "fn solutions(lst: Vec<i32>) -> i32 {\n\n", "prompt_text_chinese": "给定一个非空的整数列表，返回位于偶数位置的所有奇数元素的和。"}
{"task_id": "Rust/122", "prompt": "/*\n\n    Given a non-empty array of integers arr and an integer k, return\n    the sum of the elements with at most two digits from the first k elements of arr.\n\n    Constraints:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn add_elements(arr: Vec<i32>, k: i32) -> i32 {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn add_elements(arr: Vec<i32>, k: i32) -> i32 {\n\n", "canonical_solution": "\n    let mut sum = 0;\n    for i in 0..k {\n        if arr[i as usize] >= -99 && arr[i as usize] <= 99 {\n            sum += arr[i as usize];\n        }\n    }\n    sum\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_add_elements() {\n        assert_eq!(add_elements(vec![1, -2, -3, 41, 57, 76, 87, 88, 99], 3), -4);\n        assert_eq!(add_elements(vec![111, 121, 3, 4000, 5, 6], 2), 0);\n        assert_eq!(add_elements(vec![11, 21, 3, 90, 5, 6, 7, 8, 9], 4), 125);\n        assert_eq!(add_elements(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4), 24);\n        assert_eq!(add_elements(vec![1], 1), 1);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Given a non-empty array of integers arr and an integer k, return\n    the sum of the elements with at most two digits from the first k elements of arr.", "prompt_explain": "Given a non-empty array of integers arr and an integer k, return\n    the sum of the elements with at most two digits from the first k elements of arr.\n        assert_eq!(add_elements(vec![1], 1), 1)", "func_title": "fn add_elements(arr: Vec<i32>, k: i32) -> i32 {\n\n", "prompt_text_chinese": "给定一个由整数arr和整数k组成的非空数组，返回arr中前k个元素中最多两位数的元素之和。"}
{"task_id": "Rust/123", "prompt": "/*\n\n    Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n    as follows: start with any positive integer n. Then each term is obtained from the \n    previous term as follows: if the previous term is even, the next term is one half of \n    the previous term. If the previous term is odd, the next term is 3 times the previous\n    term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n        2. returned list sorted in increasing order.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn get_odd_collatz(n: i32) -> Vec<i32> {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn get_odd_collatz(n: i32) -> Vec<i32> {\n\n", "canonical_solution": "\n    let mut out = vec![1];\n    let mut n = n;\n    while n != 1 {\n        if n % 2 == 1 {\n            out.push(n);\n            n = n * 3 + 1;\n        } else {\n            n = n / 2;\n        }\n    }\n    out.sort();\n    out\n}\n\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n   #[test]\n    fn test_get_odd_collatz() {\n        assert_eq!(get_odd_collatz(14), vec![1, 5, 7, 11, 13, 17]);\n        assert_eq!(get_odd_collatz(5), vec![1, 5]);\n        assert_eq!(get_odd_collatz(12), vec![1, 3, 5]);\n        assert_eq!(get_odd_collatz(1), vec![1]);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n    as follows: start with any positive integer n. Then each term is obtained from the \n    previous term as follows: if the previous term is even, the next term is one half of \n    the previous term. If the previous term is odd, the next term is 3 times the previous\n    term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n        2. returned list sorted in increasing order.", "prompt_explain": "Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n    as follows: start with any positive integer n. Then each term is obtained from the \n    previous term as follows: if the previous term is even, the next term is one half of \n    the previous term. If the previous term is odd, the next term is 3 times the previous\n    term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n        2. returned list sorted in increasing order.\n        assert_eq!(get_odd_collatz(1), vec![1])", "func_title": "fn get_odd_collatz(n: i32) -> Vec<i32> {\n\n", "prompt_text_chinese": "给定一个正整数n，返回一个以collatz顺序排列的奇数的有序列表。Collatz猜想是数学中的一个猜想，它涉及一个序列，定义如下:从任意正整数n开始，然后每一项都从上一项得到，如下所示:如果前一项是偶数，下一项是前一项的一半。如果前一项是奇数，那么下一项就是3乘以前一项加1。猜想是不管n的值是多少，序列总是会达到1。请注意 :         1。Collatz(1)是[1]。2. 返回的列表按递增顺序排序。"}
{"task_id": "Rust/124", "prompt": "/*\nYou have to write a function which validates a given date string and\n    returns True if the date is valid otherwise False.\n    The date is valid if all of the following rules are satisfied:\n    1. The date string is not empty.\n    2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n    3. The months should not be less than 1 or higher than 12.\n    4. The date should be in the format: mm-dd-yyyy\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn valid_date(date: &str) -> bool {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn valid_date(date: &str) -> bool {\n\n", "canonical_solution": "\n    let mut mm = 0;\n    let mut dd = 0;\n    let mut yy = 0;\n    let mut i = 0;\n    if date.len() != 10 {\n        return false;\n    }\n    for i in 0..10 {\n        if i == 2 || i == 5 {\n            if date.chars().nth(i).unwrap() != '-' {\n                return false;\n            }\n        } else if date.chars().nth(i).unwrap() < '0' || date.chars().nth(i).unwrap() > '9' {\n            return false;\n        }\n    }\n    mm = date[0..2].parse::<i32>().unwrap();\n    dd = date[3..5].parse::<i32>().unwrap();\n    yy = date[6..10].parse::<i32>().unwrap();\n    if mm < 1 || mm > 12 {\n        return false;\n    }\n    if dd < 1 || dd > 31 {\n        return false;\n    }\n    if dd == 31 && (mm == 4 || mm == 6 || mm == 9 || mm == 11 || mm == 2) {\n        return false;\n    }\n    if dd == 30 && mm == 2 {\n        return false;\n    }\n    return true;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_valid_date() {\n        assert_eq!(valid_date(\"03-11-2000\"), true);\n        assert_eq!(valid_date(\"15-01-2012\"), false);\n        assert_eq!(valid_date(\"04-0-2040\"), false);\n        assert_eq!(valid_date(\"06-04-2020\"), true);\n        assert_eq!(valid_date(\"01-01-2007\"), true);\n        assert_eq!(valid_date(\"03-32-2011\"), false);\n        assert_eq!(valid_date(\"\"), false);\n        assert_eq!(valid_date(\"04-31-3000\"), false);\n        assert_eq!(valid_date(\"06-06-2005\"), true);\n        assert_eq!(valid_date(\"21-31-2000\"), false);\n        assert_eq!(valid_date(\"04-12-2003\"), true);\n        assert_eq!(valid_date(\"04122003\"), false);\n        assert_eq!(valid_date(\"20030412\"), false);\n        assert_eq!(valid_date(\"2003-04\"), false);\n        assert_eq!(valid_date(\"2003-04-12\"), false);\n        assert_eq!(valid_date(\"04-2003\"), false);\n    }\n\n}\n", "example_test": "None", "prompt_text": "You have to write a function which validates a given date string and\n    returns True if the date is valid otherwise False.\n    The date is valid if all of the following rules are satisfied:\n    1. The date string is not empty.\n    2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n    3. The months should not be less than 1 or higher than 12.\n    4. The date should be in the format: mm-dd-yyyy", "prompt_explain": "You have to write a function which validates a given date string and\n    returns True if the date is valid otherwise False.\n    The date is valid if all of the following rules are satisfied:\n    1. The date string is not empty.\n    2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n    3. The months should not be less than 1 or higher than 12.\n    4. The date should be in the format: mm-dd-yyyy\n        assert_eq!(valid_date(\"04-2003\"), false)", "func_title": "fn valid_date(date: &str) -> bool {\n\n", "prompt_text_chinese": "您必须编写一个函数来验证给定的日期字符串，如果日期有效则返回True，否则返回False。当满足以下所有条件时，该日期有效。日期字符串不是空的。2. 第1、3、5、7、8、10、12月的天数不少于1天或大于31天。第4、6、9、11个月的天数不少于1天或大于30天。并且，第2个月的天数不小于1或大于29。3.月份不应小于1或大于12。4. 日期的格式为:mm-dd-yyyy"}
{"task_id": "Rust/125", "prompt": "/*\n\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn split_words(txt: &str) -> Vec<String> {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn split_words(txt: &str) -> Vec<String> {\n\n", "canonical_solution": "\n    let mut out: Vec<String> = Vec::new();\n    let alphabet: HashMap<char, i32> = HashMap::from([\n        ('a', 0),\n        ('b', 1),\n        ('c', 2),\n        ('d', 3),\n        ('e', 4),\n        ('f', 5),\n        ('g', 6),\n        ('h', 7),\n        ('i', 8),\n        ('j', 9),\n        ('k', 10),\n        ('l', 11),\n        ('m', 12),\n        ('n', 13),\n        ('o', 14),\n        ('p', 15),\n        ('q', 16),\n        ('r', 17),\n        ('s', 18),\n        ('t', 19),\n        ('u', 20),\n        ('v', 21),\n        ('w', 22),\n        ('x', 23),\n        ('y', 24),\n        ('z', 25),\n    ]);\n\n    if txt.contains(' ') {\n        out = txt\n            .split_whitespace()\n            .into_iter()\n            .map(|c| c.to_string())\n            .collect();\n    } else if txt.contains(',') {\n        out = txt.split(',').into_iter().map(|c| c.to_string()).collect();\n    } else {\n        let count = txt\n            .chars()\n            .into_iter()\n            .filter(|c| c.is_ascii_lowercase())\n            .filter(|c| alphabet.get(c).unwrap() % 2 == 1)\n            .count();\n        out.push(count.to_string());\n    }\n\n    return out;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_split_words() {\n        assert_eq!(split_words(\"Hello world!\"), vec![\"Hello\", \"world!\"]);\n        assert_eq!(split_words(\"Hello,world!\"), vec![\"Hello\", \"world!\"]);\n        assert_eq!(split_words(\"Hello world,!\"), vec![\"Hello\", \"world,!\"]);\n        assert_eq!(\n            split_words(\"Hello,Hello,world !\"),\n            vec![\"Hello,Hello,world\", \"!\"]\n        );\n        assert_eq!(split_words(\"abcdef\"), vec![\"3\"]);\n        assert_eq!(split_words(\"aaabb\"), vec![\"2\"]);\n        assert_eq!(split_words(\"aaaBb\"), vec![\"1\"]);\n        assert_eq!(split_words(\"\"), vec![\"0\"]);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25", "prompt_explain": "Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n        assert_eq!(split_words(\"\"), vec![\"0\"])", "func_title": "fn split_words(txt: &str) -> Vec<String> {\n\n", "prompt_text_chinese": "给定一串单词，返回一个以空格分隔的单词列表，如果文本中不存在空格，则应以逗号'分隔，'如果不存在逗号，则应返回字母表中奇数顺序的小写字母的数量，ord('a') = 0, ord('b') = 1，…Ord ('z') = 25"}
{"task_id": "Rust/126", "prompt": "/*\n\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn is_sorted(lst: Vec<i32>) -> bool {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn is_sorted(lst: Vec<i32>) -> bool {\n\n", "canonical_solution": "\n    for i in 1..lst.len() {\n        if lst[i] < lst[i - 1] {\n            return false;\n        }\n        if i >= 2 && lst[i] == lst[i - 1] && lst[i] == lst[i - 2] {\n            return false;\n        }\n    }\n    true\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_is_sorted() {\n        assert_eq!(is_sorted(vec![5]), true);\n        assert_eq!(is_sorted(vec![1, 2, 3, 4, 5]), true);\n        assert_eq!(is_sorted(vec![1, 3, 2, 4, 5]), false);\n        assert_eq!(is_sorted(vec![1, 2, 3, 4, 5, 6]), true);\n        assert_eq!(is_sorted(vec![1, 2, 3, 4, 5, 6, 7]), true);\n        assert_eq!(is_sorted(vec![1, 3, 2, 4, 5, 6, 7]), false);\n        assert_eq!(is_sorted(vec![]), true);\n        assert_eq!(is_sorted(vec![1]), true);\n        assert_eq!(is_sorted(vec![3, 2, 1]), false);\n        assert_eq!(is_sorted(vec![1, 2, 2, 2, 3, 4]), false);\n        assert_eq!(is_sorted(vec![1, 2, 3, 3, 3, 4]), false);\n        assert_eq!(is_sorted(vec![1, 2, 2, 3, 3, 4]), true);\n        assert_eq!(is_sorted(vec![1, 2, 3, 4]), true);\n    }\n\n\n}\n", "example_test": "None", "prompt_text": "Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.", "prompt_explain": "Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n        assert_eq!(is_sorted(vec![1, 2, 3, 4]), true)", "func_title": "fn is_sorted(lst: Vec<i32>) -> bool {\n\n", "prompt_text_chinese": "给定一个数字列表，返回它们是否按升序排序。如果列表中有多个相同数字的副本，则返回False。假设没有负数，只有整数。"}
{"task_id": "Rust/127", "prompt": "/*\nYou are given two intervals,\n    where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n    The given intervals are closed which means that the interval (start, end)\n    includes both start and end.\n    For each given interval, it is assumed that its start is less or equal its end.\n    Your task is to determine whether the length of intersection of these two \n    intervals is a prime number.\n    Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n    which its length is 1, which not a prime number.\n    If the length of the intersection is a prime number, return \"YES\",\n    otherwise, return \"NO\".\n    If the two intervals don't intersect, return \"NO\".\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn intersection(interval1: Vec<i32>, interval2: Vec<i32>) -> String {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn intersection(interval1: Vec<i32>, interval2: Vec<i32>) -> String {\n\n", "canonical_solution": "\n    let inter1 = std::cmp::max(interval1[0], interval2[0]);\n    let inter2 = std::cmp::min(interval1[1], interval2[1]);\n    let l = inter2 - inter1;\n    if l < 2 {\n        return \"NO\".to_string();\n    }\n    for i in 2..l {\n        if l % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n    return \"YES\".to_string();\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_intersection() {\n        assert_eq!(intersection(vec![1, 2], vec![2, 3]), \"NO\");\n        assert_eq!(intersection(vec![-1, 1], vec![0, 4]), \"NO\");\n        assert_eq!(intersection(vec![-3, -1], vec![-5, 5]), \"YES\");\n        assert_eq!(intersection(vec![-2, 2], vec![-4, 0]), \"YES\");\n        assert_eq!(intersection(vec![-11, 2], vec![-1, -1]), \"NO\");\n        assert_eq!(intersection(vec![1, 2], vec![3, 5]), \"NO\");\n        assert_eq!(intersection(vec![1, 2], vec![1, 2]), \"NO\");\n        assert_eq!(intersection(vec![-2, -2], vec![-3, -2]), \"NO\");\n    }\n\n}\n", "example_test": "None", "prompt_text": "You are given two intervals,\n    where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n    The given intervals are closed which means that the interval (start, end)\n    includes both start and end.\n    For each given interval, it is assumed that its start is less or equal its end.\n    Your task is to determine whether the length of intersection of these two \n    intervals is a prime number.", "prompt_explain": "You are given two intervals,\n    where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n    The given intervals are closed which means that the interval (start, end)\n    includes both start and end.\n    For each given interval, it is assumed that its start is less or equal its end.\n    Your task is to determine whether the length of intersection of these two \n    intervals is a prime number.\n        assert_eq!(intersection(vec![-2, -2], vec![-3, -2]), \"NO\")", "func_title": "fn intersection(interval1: Vec<i32>, interval2: Vec<i32>) -> String {\n\n", "prompt_text_chinese": "给定两个区间，每个区间是一对整数。例如，interval = (start, end) =(1,2)。给定的间隔是封闭的，这意味着间隔(start, end)包括start和end。对于每个给定的区间，假设它的起始点小于或等于它的结束点。你的任务是确定这两个区间的交点长度是否为质数。"}
{"task_id": "Rust/128", "prompt": "/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn prod_signs(arr: Vec<i32>) -> i32 {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn prod_signs(arr: Vec<i32>) -> i32 {\n\n", "canonical_solution": "\n    if arr.is_empty() {\n        return -32768;\n    }\n    let mut sum = 0;\n    let mut prods = 1;\n    for i in arr {\n        sum += i.abs();\n        if i == 0 {\n            prods = 0;\n        }\n        if i < 0 {\n            prods = -prods;\n        }\n    }\n    sum * prods\n}\n\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_prod_signs() {\n        assert_eq!(prod_signs(vec![1, 2, 2, -4]), -9);\n        assert_eq!(prod_signs(vec![0, 1]), 0);\n        assert_eq!(prod_signs(vec![1, 1, 1, 2, 3, -1, 1]), -10);\n        assert_eq!(prod_signs(vec![]), -32768);\n        assert_eq!(prod_signs(vec![2, 4, 1, 2, -1, -1, 9]), 20);\n        assert_eq!(prod_signs(vec![-1, 1, -1, 1]), 4);\n        assert_eq!(prod_signs(vec![-1, 1, 1, 1]), -4);\n        assert_eq!(prod_signs(vec![-1, 1, 1, 0]), 0);\n    }\n\n}\n", "example_test": "None", "prompt_text": "You are given an array arr of integers and you need to return sum of magnitudes of integers multiplied by product of all signs of each number in the array, represented by 1, -1 or 0. Note: return None for empty arr.  Example:", "prompt_explain": "You are given an array arr of integers and you need to return sum of magnitudes of integers multiplied by product of all signs of each number in the array, represented by 1, -1 or 0. Note: return None for empty arr.  Example:\n        assert_eq!(prod_signs(vec![-1, 1, 1, 0]), 0)", "func_title": "fn prod_signs(arr: Vec<i32>) -> i32 {\n\n", "prompt_text_chinese": "给你一个整数数组arr，你需要返回整数大小的和乘以数组中每个数字的所有符号的乘积，用1、-1或0表示。备注:空arr返回None。"}
{"task_id": "Rust/129", "prompt": "/*\n\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn min_path(grid: Vec<Vec<i32>>, k: i32) -> Vec<i32> {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn min_path(grid: Vec<Vec<i32>>, k: i32) -> Vec<i32> {\n\n", "canonical_solution": "\n    let mut out: Vec<i32> = vec![];\n    let mut x = 0;\n    let mut y = 0;\n    let mut min: i32 = (grid.len() * grid.len()) as i32;\n    for i in 0..grid.len() {\n        for j in 0..grid[i].len() {\n            if grid[i][j] == 1 {\n                x = i;\n                y = j;\n            }\n        }\n    }\n    if x > 0 && grid[x - 1][y] < min {\n        min = grid[x - 1][y];\n    }\n    if x < grid.len() - 1 && grid[x + 1][y] < min {\n        min = grid[x + 1][y];\n    }\n    if y > 0 && grid[x][y - 1] < min {\n        min = grid[x][y - 1];\n    }\n    if y < grid.len() - 1 && grid[x][y + 1] < min {\n        min = grid[x][y + 1];\n    }\n    let mut out = vec![];\n    for i in 0..k {\n        if i % 2 == 0 {\n            out.push(1);\n        } else {\n            out.push(min);\n        }\n    }\n    out\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_min_path() {\n        assert_eq!(\n            min_path(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3),\n            vec![1, 2, 1]\n        );\n        assert_eq!(\n            min_path(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1),\n            vec![1]\n        );\n        assert_eq!(\n            min_path(\n                vec![\n                    vec![1, 2, 3, 4],\n                    vec![5, 6, 7, 8],\n                    vec![9, 10, 11, 12],\n                    vec![13, 14, 15, 16]\n                ],\n                4\n            ),\n            vec![1, 2, 1, 2]\n        );\n        assert_eq!(\n            min_path(\n                vec![\n                    vec![6, 4, 13, 10],\n                    vec![5, 7, 12, 1],\n                    vec![3, 16, 11, 15],\n                    vec![8, 14, 9, 2]\n                ],\n                7\n            ),\n            vec![1, 10, 1, 10, 1, 10, 1]\n        );\n        assert_eq!(\n            min_path(\n                vec![\n                    vec![8, 14, 9, 2],\n                    vec![6, 4, 13, 15],\n                    vec![5, 7, 1, 12],\n                    vec![3, 10, 11, 16]\n                ],\n                5\n            ),\n            vec![1, 7, 1, 7, 1]\n        );\n        assert_eq!(\n            min_path(\n                vec![\n                    vec![11, 8, 7, 2],\n                    vec![5, 16, 14, 4],\n                    vec![9, 3, 15, 6],\n                    vec![12, 13, 10, 1]\n                ],\n                9\n            ),\n            vec![1, 6, 1, 6, 1, 6, 1, 6, 1]\n        );\n        assert_eq!(\n            min_path(\n                vec![\n                    vec![12, 13, 10, 1],\n                    vec![9, 3, 15, 6],\n                    vec![5, 16, 14, 4],\n                    vec![11, 8, 7, 2]\n                ],\n                12\n            ),\n            vec![1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n        );\n        assert_eq!(\n            min_path(vec![vec![2, 7, 4], vec![3, 1, 5], vec![6, 8, 9]], 8),\n            vec![1, 3, 1, 3, 1, 3, 1, 3]\n        );\n\n        assert_eq!(\n            min_path(vec![vec![6, 1, 5], vec![3, 8, 9], vec![2, 7, 4]], 8),\n            vec![1, 5, 1, 5, 1, 5, 1, 5]\n        );\n\n        assert_eq!(\n            min_path(vec![vec![1, 2], vec![3, 4]], 10),\n            vec![1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n        );\n\n        assert_eq!(\n            min_path(vec![vec![1, 3], vec![3, 2]], 10),\n            vec![1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n        );\n    }\n\n}\n", "example_test": "None", "prompt_text": "Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.", "prompt_explain": "Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n        assert_eq!(\n            min_path(vec![vec![1, 3], vec![3, 2]], 10),\n            vec![1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n        )", "func_title": "fn min_path(grid: Vec<Vec<i32>>, k: i32) -> Vec<i32> {\n\n", "prompt_text_chinese": "给定一个有N行N列(N >= 2)和正整数k的网格，网格的每个单元格都包含一个值。包括[1,N * N]在内的范围内的每个整数在网格的单元格中恰好出现一次。你必须找到网格中长度为k的最小路径。你可以从任何单元格开始，每一步你都可以移动到任何相邻的单元格，换句话说，你可以移动到与当前单元格共享一条边的单元格。请注意，长度为k的路径意味着访问k个单元格(不一定是不同的)。你不能离开电网。路径长度(k)被认为是不到一个路径B (k)长度值的有序列表后如果A和B细胞经历(我们称之为lst_A lst_B) lst_A按小于lst_B,换句话说,存在一个整数指数(1 < =我< = k)这样lst_A[我]< lst_B[我]和任何j(1 < = <我)我们有lst_A [j] = lst_B [j]。它保证答案是唯一的。返回最小路径所经过的单元格上的值的有序列表。"}
{"task_id": "Rust/130", "prompt": "/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn tri(n: i32) -> Vec<i32> {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn tri(n: i32) -> Vec<i32> {\n\n", "canonical_solution": "\n    let mut out = vec![1, 3];\n    if n == 0 {\n        return vec![1];\n    }\n    for i in 2..=n {\n        if i % 2 == 0 {\n            out.push(1 + i / 2);\n        } else {\n            out.push(out[(i - 1) as usize] + out[(i - 2) as usize] + 1 + (i + 1) / 2);\n        }\n    }\n    out\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_tri() {\n        assert!(tri(3) == vec![1, 3, 2, 8]);\n        assert!(tri(4) == vec![1, 3, 2, 8, 3]);\n        assert!(tri(5) == vec![1, 3, 2, 8, 3, 15]);\n        assert!(tri(6) == vec![1, 3, 2, 8, 3, 15, 4]);\n        assert!(tri(7) == vec![1, 3, 2, 8, 3, 15, 4, 24]);\n        assert!(tri(8) == vec![1, 3, 2, 8, 3, 15, 4, 24, 5]);\n        assert!(tri(9) == vec![1, 3, 2, 8, 3, 15, 4, 24, 5, 35]);\n        assert!(\n            tri(20)\n                == vec![1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11]\n        );\n        assert!(tri(0) == vec![1]);\n        assert!(tri(1) == vec![1, 3]);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.", "prompt_explain": "Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n        assert!(tri(1) == vec![1, 3])", "func_title": "fn tri(n: i32) -> Vec<i32> {\n\n", "prompt_text_chinese": "每个人都知道斐波那契数列，在过去的几个世纪里，数学家对它进行了深入的研究。然而，人们不知道的是Tribonacci数列。Tribonacci数列由以下递归式定义:当n为偶数时，tri(1) = 3 tri(n) = 1 + n / 2。如果n是奇数，Tri (n) = Tri (n - 1) + Tri (n - 2) + Tri (n + 1)。"}
{"task_id": "Rust/131", "prompt": "/*\nGiven a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn digits(n: i32) -> i32 {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn digits(n: i32) -> i32 {\n\n", "canonical_solution": "\n    let mut prod: i32 = 1;\n    let mut has = 0;\n    let s = n.to_string();\n    for i in 0..s.len() {\n        if s.chars().nth(i).unwrap().to_digit(10).unwrap() % 2 == 1 {\n            has = 1;\n            prod = prod * (s.chars().nth(i).unwrap().to_digit(10).unwrap()) as i32;\n        }\n    }\n    if has == 0 {\n        return 0;\n    }\n    prod\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_digits() {\n        assert_eq!(digits(5), 5);\n        assert_eq!(digits(54), 5);\n        assert_eq!(digits(120), 1);\n        assert_eq!(digits(5014), 5);\n        assert_eq!(digits(98765), 315);\n        assert_eq!(digits(5576543), 2625);\n        assert_eq!(digits(2468), 0);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.", "prompt_explain": "Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n        assert_eq!(digits(2468), 0)", "func_title": "fn digits(n: i32) -> i32 {\n\n", "prompt_text_chinese": "给定一个正整数n，返回奇数的乘积。如果所有数字都是偶数，则返回0。"}
{"task_id": "Rust/132", "prompt": "/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn is_nested(str: &str) -> bool {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn is_nested(str: &str) -> bool {\n\n", "canonical_solution": "\n    let mut count = 0;\n    let mut maxcount = 0;\n    for i in 0..str.len() {\n        if str.chars().nth(i).unwrap() == '[' {\n            count += 1;\n        }\n        if str.chars().nth(i).unwrap() == ']' {\n            count -= 1;\n        }\n        if count < 0 {\n            count = 0;\n        }\n        if count > maxcount {\n            maxcount = count;\n        }\n        if count <= maxcount - 2 {\n            return true;\n        }\n    }\n    return false;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_is_nested() {\n        assert_eq!(is_nested(\"[[]]\"), true);\n        assert_eq!(is_nested(\"[]]]]]]][[[[[]\"), false);\n        assert_eq!(is_nested(\"[][]\"), false);\n        assert_eq!(is_nested(\"[]\"), false);\n        assert_eq!(is_nested(\"[[[[]]]]\"), true);\n        assert_eq!(is_nested(\"[]]]]]]]]]]\"), false);\n        assert_eq!(is_nested(\"[][][[]]\"), true);\n        assert_eq!(is_nested(\"[[]\"), false);\n        assert_eq!(is_nested(\"[]]\"), false);\n        assert_eq!(is_nested(\"[[]][[\"), true);\n        assert_eq!(is_nested(\"[[][]]\"), true);\n        assert_eq!(is_nested(\"\"), false);\n        assert_eq!(is_nested(\"[[[[[[[[\"), false);\n        assert_eq!(is_nested(\"]]]]]]]]\"), false);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.", "prompt_explain": "Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n        assert_eq!(is_nested(\"]]]]]]]]\"), false)", "func_title": "fn is_nested(str: &str) -> bool {\n\n", "prompt_text_chinese": "创建一个函数，该函数接受一个字符串作为输入，该字符串只包含方括号。当且仅当存在括号的有效子序列，且该子序列中至少有一个括号嵌套时，函数应返回True。"}
{"task_id": "Rust/133", "prompt": "/*\n\"\n    This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n    multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n    change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn sum_squares(lst: Vec<f32>) -> i32 {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn sum_squares(lst: Vec<f32>) -> i32 {\n\n", "canonical_solution": "\n    let mut sum: f32 = 0.0;\n    for i in 0..lst.len() {\n        sum = sum + (lst[i].ceil() * lst[i].ceil());\n    }\n    sum as i32\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_sum_squares() {\n        assert_eq!(sum_squares(vec![1.0, 2.0, 3.0]), 14);\n        assert_eq!(sum_squares(vec![1.0, 2.0, 3.0]), 14);\n        assert_eq!(sum_squares(vec![1.0, 3.0, 5.0, 7.0]), 84);\n        assert_eq!(sum_squares(vec![1.4, 4.2, 0.0]), 29);\n        assert_eq!(sum_squares(vec![-2.4, 1.0, 1.0]), 6);\n        assert_eq!(sum_squares(vec![100.0, 1.0, 15.0, 2.0]), 10230);\n        assert_eq!(sum_squares(vec![10000.0, 10000.0]), 200000000);\n        assert_eq!(sum_squares(vec![-1.4, 4.6, 6.3]), 75);\n        assert_eq!(sum_squares(vec![-1.4, 17.9, 18.9, 19.9]), 1086);\n        assert_eq!(sum_squares(vec![0.0]), 0);\n        assert_eq!(sum_squares(vec![-1.0]), 1);\n        assert_eq!(sum_squares(vec![-1.0, 1.0, 0.0]), 2);\n    }\n\n}\n", "example_test": "None", "prompt_text": "You are given a list of numbers.\n    You need to return the sum of squared numbers in the given list,\n    round each element in the list to the upper int(Ceiling) first.", "prompt_explain": "You are given a list of numbers.\n    You need to return the sum of squared numbers in the given list,\n    round each element in the list to the upper int(Ceiling) first.\n        assert_eq!(sum_squares(vec![-1.0, 1.0, 0.0]), 2)", "func_title": "fn sum_squares(lst: Vec<f32>) -> i32 {\n\n", "prompt_text_chinese": "给你一个数字列表。您需要返回给定列表中数字的平方和，首先将列表中的每个元素四舍五入为上整数(Ceiling)。"}
{"task_id": "Rust/134", "prompt": "/*\n\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn check_if_last_char_is_a_letter(txt: &str) -> bool {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn check_if_last_char_is_a_letter(txt: &str) -> bool {\n\n", "canonical_solution": "\n    if txt.len() == 0 {\n        return false;\n    }\n    let chr = txt.chars().last().unwrap();\n    if chr < 'A' || (chr > 'Z' && chr < 'a') || chr > 'z' {\n        return false;\n    }\n    if txt.len() == 1 {\n        return true;\n    }\n    let chr = txt.chars().nth(txt.len() - 2).unwrap();\n    if (chr >= 'A' && chr <= 'Z') || (chr >= 'a' && chr <= 'z') {\n        return false;\n    }\n    true\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_check_if_last_char_is_a_letter() {\n        assert_eq!(check_if_last_char_is_a_letter(\"apple\"), false);\n        assert_eq!(check_if_last_char_is_a_letter(\"apple pi e\"), true);\n        assert_eq!(check_if_last_char_is_a_letter(\"eeeee\"), false);\n        assert_eq!(check_if_last_char_is_a_letter(\"A\"), true);\n        assert_eq!(check_if_last_char_is_a_letter(\"Pumpkin pie \"), false);\n        assert_eq!(check_if_last_char_is_a_letter(\"Pumpkin pie 1\"), false);\n        assert_eq!(check_if_last_char_is_a_letter(\"\"), false);\n        assert_eq!(check_if_last_char_is_a_letter(\"eeeee e \"), false);\n        assert_eq!(check_if_last_char_is_a_letter(\"apple pie\"), false);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.", "prompt_explain": "Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n        assert_eq!(check_if_last_char_is_a_letter(\"apple pie\"), false)", "func_title": "fn check_if_last_char_is_a_letter(txt: &str) -> bool {\n\n", "prompt_text_chinese": "创建一个函数，如果给定字符串的最后一个字符是字母字符并且不是单词的一部分，则返回True，否则返回False。注意:\"word\"是由空格分隔的一组字符。"}
{"task_id": "Rust/135", "prompt": "/*\nCreate a function which returns the largest index of an element which\n    is not greater than or equal to the element immediately preceding it. If\n    no such element exists then return -1. The given array will not contain\n    duplicate values.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn can_arrange(arr: Vec<i32>) -> i32 {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn can_arrange(arr: Vec<i32>) -> i32 {\n\n", "canonical_solution": "\n    let mut max: i32 = -1;\n    for i in 0..arr.len() {\n        if arr[i] <= i as i32 {\n            max = i as i32;\n        }\n    }\n    max\n}\n\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n\n    #[test]\n    fn test_can_arrange() {\n        assert_eq!(can_arrange(vec![1, 2, 4, 3, 5]), 3);\n        assert_eq!(can_arrange(vec![1, 2, 4, 5]), -1);\n        assert_eq!(can_arrange(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n        assert_eq!(can_arrange(vec![4, 8, 5, 7, 3]), 4);\n        assert_eq!(can_arrange(vec![]), -1);\n    }\n\n\n}\n", "example_test": "None", "prompt_text": "You are given an array arr of integers and you need to return sum of magnitudes of integers multiplied by product of all signs of each number in the array, represented by 1, -1 or 0. Note: return None for empty arr.  Example:", "prompt_explain": "You are given an array arr of integers and you need to return sum of magnitudes of integers multiplied by product of all signs of each number in the array, represented by 1, -1 or 0. Note: return None for empty arr.  Example:\n        assert_eq!(can_arrange(vec![]), -1)", "func_title": "fn can_arrange(arr: Vec<i32>) -> i32 {\n\n", "prompt_text_chinese": "创建一个函数，返回不大于或等于紧挨着它前面的元素的最大下标。如果不存在这样的元素，则返回-1。给定的数组将不包含重复的值。"}
{"task_id": "Rust/136", "prompt": "/*\n\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn largest_smallest_integers(lst: Vec<i32>) -> Vec<i32> {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn largest_smallest_integers(lst: Vec<i32>) -> Vec<i32> {\n\n", "canonical_solution": "\n    let mut maxneg = 0;\n    let mut minpos = 0;\n    for i in 0..lst.len() {\n        if lst[i] < 0 && (maxneg == 0 || lst[i] > maxneg) {\n            maxneg = lst[i];\n        }\n        if lst[i] > 0 && (minpos == 0 || lst[i] < minpos) {\n            minpos = lst[i];\n        }\n    }\n    vec![maxneg, minpos]\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_largest_smallest_integers() {\n        assert_eq!(\n            largest_smallest_integers(vec![2, 4, 1, 3, 5, 7]),\n            vec![0, 1]\n        );\n        assert_eq!(\n            largest_smallest_integers(vec![2, 4, 1, 3, 5, 7, 0]),\n            vec![0, 1]\n        );\n        assert_eq!(\n            largest_smallest_integers(vec![1, 3, 2, 4, 5, 6, -2]),\n            vec![-2, 1]\n        );\n        assert_eq!(\n            largest_smallest_integers(vec![4, 5, 3, 6, 2, 7, -7]),\n            vec![-7, 2]\n        );\n        assert_eq!(\n            largest_smallest_integers(vec![7, 3, 8, 4, 9, 2, 5, -9]),\n            vec![-9, 2]\n        );\n        assert_eq!(largest_smallest_integers(vec![]), vec![0, 0]);\n        assert_eq!(largest_smallest_integers(vec![0]), vec![0, 0]);\n        assert_eq!(largest_smallest_integers(vec![-1, -3, -5, -6]), vec![-1, 0]);\n        assert_eq!(\n            largest_smallest_integers(vec![-1, -3, -5, -6, 0]),\n            vec![-1, 0]\n        );\n        assert_eq!(\n            largest_smallest_integers(vec![-6, -4, -4, -3, 1]),\n            vec![-3, 1]\n        );\n        assert_eq!(\n            largest_smallest_integers(vec![-6, -4, -4, -3, -100, 1]),\n            vec![-3, 1]\n        );\n    }\n\n}\n", "example_test": "None", "prompt_text": "Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.", "prompt_explain": "Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n        assert_eq!(\n            largest_smallest_integers(vec![-6, -4, -4, -3, -100, 1]),\n            vec![-3, 1]\n        )", "func_title": "fn largest_smallest_integers(lst: Vec<i32>) -> Vec<i32> {\n\n", "prompt_text_chinese": "创建一个函数，返回一个元组(a, b)，其中'a'是列表中最大的负整数，'b'是列表中最小的正整数。如果没有负整数或正整数，则将它们返回为None。"}
{"task_id": "Rust/137", "prompt": "/*\n\n    Create a function that takes integers, floats, or strings representing\n    real numbers, and returns the larger variable in its given variable type.\n    Return None if the values are equal.\n    Note: If a real number is represented as a string, the floating point might be . or ,\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn compare_one<'a>(a:&'a dyn Any, b:&'a dyn Any) -> RtnType<String,f64,i32>{\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn compare_one<'a>(a:&'a dyn Any, b:&'a dyn Any) -> RtnType<String,f64,i32>{\n\n", "canonical_solution": "\n    let a_f64 = Any_to_f64(a);\n    let b_f64 = Any_to_f64(b);\n\n    if a_f64 > b_f64 {\n        return original_type(a);\n    }\n\n    if a_f64 < b_f64 {\n        return original_type(b);\n    } else {\n        return RtnType::String(\"None\".to_string());\n    }\n}\n\n#[derive(Debug, PartialEq)]\npub enum RtnType<S, F, I> {\n    Empty(),\n    String(S),\n    Float(F),\n    Int(I),\n}\n\nfn Any_to_f64(a: &dyn Any) -> f64 {\n    let mut a_f64 = 0.0;\n\n    if a.downcast_ref::<f64>() == None {\n        match a.downcast_ref::<&str>() {\n            Some(as_string) => {\n                a_f64 = as_string.parse::<f64>().unwrap();\n            }\n            None => {}\n        }\n\n        match a.downcast_ref::<i32>() {\n            Some(as_i32) => {\n                a_f64 = *as_i32 as f64;\n            }\n            None => {}\n        }\n    } else {\n        a_f64 = *a.downcast_ref::<f64>().unwrap();\n    }\n\n    return a_f64;\n}\n\nfn original_type(a: &dyn Any) -> RtnType<String, f64, i32> {\n    let mut res = RtnType::Empty();\n    match a.downcast_ref::<&str>() {\n        Some(as_string) => {\n            res = RtnType::String(as_string.parse::<String>().unwrap());\n        }\n        None => {}\n    }\n\n    match a.downcast_ref::<i32>() {\n        Some(as_i32) => {\n            res = RtnType::Int(*as_i32);\n        }\n        None => {}\n    }\n\n    match a.downcast_ref::<f64>() {\n        Some(as_f64) => res = RtnType::Float(*as_f64),\n        None => {}\n    }\n    return res;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_compare_one() {\n        assert_eq!(compare_one(&1, &2), RtnType::Int(2));\n        assert_eq!(compare_one(&1, &2.5), RtnType::Float(2.5));\n        assert_eq!(compare_one(&2, &3), RtnType::Int(3));\n        assert_eq!(compare_one(&5, &6), RtnType::Int(6));\n        assert_eq!(compare_one(&1, &\"2.3\"), RtnType::String(\"2.3\".to_string()));\n        assert_eq!(compare_one(&\"5.1\", &\"6\"), RtnType::String(\"6\".to_string()));\n        assert_eq!(compare_one(&\"1\", &\"2\"), RtnType::String(\"2\".to_string()));\n        assert_eq!(compare_one(&\"1\", &1), RtnType::String(\"None\".to_string()));\n    }\n\n}\n", "example_test": "None", "prompt_text": "Create a function that takes integers, floats, or strings representing\n    real numbers, and returns the larger variable in its given variable type.\n    Return None if the values are equal.", "prompt_explain": "Create a function that takes integers, floats, or strings representing\n    real numbers, and returns the larger variable in its given variable type.\n    Return None if the values are equal.\n        assert_eq!(compare_one(&\"1\", &1), RtnType::String(\"None\".to_string()))", "func_title": "fn compare_one<'a>(a:&'a dyn Any, b:&'a dyn Any) -> RtnType<String,f64,i32>{\n\n", "prompt_text_chinese": "创建一个函数，接受整数、浮点数或表示实数的字符串，并返回给定变量类型的较大变量。如果值相等则返回None。"}
{"task_id": "Rust/138", "prompt": "/*\nEvaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn is_equal_to_sum_even(n: i32) -> bool {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn is_equal_to_sum_even(n: i32) -> bool {\n\n", "canonical_solution": "\n    if n % 2 == 0 && n >= 8 {\n        return true;\n    }\n    return false;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_is_equal_to_sum_even() {\n        assert_eq!(is_equal_to_sum_even(4), false);\n        assert_eq!(is_equal_to_sum_even(6), false);\n        assert_eq!(is_equal_to_sum_even(8), true);\n        assert_eq!(is_equal_to_sum_even(10), true);\n        assert_eq!(is_equal_to_sum_even(11), false);\n        assert_eq!(is_equal_to_sum_even(12), true);\n        assert_eq!(is_equal_to_sum_even(13), false);\n        assert_eq!(is_equal_to_sum_even(16), true);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers", "prompt_explain": "Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n        assert_eq!(is_equal_to_sum_even(16), true)", "func_title": "fn is_equal_to_sum_even(n: i32) -> bool {\n\n", "prompt_text_chinese": "计算给定的数n是否可以写成恰好4个正偶数的和"}
{"task_id": "Rust/139", "prompt": "/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn special_factorial(n: i32) -> i64 {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn special_factorial(n: i32) -> i64 {\n\n", "canonical_solution": "\n    let mut fact = 1;\n    let mut bfact: i64 = 1;\n    for i in 1..=n {\n        fact = fact * i;\n        bfact = bfact * fact as i64;\n    }\n    bfact\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_special_factorial() {\n        assert_eq!(special_factorial(4), 288);\n        assert_eq!(special_factorial(5), 34560);\n        assert_eq!(special_factorial(7), 125411328000);\n        assert_eq!(special_factorial(1), 1);\n    }\n\n}\n", "example_test": "None", "prompt_text": "The Brazilian factorial is defined as: brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! where n > 0  For example:", "prompt_explain": "The Brazilian factorial is defined as: brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! where n > 0  For example:\n        assert_eq!(special_factorial(1), 1)", "func_title": "fn special_factorial(n: i32) -> i64 {\n\n", "prompt_text_chinese": "巴西阶乘定义为:brazilian_factorial(n) = n!* (n - 1) !* (n - 2) !*……* 1 ! 其中n > 0"}
{"task_id": "Rust/140", "prompt": "/*\n\n    Given a string text, replace all spaces in it with underscores, \n    and if a string has more than 2 consecutive spaces, \n    then replace all consecutive spaces with - \n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn fix_spaces(text: &str) -> String {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn fix_spaces(text: &str) -> String {\n\n", "canonical_solution": "\n    let mut out = String::new();\n    let mut spacelen = 0;\n    for c in text.chars() {\n        if c == ' ' {\n            spacelen += 1;\n        } else {\n            if spacelen == 1 {\n                out.push('_');\n            }\n            if spacelen == 2 {\n                out.push_str(\"__\");\n            }\n            if spacelen > 2 {\n                out.push('-');\n            }\n            spacelen = 0;\n            out.push(c);\n        }\n    }\n    if spacelen == 1 {\n        out.push('_');\n    }\n    if spacelen == 2 {\n        out.push_str(\"__\");\n    }\n    if spacelen > 2 {\n        out.push('-');\n    }\n    out\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_fix_spaces() {\n        assert_eq!(fix_spaces(\"Example\"), \"Example\");\n        assert_eq!(fix_spaces(\"Mudasir Hanif \"), \"Mudasir_Hanif_\");\n        assert_eq!(\n            fix_spaces(\"Yellow Yellow  Dirty  Fellow\"),\n            \"Yellow_Yellow__Dirty__Fellow\"\n        );\n        assert_eq!(fix_spaces(\"Exa   mple\"), \"Exa-mple\");\n        assert_eq!(fix_spaces(\"   Exa 1 2 2 mple\"), \"-Exa_1_2_2_mple\");\n    }\n\n}\n", "example_test": "None", "prompt_text": "The Brazilian factorial is defined as: brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! where n > 0  For example:", "prompt_explain": "The Brazilian factorial is defined as: brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! where n > 0  For example:\n        assert_eq!(fix_spaces(\"   Exa 1 2 2 mple\"), \"-Exa_1_2_2_mple\")", "func_title": "fn fix_spaces(text: &str) -> String {\n\n", "prompt_text_chinese": "给定一个字符串文本，将其中的所有空格替换为下划线，如果字符串有超过2个连续空格，则将所有连续空格替换为-"}
{"task_id": "Rust/141", "prompt": "/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn file_name_check(file_name: &str) -> &str {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn file_name_check(file_name: &str) -> &str {\n\n", "canonical_solution": "\n    let mut numdigit = 0;\n    let mut numdot = 0;\n    if file_name.len() < 5 {\n        return \"No\";\n    }\n    let w = file_name.chars().nth(0).unwrap();\n    if w < 'A' || (w > 'Z' && w < 'a') || w > 'z' {\n        return \"No\";\n    }\n    let last = &file_name[file_name.len() - 4..];\n    if last != \".txt\" && last != \".exe\" && last != \".dll\" {\n        return \"No\";\n    }\n    for c in file_name.chars() {\n        if c >= '0' && c <= '9' {\n            numdigit += 1;\n        }\n        if c == '.' {\n            numdot += 1;\n        }\n    }\n    if numdigit > 3 || numdot != 1 {\n        return \"No\";\n    }\n    return \"Yes\";\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_file_name_check() {\n        assert_eq!(file_name_check(\"example.txt\"), \"Yes\");\n        assert_eq!(file_name_check(\"1example.dll\"), \"No\");\n        assert_eq!(file_name_check(\"s1sdf3.asd\"), \"No\");\n        assert_eq!(file_name_check(\"K.dll\"), \"Yes\");\n        assert_eq!(file_name_check(\"MY16FILE3.exe\"), \"Yes\");\n        assert_eq!(file_name_check(\"His12FILE94.exe\"), \"No\");\n        assert_eq!(file_name_check(\"_Y.txt\"), \"No\");\n        assert_eq!(file_name_check(\"?aREYA.exe\"), \"No\");\n        assert_eq!(file_name_check(\"/this_is_valid.dll\"), \"No\");\n        assert_eq!(file_name_check(\"this_is_valid.wow\"), \"No\");\n        assert_eq!(file_name_check(\"this_is_valid.txt\"), \"Yes\");\n        assert_eq!(file_name_check(\"this_is_valid.txtexe\"), \"No\");\n        assert_eq!(file_name_check(\"#this2_i4s_5valid.ten\"), \"No\");\n        assert_eq!(file_name_check(\"@this1_is6_valid.exe\"), \"No\");\n        assert_eq!(file_name_check(\"this_is_12valid.6exe4.txt\"), \"No\");\n        assert_eq!(file_name_check(\"all.exe.txt\"), \"No\");\n        assert_eq!(file_name_check(\"I563_No.exe\"), \"Yes\");\n        assert_eq!(file_name_check(\"Is3youfault.txt\"), \"Yes\");\n        assert_eq!(file_name_check(\"no_one#knows.dll\"), \"Yes\");\n        assert_eq!(file_name_check(\"1I563_Yes3.exe\"), \"No\");\n        assert_eq!(file_name_check(\"I563_Yes3.txtt\"), \"No\");\n        assert_eq!(file_name_check(\"final..txt\"), \"No\");\n        assert_eq!(file_name_check(\"final132\"), \"No\");\n        assert_eq!(file_name_check(\"_f4indsartal132.\"), \"No\");\n        assert_eq!(file_name_check(\".txt\"), \"No\");\n        assert_eq!(file_name_check(\"s.\"), \"No\");\n    }\n\n}\n", "example_test": "None", "prompt_text": "Create a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']", "prompt_explain": "Create a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n        assert_eq!(file_name_check(\"s.\"), \"No\")", "func_title": "fn file_name_check(file_name: &str) -> &str {\n\n", "prompt_text_chinese": "创建一个函数，该函数接受一个表示文件名的字符串，如果文件名有效则返回'Yes'，否则返回'No'。当且仅当满足以下所有条件时，文件名才被认为是有效的:—文件名中不应超过三位数字('0'-'9')。-文件名中只包含一个点。-点前的子字符串不能为空，以拉丁字母开头('a'-'z'和'a'-'z')。点后面的子字符串应该是以下其中之一:['txt'， 'exe'， 'dll']"}
{"task_id": "Rust/142", "prompt": "/*\n\"\n    This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n    multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n    change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn sum_squares_142(lst: Vec<i32>) -> i32 {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn sum_squares_142(lst: Vec<i32>) -> i32 {\n\n", "canonical_solution": "\n    let mut sum = 0;\n    for i in 0..lst.len() {\n        if i % 3 == 0 {\n            sum += lst[i] * lst[i];\n        } else if i % 4 == 0 {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_sum_squares_142() {\n        assert_eq!(sum_squares_142(vec![1, 2, 3]), 6);\n        assert_eq!(sum_squares_142(vec![1, 4, 9]), 14);\n        assert_eq!(sum_squares_142(vec![]), 0);\n        assert_eq!(sum_squares_142(vec![1, 1, 1, 1, 1, 1, 1, 1, 1]), 9);\n        assert_eq!(\n            sum_squares_142(vec![-1, -1, -1, -1, -1, -1, -1, -1, -1]),\n            -3\n        );\n        assert_eq!(sum_squares_142(vec![0]), 0);\n        assert_eq!(sum_squares_142(vec![-1, -5, 2, -1, -5]), -126);\n        assert_eq!(sum_squares_142(vec![-56, -99, 1, 0, -2]), 3030);\n        assert_eq!(sum_squares_142(vec![-1, 0, 0, 0, 0, 0, 0, 0, -1]), 0);\n        assert_eq!(\n            sum_squares_142(vec![\n                -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37\n            ]),\n            -14196\n        );\n        assert_eq!(\n            sum_squares_142(vec![\n                -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10\n            ]),\n            -1448\n        );\n    }\n\n}\n", "example_test": "None", "prompt_text": "This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n    multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n    change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.", "prompt_explain": "This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n    multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n    change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n        assert_eq!(\n            sum_squares_142(vec![\n                -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10\n            ]),\n            -1448\n        )", "func_title": "fn sum_squares_142(lst: Vec<i32>) -> i32 {\n\n", "prompt_text_chinese": "这个函数将接受一个整数列表。对于列表中的所有条目，如果索引是3的倍数，则函数将对整数项进行平方;如果索引是4的倍数而不是3的倍数，则函数将对整数项进行立方。该函数将不会更改列表中索引不是3或4的倍数的条目。然后，函数将返回所有项的和。"}
{"task_id": "Rust/143", "prompt": "/*\n\n    You are given a string representing a sentence,\n    the sentence contains some words separated by a space,\n    and you have to return a string that contains the words from the original sentence,\n    whose lengths are prime numbers,\n    the order of the words in the new string should be the same as the original one.\n\n    Constraints:\n        * 1 <= len(sentence) <= 100\n        * sentence contains only letters\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn words_in_sentence(sentence: &str) -> String {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn words_in_sentence(sentence: &str) -> String {\n\n", "canonical_solution": "\n    let mut out = String::new();\n    let mut current = String::new();\n    let mut sentence = sentence.to_string();\n    sentence.push(' ');\n\n    for i in 0..sentence.len() {\n        if sentence.chars().nth(i).unwrap() != ' ' {\n            current.push(sentence.chars().nth(i).unwrap());\n        } else {\n            let mut isp = true;\n            let l = current.len();\n            if l < 2 {\n                isp = false;\n            }\n            for j in 2..(l as f64).sqrt() as usize + 1 {\n                if l % j == 0 {\n                    isp = false;\n                }\n            }\n            if isp {\n                out.push_str(&current);\n                out.push(' ');\n            }\n            current = String::new();\n        }\n    }\n    if out.len() > 0 {\n        out.pop();\n    }\n    out\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_words_in_sentence() {\n        assert_eq!(words_in_sentence(\"This is a test\"), \"is\");\n        assert_eq!(words_in_sentence(\"lets go for swimming\"), \"go for\");\n        assert_eq!(\n            words_in_sentence(\"there is no place available here\"),\n            \"there is no place\"\n        );\n        assert_eq!(words_in_sentence(\"Hi I am Hussein\"), \"Hi am Hussein\");\n        assert_eq!(words_in_sentence(\"go for it\"), \"go for it\");\n        assert_eq!(words_in_sentence(\"here\"), \"\");\n        assert_eq!(words_in_sentence(\"here is\"), \"is\");\n    }\n\n}\n", "example_test": "None", "prompt_text": "You are given a string representing a sentence,\n    the sentence contains some words separated by a space,\n    and you have to return a string that contains the words from the original sentence,\n    whose lengths are prime numbers,\n    the order of the words in the new string should be the same as the original one.", "prompt_explain": "You are given a string representing a sentence,\n    the sentence contains some words separated by a space,\n    and you have to return a string that contains the words from the original sentence,\n    whose lengths are prime numbers,\n    the order of the words in the new string should be the same as the original one.\n        assert_eq!(words_in_sentence(\"here is\"), \"is\")", "func_title": "fn words_in_sentence(sentence: &str) -> String {\n\n", "prompt_text_chinese": "给定一个表示一个句子的字符串，该句子包含一些用空格分隔的单词，并且必须返回一个包含原始句子中的单词的字符串，其长度为素数，新字符串中单词的顺序应与原始字符串相同。"}
{"task_id": "Rust/144", "prompt": "/*\nYour task is to implement a function that will simplify the expression\n    x * n. The function returns True if x * n evaluates to a whole number and False\n    otherwise. Both x and n, are string representation of a fraction, and have the following format,\n    <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n    You can assume that x, and n are valid fractions, and do not have zero as denominator.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn simplify(x: &str, n: &str) -> bool {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn simplify(x: &str, n: &str) -> bool {\n\n", "canonical_solution": "\n    let mut a = 0;\n    let mut b = 0;\n    let mut c = 0;\n    let mut d = 0;\n    let mut i = 0;\n    for i in 0..x.len() {\n        if x.chars().nth(i).unwrap() == '/' {\n            a = x\n                .chars()\n                .take(i)\n                .collect::<String>()\n                .parse::<i32>()\n                .unwrap();\n            b = x\n                .chars()\n                .skip(i + 1)\n                .collect::<String>()\n                .parse::<i32>()\n                .unwrap();\n        }\n    }\n    for i in 0..n.len() {\n        if n.chars().nth(i).unwrap() == '/' {\n            c = n\n                .chars()\n                .take(i)\n                .collect::<String>()\n                .parse::<i32>()\n                .unwrap();\n            d = n\n                .chars()\n                .skip(i + 1)\n                .collect::<String>()\n                .parse::<i32>()\n                .unwrap();\n        }\n    }\n    if (a * c) % (b * d) == 0 {\n        return true;\n    }\n    return false;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_simplify() {\n        assert_eq!(simplify(\"1/5\", \"5/1\"), true);\n        assert_eq!(simplify(\"1/6\", \"2/1\"), false);\n        assert_eq!(simplify(\"5/1\", \"3/1\"), true);\n        assert_eq!(simplify(\"7/10\", \"10/2\"), false);\n        assert_eq!(simplify(\"2/10\", \"50/10\"), true);\n        assert_eq!(simplify(\"7/2\", \"4/2\"), true);\n        assert_eq!(simplify(\"11/6\", \"6/1\"), true);\n        assert_eq!(simplify(\"2/3\", \"5/2\"), false);\n        assert_eq!(simplify(\"5/2\", \"3/5\"), false);\n        assert_eq!(simplify(\"2/4\", \"8/4\"), true);\n        assert_eq!(simplify(\"2/4\", \"4/2\"), true);\n        assert_eq!(simplify(\"1/5\", \"5/1\"), true);\n        assert_eq!(simplify(\"1/5\", \"1/5\"), false);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Your task is to implement a function that will simplify the expression\n    x * n. The function returns True if x * n evaluates to a whole number and False\n    otherwise. Both x and n, are string representation of a fraction, and have the following format,\n    <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n    You can assume that x, and n are valid fractions, and do not have zero as denominator.", "prompt_explain": "Your task is to implement a function that will simplify the expression\n    x * n. The function returns True if x * n evaluates to a whole number and False\n    otherwise. Both x and n, are string representation of a fraction, and have the following format,\n    <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n    You can assume that x, and n are valid fractions, and do not have zero as denominator.\n        assert_eq!(simplify(\"1/5\", \"1/5\"), false)", "func_title": "fn simplify(x: &str, n: &str) -> bool {\n\n", "prompt_text_chinese": "您的任务是实现一个函数来简化表达式x * n。如果x * n的计算结果为整数，则函数返回True，否则返回False。x和n都是分数的字符串表示形式，格式如下:<分子>/<分母>其中分子和分母都是正整数。你可以假设x和n是有效的分数，分母不为零。"}
{"task_id": "Rust/145", "prompt": "/*\n\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn order_by_points(arr: Vec<i32>) -> Vec<i32> {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn order_by_points(arr: Vec<i32>) -> Vec<i32> {\n\n", "canonical_solution": "\n    let mut result = arr.clone();\n    result.sort_by_key(|&x| (sum_of_digits(x)));\n    result\n}\n\npub fn sum_of_digits(n: i32) -> i32 {\n    let mut sum = 0;\n    let mut n = n;\n    if n < 0 {\n        let right = n / 10;\n        let mut left;\n\n        if right != 0 {\n            left = n % 10;\n            left = -1 * left;\n        } else {\n            left = n % 10;\n        }\n        sum = right + left;\n        return sum;\n    }\n\n    while n > 0 {\n        sum += n % 10;\n        n /= 10;\n    }\n    sum\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_order_by_points() {\n        assert_eq!(\n            order_by_points(vec![1, 11, -1, -11, -12]),\n            vec![-1, -11, 1, -12, 11]\n        );\n        assert_eq!(\n            order_by_points(vec![\n                1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46\n            ]),\n            vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n        );\n        assert_eq!(order_by_points(vec![]), vec![]);\n        assert_eq!(\n            order_by_points(vec![1, -11, -32, 43, 54, -98, 2, -3]),\n            vec![-3, -32, -98, -11, 1, 2, 43, 54]\n        );\n        assert_eq!(\n            order_by_points(vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]),\n            vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n        );\n        assert_eq!(\n            order_by_points(vec![0, 6, 6, -76, -21, 23, 4]),\n            vec![-76, -21, 0, 4, 23, 6, 6]\n        );\n    }\n\n}\n", "example_test": "None", "prompt_text": "Write a function which sorts the given list of integers in ascending order according to the sum of their digits. Note: if there are several items with similar sum of their digits, order them based on their index in original list.  For example:", "prompt_explain": "Write a function which sorts the given list of integers in ascending order according to the sum of their digits. Note: if there are several items with similar sum of their digits, order them based on their index in original list.  For example:\n        assert_eq!(\n            order_by_points(vec![0, 6, 6, -76, -21, 23, 4]),\n            vec![-76, -21, 0, 4, 23, 6, 6]\n        )", "func_title": "fn order_by_points(arr: Vec<i32>) -> Vec<i32> {\n\n", "prompt_text_chinese": "编写一个函数，根据给定整数的数字和按升序排序。注:如果有几项数字和相近，则按其在原列表中的索引排序。"}
{"task_id": "Rust/146", "prompt": "/*\nWrite a function that takes an array of numbers as input and returns \n    the number of elements in the array that are greater than 10 and both \n    first and last digits of a number are odd (1, 3, 5, 7, 9).\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn special_filter(nums: Vec<i32>) -> i32 {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn special_filter(nums: Vec<i32>) -> i32 {\n\n", "canonical_solution": "\n    let mut num = 0;\n    for i in 0..nums.len() {\n        if nums[i] > 10 {\n            let w = nums[i].to_string();\n            if w.chars().nth(0).unwrap().to_digit(10).unwrap() % 2 == 1\n                && w.chars().last().unwrap().to_digit(10).unwrap() % 2 == 1\n            {\n                num += 1;\n            }\n        }\n    }\n    num\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_special_filter() {\n        assert_eq!(special_filter(vec![5, -2, 1, -5]), 0);\n        assert_eq!(special_filter(vec![15, -73, 14, -15]), 1);\n        assert_eq!(special_filter(vec![33, -2, -3, 45, 21, 109]), 2);\n        assert_eq!(special_filter(vec![43, -12, 93, 125, 121, 109]), 4);\n        assert_eq!(special_filter(vec![71, -2, -33, 75, 21, 19]), 3);\n        assert_eq!(special_filter(vec![1]), 0);\n        assert_eq!(special_filter(vec![]), 0);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Write a function that takes an array of numbers as input and returns \n    the number of elements in the array that are greater than 10 and both \n    first and last digits of a number are odd (1, 3, 5, 7, 9).", "prompt_explain": "Write a function that takes an array of numbers as input and returns \n    the number of elements in the array that are greater than 10 and both \n    first and last digits of a number are odd (1, 3, 5, 7, 9).\n        assert_eq!(special_filter(vec![]), 0)", "func_title": "fn special_filter(nums: Vec<i32>) -> i32 {\n\n", "prompt_text_chinese": "编写一个函数，该函数接受一个数字数组作为输入，并返回数组中大于10且数字的第一位和最后一位都是奇数(1,3,5,7,9)的元素数量。"}
{"task_id": "Rust/147", "prompt": "/*\n\n    You are given a positive integer n. You have to create an integer array a of length n.\n        For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n        Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n    and a[i] + a[j] + a[k] is a multiple of 3.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn get_matrix_triples(n: i32) -> i32 {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn get_matrix_triples(n: i32) -> i32 {\n\n", "canonical_solution": "\n    let mut a = vec![];\n    let mut sum = vec![vec![0, 0, 0]];\n    let mut sum2 = vec![vec![0, 0, 0]];\n\n    for i in 1..=n {\n        a.push((i * i - i + 1) % 3);\n        sum.push(sum[sum.len() - 1].clone());\n        sum[i as usize][a[i as usize - 1] as usize] += 1;\n    }\n\n    for times in 1..3 {\n        for i in 1..=n {\n            sum2.push(sum2[sum2.len() - 1].clone());\n            if i >= 1 {\n                for j in 0..=2 {\n                    sum2[i as usize][(a[i as usize - 1] + j) as usize % 3] +=\n                        sum[i as usize - 1][j as usize];\n                }\n            }\n        }\n        sum = sum2.clone();\n        sum2 = vec![vec![0, 0, 0]];\n    }\n\n    return sum[n as usize][0];\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_get_matrix_triples() {\n        assert_eq!(get_matrix_triples(5), 1);\n        assert_eq!(get_matrix_triples(6), 4);\n        assert_eq!(get_matrix_triples(10), 36);\n        assert_eq!(get_matrix_triples(100), 53361);\n    }\n\n}\n", "example_test": "None", "prompt_text": "You are given a positive integer n. You have to create an integer array a of length n.\n        For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n        Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n    and a[i] + a[j] + a[k] is a multiple of 3.", "prompt_explain": "You are given a positive integer n. You have to create an integer array a of length n.\n        For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n        Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n    and a[i] + a[j] + a[k] is a multiple of 3.\n        assert_eq!(get_matrix_triples(100), 53361)", "func_title": "fn get_matrix_triples(n: i32) -> i32 {\n\n", "prompt_text_chinese": "给定一个正整数n。你必须创建一个长度为n的整数数组a。对于每个i(1≤i≤n)， a[i] = i * i - i + 1。返回a的三元组(a[i]， a[j]， a[k])的个数，其中i < j < k，且a[i] + a[j] + a[k]是3的倍数。"}
{"task_id": "Rust/148", "prompt": "/*\n\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn bf(planet1: &str, planet2: &str) -> Vec<String> {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn bf(planet1: &str, planet2: &str) -> Vec<String> {\n\n", "canonical_solution": "\n    let planets = vec![\n        \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\",\n    ];\n    let mut pos1: i32 = -1;\n    let mut pos2: i32 = -1;\n    let mut m;\n    for m in 0..planets.len() {\n        if planets[m] == planet1 {\n            pos1 = m as i32;\n        }\n        if planets[m] == planet2 {\n            pos2 = m as i32;\n        }\n    }\n    if pos1 == -1 || pos2 == -1 {\n        return vec![];\n    }\n    if pos1 > pos2 {\n        m = pos1;\n        pos1 = pos2;\n        pos2 = m;\n    }\n    let mut out = vec![];\n    for m in pos1 + 1..pos2 {\n        out.push(planets[m as usize].to_string());\n    }\n    return out;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_bf() {\n        assert_eq!(bf(\"Jupiter\", \"Neptune\"), vec![\"Saturn\", \"Uranus\"]);\n        assert_eq!(bf(\"Earth\", \"Mercury\"), vec![\"Venus\"]);\n        assert_eq!(\n            bf(\"Mercury\", \"Uranus\"),\n            vec![\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]\n        );\n        assert_eq!(\n            bf(\"Neptune\", \"Venus\"),\n            vec![\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"]\n        );\n        let v_empty: Vec<&str> = vec![];\n        assert_eq!(bf(\"Earth\", \"Earth\"), v_empty);\n        assert_eq!(bf(\"Mars\", \"Earth\"), v_empty);\n        assert_eq!(bf(\"Jupiter\", \"Makemake\"), v_empty);\n    }\n\n}\n", "example_test": "None", "prompt_text": "There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names.", "prompt_explain": "There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names.\n        assert_eq!(bf(\"Jupiter\", \"Makemake\"), v_empty)", "func_title": "fn bf(planet1: &str, planet2: &str) -> Vec<String> {\n\n", "prompt_text_chinese": "我们的太阳系有八颗行星:离太阳最近的是水星，其次是金星，然后是地球、火星、木星、土星、天王星、海王星。编写一个函数，将两个行星名作为字符串planet1和planet2。该函数应返回一个元组，其中包含轨道位于planet1轨道和planet2轨道之间的所有行星，按距离太阳的远近排序。如果planet1或planet2不是正确的行星名称，函数将返回一个空元组。"}
{"task_id": "Rust/149", "prompt": "/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn sorted_list_sum(lst: Vec<&str>) -> Vec<&str> {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn sorted_list_sum(lst: Vec<&str>) -> Vec<&str> {\n\n", "canonical_solution": "\n    let mut out: Vec<&str> = Vec::new();\n    for i in 0..lst.len() {\n        if lst[i].len() % 2 == 0 {\n            out.push(lst[i]);\n        }\n    }\n    out.sort();\n    for i in 0..out.len() {\n        for j in 1..out.len() {\n            if out[j].len() < out[j - 1].len() {\n                let mid = out[j];\n                out[j] = out[j - 1];\n                out[j - 1] = mid;\n            }\n        }\n    }\n    return out;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n   #[test]\n    fn test_sorted_list_sum() {\n        assert_eq!(sorted_list_sum(vec![\"aa\", \"a\", \"aaa\"]), vec![\"aa\"]);\n        assert_eq!(\n            sorted_list_sum(vec![\"school\", \"AI\", \"asdf\", \"b\"]),\n            vec![\"AI\", \"asdf\", \"school\"]\n        );\n        let v_empty: Vec<&str> = vec![];\n        assert_eq!(sorted_list_sum(vec![\"d\", \"b\", \"c\", \"a\"]), v_empty);\n        assert_eq!(\n            sorted_list_sum(vec![\"d\", \"dcba\", \"abcd\", \"a\"]),\n            vec![\"abcd\", \"dcba\"]\n        );\n        assert_eq!(\n            sorted_list_sum(vec![\"AI\", \"ai\", \"au\"]),\n            vec![\"AI\", \"ai\", \"au\"]\n        );\n        assert_eq!(sorted_list_sum(vec![\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]), v_empty);\n        assert_eq!(\n            sorted_list_sum(vec![\"aaaa\", \"bbbb\", \"dd\", \"cc\"]),\n            vec![\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n        );\n    }\n\n}\n", "example_test": "None", "prompt_text": "Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.", "prompt_explain": "Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n        assert_eq!(\n            sorted_list_sum(vec![\"aaaa\", \"bbbb\", \"dd\", \"cc\"]),\n            vec![\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n        )", "func_title": "fn sorted_list_sum(lst: Vec<&str>) -> Vec<&str> {\n\n", "prompt_text_chinese": "编写一个函数，接受字符串列表作为参数，从其中删除长度为奇数的字符串，并以排序顺序返回结果列表。列表始终是字符串列表，而不是数字数组，并且可能包含重复的数字。列表的顺序应该按每个单词的长度递增，并且您应该返回按该规则排序的列表。如果两个单词的长度相同，则按字母顺序对列表进行排序。该函数应返回一个按顺序排列的字符串列表。你可以假设所有的单词都有相同的长度。"}
{"task_id": "Rust/150", "prompt": "/*\nA simple program which should return the value of x if n is \n    a prime number and should return the value of y otherwise.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn x_or_y(n: i32, x: i32, y: i32) -> i32 {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn x_or_y(n: i32, x: i32, y: i32) -> i32 {\n\n", "canonical_solution": "\n    let mut isp = true;\n    if n < 2 {\n        isp = false;\n    }\n    for i in 2..=n / 2 {\n        if n % i == 0 {\n            isp = false;\n        }\n    }\n    if isp {\n        return x;\n    }\n    return y;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_x_or_y() {\n        assert_eq!(x_or_y(7, 34, 12), 34);\n        assert_eq!(x_or_y(15, 8, 5), 5);\n        assert_eq!(x_or_y(3, 33, 5212), 33);\n        assert_eq!(x_or_y(1259, 3, 52), 3);\n        assert_eq!(x_or_y(7919, -1, 12), -1);\n        assert_eq!(x_or_y(3609, 1245, 583), 583);\n        assert_eq!(x_or_y(91, 56, 129), 129);\n        assert_eq!(x_or_y(6, 34, 1234), 1234);\n        assert_eq!(x_or_y(1, 2, 0), 0);\n        assert_eq!(x_or_y(2, 2, 0), 2);\n    }\n\n}\n", "example_test": "None", "prompt_text": "A simple program which should return the value of x if n is \n    a prime number and should return the value of y otherwise.", "prompt_explain": "A simple program which should return the value of x if n is \n    a prime number and should return the value of y otherwise.\n        assert_eq!(x_or_y(2, 2, 0), 2)", "func_title": "fn x_or_y(n: i32, x: i32, y: i32) -> i32 {\n\n", "prompt_text_chinese": "一个简单的程序，如果n是质数，则返回x的值，否则返回y的值。"}
{"task_id": "Rust/151", "prompt": "/*\n\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n   \n    If the input list is empty, return 0.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn double_the_difference(lst: Vec<f32>) -> i64 {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn double_the_difference(lst: Vec<f32>) -> i64 {\n\n", "canonical_solution": "\n    let mut sum: i64 = 0;\n    for i in 0..lst.len() {\n        if (lst[i] - lst[i].round()).abs() < 1e-4 {\n            if lst[i] > 0.0 && (lst[i].round() as i64) % 2 == 1 {\n                sum += (lst[i].round() as i64) * (lst[i].round() as i64);\n            }\n        }\n    }\n    return sum;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_double_the_difference() {\n        assert_eq!(double_the_difference(vec![]), 0);\n        assert_eq!(double_the_difference(vec![5.0, 4.0]), 25);\n        assert_eq!(double_the_difference(vec![0.1, 0.2, 0.3]), 0);\n        assert_eq!(double_the_difference(vec![-10.0, -20.0, -30.0]), 0);\n        assert_eq!(double_the_difference(vec![-1.0, -2.0, 8.0]), 0);\n        assert_eq!(double_the_difference(vec![0.2, 3.0, 5.0]), 34);\n\n        let mut lst = vec![];\n        let mut odd_sum = 0;\n        for i in -99..100 {\n            lst.push(i as f32);\n            if i > 0 && i % 2 == 1 {\n                odd_sum += i * i;\n            }\n        }\n        assert_eq!(double_the_difference(lst), odd_sum);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.", "prompt_explain": "Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n            }\n        }\n        assert_eq!(double_the_difference(lst), odd_sum)", "func_title": "fn double_the_difference(lst: Vec<f32>) -> i64 {\n\n", "prompt_text_chinese": "给定一个数字列表，返回列表中奇数的平方和。忽略负数或非整数的数字。"}
{"task_id": "Rust/152", "prompt": "/*\nI think we all remember that feeling when the result of some long-awaited\n    event is finally known. The feelings and thoughts you have at that moment are\n    definitely worth noting down and comparing.\n    Your task is to determine if a person correctly guessed the results of a number of matches.\n    You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn compare(game: Vec<i32>, guess: Vec<i32>) -> Vec<i32> {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn compare(game: Vec<i32>, guess: Vec<i32>) -> Vec<i32> {\n\n", "canonical_solution": "\n    let mut out: Vec<i32> = Vec::new();\n    for i in 0..game.len() {\n        out.push(i32::abs(game[i] - guess[i]));\n    }\n    return out;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_compare() {\n        assert_eq!(\n            compare(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2]),\n            vec![0, 0, 0, 0, 3, 3]\n        );\n        assert_eq!(\n            compare(vec![0, 5, 0, 0, 0, 4], vec![4, 1, 1, 0, 0, -2]),\n            vec![4, 4, 1, 0, 0, 6]\n        );\n        assert_eq!(\n            compare(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2]),\n            vec![0, 0, 0, 0, 3, 3]\n        );\n        assert_eq!(\n            compare(vec![0, 0, 0, 0, 0, 0], vec![0, 0, 0, 0, 0, 0]),\n            vec![0, 0, 0, 0, 0, 0]\n        );\n        assert_eq!(compare(vec![1, 2, 3], vec![-1, -2, -3]), vec![2, 4, 6]);\n        assert_eq!(\n            compare(vec![1, 2, 3, 5], vec![-1, 2, 3, 4]),\n            vec![2, 0, 0, 1]\n        );\n    }\n\n}\n", "example_test": "None", "prompt_text": "I think we all remember that feeling when the result of some long-awaited\n    event is finally known. The feelings and thoughts you have at that moment are\n    definitely worth noting down and comparing.\n    Your task is to determine if a person correctly guessed the results of a number of matches.\n    You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    the value is 0, and if not, the value is the absolute difference between the guess and the score.", "prompt_explain": "I think we all remember that feeling when the result of some long-awaited\n    event is finally known. The feelings and thoughts you have at that moment are\n    definitely worth noting down and comparing.\n    Your task is to determine if a person correctly guessed the results of a number of matches.\n    You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    the value is 0, and if not, the value is the absolute difference between the guess and the score.\n        assert_eq!(\n            compare(vec![1, 2, 3, 5], vec![-1, 2, 3, 4]),\n            vec![2, 0, 0, 1]\n        )", "func_title": "fn compare(game: Vec<i32>, guess: Vec<i32>) -> Vec<i32> {\n\n", "prompt_text_chinese": "我想我们都记得那种期待已久的结果终于揭晓的感觉。你在那一刻的感受和想法绝对值得记录和比较。你的任务是确定一个人是否正确地猜出了一些匹配的结果。您将得到两个长度相等的分数和猜测数组，其中每个索引显示一个匹配。返回一个相同长度的数组，表示每次猜测的距离。如果他们猜对了，这个值是0，如果没有，这个值是猜对和分数之间的绝对差。"}
{"task_id": "Rust/153", "prompt": "/*\nYou will be given the name of a class (a string) and a list of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the list.\n    For example, if you are given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn strongest_extension(class_name: &str, extensions: Vec<&str>) -> String { \n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn strongest_extension(class_name: &str, extensions: Vec<&str>) -> String { \n\n", "canonical_solution": "\n    let mut strongest = \"\";\n    let mut max = -1000;\n    for i in 0..extensions.len() {\n        let mut strength = 0;\n        for j in 0..extensions[i].len() {\n            let chr = extensions[i].chars().nth(j).unwrap();\n            if chr >= 'A' && chr <= 'Z' {\n                strength += 1;\n            }\n            if chr >= 'a' && chr <= 'z' {\n                strength -= 1;\n            }\n        }\n        if strength > max {\n            max = strength;\n            strongest = extensions[i];\n        }\n    }\n    format!(\"{}.{}\", class_name, strongest)\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_strongest_extension() {\n        assert_eq!(\n            strongest_extension(\"Watashi\", vec![\"tEN\", \"niNE\", \"eIGHt8OKe\"]),\n            \"Watashi.eIGHt8OKe\"\n        );\n        assert_eq!(\n            strongest_extension(\"Boku123\", vec![\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]),\n            \"Boku123.YEs.WeCaNe\"\n        );\n        assert_eq!(\n            strongest_extension(\n                \"__YESIMHERE\",\n                vec![\"t\", \"eMptY\", \"(nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]\n            ),\n            \"__YESIMHERE.NuLl__\"\n        );\n        assert_eq!(\n            strongest_extension(\"K\", vec![\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]),\n            \"K.TAR\"\n        );\n        assert_eq!(\n            strongest_extension(\"__HAHA\", vec![\"Tab\", \"123\", \"781345\", \"-_-\"]),\n            \"__HAHA.123\"\n        );\n        assert_eq!(\n            strongest_extension(\n                \"YameRore\",\n                vec![\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]\n            ),\n            \"YameRore.okIWILL123\"\n        );\n        assert_eq!(\n            strongest_extension(\"finNNalLLly\", vec![\"Die\", \"NowW\", \"Wow\", \"WoW\"]),\n            \"finNNalLLly.WoW\"\n        );\n        assert_eq!(strongest_extension(\"_\", vec![\"Bb\", \"91245\"]), \"_.Bb\");\n        assert_eq!(strongest_extension(\"Sp\", vec![\"671235\", \"Bb\"]), \"Sp.671235\");\n    }\n\n}\n", "example_test": "None", "prompt_text": "You will be given the name of a class (a string) and a list of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the list.", "prompt_explain": "You will be given the name of a class (a string) and a list of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the list.\n        assert_eq!(strongest_extension(\"Sp\", vec![\"671235\", \"Bb\"]), \"Sp.671235\")", "func_title": "fn strongest_extension(class_name: &str, extensions: Vec<&str>) -> String { \n\n", "prompt_text_chinese": "您将得到一个类的名称(一个字符串)和一个扩展列表。扩展将用于将其他类加载到类中。扩展的强度如下:设CAP为扩展名中大写字母的个数，SM为扩展名中小写字母的个数，强度由分数CAP - SM给出。您应该找到最强的扩展并返回如下格式的字符串:classname . stronggestextensionname。如果有两个或更多具有相同强度的扩展，您应该选择列表中最先出现的扩展。"}
{"task_id": "Rust/154", "prompt": "/*\nYou are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn cycpattern_check(a: &str, b: &str) -> bool {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn cycpattern_check(a: &str, b: &str) -> bool {\n\n", "canonical_solution": "\n    for i in 0..b.len() {\n        let rotate = format!(\"{}{}\", &b[i..], &b[..i]);\n        if a.contains(&rotate) {\n            return true;\n        }\n    }\n    false\n}\n\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_cycpattern_check() {\n        assert_eq!(cycpattern_check(\"xyzw\", \"xyw\"), false);\n        assert_eq!(cycpattern_check(\"yello\", \"ell\"), true);\n        assert_eq!(cycpattern_check(\"whattup\", \"ptut\"), false);\n        assert_eq!(cycpattern_check(\"efef\", \"fee\"), true);\n        assert_eq!(cycpattern_check(\"abab\", \"aabb\"), false);\n        assert_eq!(cycpattern_check(\"winemtt\", \"tinem\"), true);\n    }\n\n}\n", "example_test": "None", "prompt_text": "You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word", "prompt_explain": "You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word\n        assert_eq!(cycpattern_check(\"winemtt\", \"tinem\"), true)", "func_title": "fn cycpattern_check(a: &str, b: &str) -> bool {\n\n", "prompt_text_chinese": "给你两个单词。如果第二个单词或它的任何旋转是第一个单词的子字符串，则需要返回True"}
{"task_id": "Rust/155", "prompt": "/*\nGiven an integer. return a tuple that has the number of even and odd digits respectively.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn even_odd_count(num: i32) -> Vec<i32> {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn even_odd_count(num: i32) -> Vec<i32> {\n\n", "canonical_solution": "\n    let w = num.abs().to_string();\n    let mut n1 = 0;\n    let mut n2 = 0;\n    for i in 0..w.len() {\n        if w.chars().nth(i).unwrap().to_digit(10).unwrap() % 2 == 1 {\n            n1 += 1;\n        } else {\n            n2 += 1;\n        }\n    }\n    vec![n2, n1]\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_even_odd() {\n        assert_eq!(even_odd_count(7), vec![0, 1]);\n        assert_eq!(even_odd_count(-78), vec![1, 1]);\n        assert_eq!(even_odd_count(3452), vec![2, 2]);\n        assert_eq!(even_odd_count(346211), vec![3, 3]);\n        assert_eq!(even_odd_count(-345821), vec![3, 3]);\n        assert_eq!(even_odd_count(-2), vec![1, 0]);\n        assert_eq!(even_odd_count(-45347), vec![2, 3]);\n        assert_eq!(even_odd_count(0), vec![1, 0]);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Given an integer. return a tuple that has the number of even and odd digits respectively.", "prompt_explain": "Given an integer. return a tuple that has the number of even and odd digits respectively.\n        assert_eq!(even_odd_count(0), vec![1, 0])", "func_title": "fn even_odd_count(num: i32) -> Vec<i32> {\n\n", "prompt_text_chinese": "给定一个整数。返回一个元组，该元组分别包含偶数和奇数位数。"}
{"task_id": "Rust/156", "prompt": "/*\n\n    Given a positive integer, obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n    Restrictions: 1 <= num <= 1000\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn int_to_mini_romank(number: i32) -> String {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn int_to_mini_romank(number: i32) -> String {\n\n", "canonical_solution": "\n    let mut current = String::new();\n    let mut number = number;\n    let rep = vec![\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\",\n    ];\n    let num = vec![1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    let mut pos = 0;\n    while number > 0 {\n        while number >= num[pos] {\n            current.push_str(rep[pos]);\n            number -= num[pos];\n        }\n        if number > 0 {\n            pos += 1;\n        }\n    }\n    current\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_int_to_mini_romank() {\n        assert_eq!(int_to_mini_romank(19), \"xix\");\n        assert_eq!(int_to_mini_romank(152), \"clii\");\n        assert_eq!(int_to_mini_romank(251), \"ccli\");\n        assert_eq!(int_to_mini_romank(426), \"cdxxvi\");\n        assert_eq!(int_to_mini_romank(500), \"d\");\n        assert_eq!(int_to_mini_romank(1), \"i\");\n        assert_eq!(int_to_mini_romank(4), \"iv\");\n        assert_eq!(int_to_mini_romank(43), \"xliii\");\n        assert_eq!(int_to_mini_romank(90), \"xc\");\n        assert_eq!(int_to_mini_romank(94), \"xciv\");\n        assert_eq!(int_to_mini_romank(532), \"dxxxii\");\n        assert_eq!(int_to_mini_romank(900), \"cm\");\n        assert_eq!(int_to_mini_romank(994), \"cmxciv\");\n        assert_eq!(int_to_mini_romank(1000), \"m\");\n    }\n\n}\n", "example_test": "None", "prompt_text": "Given a positive integer, obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n    Restrictions: 1 <= num <= 1000", "prompt_explain": "Given a positive integer, obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n    Restrictions: 1 <= num <= 1000\n        assert_eq!(int_to_mini_romank(1000), \"m\")", "func_title": "fn int_to_mini_romank(number: i32) -> String {\n\n", "prompt_text_chinese": "给定一个正整数，将其等效的罗马数字作为字符串，并以小写形式返回。限制条件:1 <= num <= 1000"}
{"task_id": "Rust/157", "prompt": "/*\n\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn right_angle_triangle(a: f32, b: f32, c: f32) -> bool {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn right_angle_triangle(a: f32, b: f32, c: f32) -> bool {\n\n", "canonical_solution": "\n    if (a * a + b * b - c * c).abs() < 1e-4\n        || (a * a + c * c - b * b).abs() < 1e-4\n        || (b * b + c * c - a * a).abs() < 1e-4\n    {\n        return true;\n    }\n    return false;\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_right_angle_triangle() {\n        assert_eq!(right_angle_triangle(3.0, 4.0, 5.0), true);\n        assert_eq!(right_angle_triangle(1.0, 2.0, 3.0), false);\n        assert_eq!(right_angle_triangle(10.0, 6.0, 8.0), true);\n        assert_eq!(right_angle_triangle(2.0, 2.0, 2.0), false);\n        assert_eq!(right_angle_triangle(7.0, 24.0, 25.0), true);\n        assert_eq!(right_angle_triangle(10.0, 5.0, 7.0), false);\n        assert_eq!(right_angle_triangle(5.0, 12.0, 13.0), true);\n        assert_eq!(right_angle_triangle(15.0, 8.0, 17.0), true);\n        assert_eq!(right_angle_triangle(48.0, 55.0, 73.0), true);\n        assert_eq!(right_angle_triangle(1.0, 1.0, 1.0), false);\n        assert_eq!(right_angle_triangle(2.0, 2.0, 10.0), false);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.", "prompt_explain": "Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n        assert_eq!(right_angle_triangle(2.0, 2.0, 10.0), false)", "func_title": "fn right_angle_triangle(a: f32, b: f32, c: f32) -> bool {\n\n", "prompt_text_chinese": "已知三角形三条边的长度。如果三条边组成一个直角三角形则返回True，否则返回False。直角三角形是其中一个角是直角或90度的三角形。"}
{"task_id": "Rust/158", "prompt": "/*\nWrite a function that accepts a list of strings.\n    The list contains different words. Return the word with maximum number\n    of unique characters. If multiple strings have maximum number of unique\n    characters, return the one which comes first in lexicographical order.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn find_max(words: Vec<&str>) -> &str {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn find_max(words: Vec<&str>) -> &str {\n\n", "canonical_solution": "\n    let mut max = \"\";\n    let mut maxu = 0;\n    for i in 0..words.len() {\n        let mut unique = String::from(\"\");\n        for j in 0..words[i].len() {\n            if !unique.contains(words[i].chars().nth(j).unwrap()) {\n                unique.push(words[i].chars().nth(j).unwrap());\n            }\n        }\n        if unique.len() > maxu || (unique.len() == maxu && words[i] < max) {\n            max = words[i];\n            maxu = unique.len();\n        }\n    }\n    max\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_find_max() {\n        assert_eq!(find_max(vec![\"name\", \"of\", \"string\"]), \"string\");\n        assert_eq!(find_max(vec![\"name\", \"enam\", \"game\"]), \"enam\");\n        assert_eq!(find_max(vec![\"aaaaaaa\", \"bb\", \"cc\"]), \"aaaaaaa\");\n        assert_eq!(find_max(vec![\"abc\", \"cba\"]), \"abc\");\n        assert_eq!(\n            find_max(vec![\"play\", \"this\", \"game\", \"of\", \"footbott\"]),\n            \"footbott\"\n        );\n        assert_eq!(find_max(vec![\"we\", \"are\", \"gonna\", \"rock\"]), \"gonna\");\n        assert_eq!(find_max(vec![\"we\", \"are\", \"a\", \"mad\", \"nation\"]), \"nation\");\n        assert_eq!(find_max(vec![\"this\", \"is\", \"a\", \"prrk\"]), \"this\");\n        assert_eq!(find_max(vec![\"b\"]), \"b\");\n        assert_eq!(find_max(vec![\"play\", \"play\", \"play\"]), \"play\");\n    }\n\n}\n", "example_test": "None", "prompt_text": "Write a function that accepts a list of strings.\n    The list contains different words. Return the word with maximum number\n    of unique characters. If multiple strings have maximum number of unique\n    characters, return the one which comes first in lexicographical order.", "prompt_explain": "Write a function that accepts a list of strings.\n    The list contains different words. Return the word with maximum number\n    of unique characters. If multiple strings have maximum number of unique\n    characters, return the one which comes first in lexicographical order.\n        assert_eq!(find_max(vec![\"play\", \"play\", \"play\"]), \"play\")", "func_title": "fn find_max(words: Vec<&str>) -> &str {\n\n", "prompt_text_chinese": "编写一个接受字符串列表的函数。这个列表包含了不同的单词。返回具有最大惟一字符数的单词。如果多个字符串具有最大惟一字符数，则返回按字典顺序排在前面的字符串。"}
{"task_id": "Rust/159", "prompt": "/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn eat(number: i32, need: i32, remaining: i32) -> Vec<i32> {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn eat(number: i32, need: i32, remaining: i32) -> Vec<i32> {\n\n", "canonical_solution": "\n    if need > remaining {\n        return vec![number + remaining, 0];\n    }\n    return vec![number + need, remaining - need];\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_eat() {\n        assert_eq!(eat(5, 6, 10), vec![11, 4]);\n        assert_eq!(eat(4, 8, 9), vec![12, 1]);\n        assert_eq!(eat(1, 10, 10), vec![11, 0]);\n        assert_eq!(eat(2, 11, 5), vec![7, 0]);\n        assert_eq!(eat(4, 5, 7), vec![9, 2]);\n        assert_eq!(eat(4, 5, 1), vec![5, 0]);\n    }\n\n}\n", "example_test": "None", "prompt_text": "You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.", "prompt_explain": "You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n        assert_eq!(eat(4, 5, 1), vec![5, 0])", "func_title": "fn eat(number: i32, need: i32, remaining: i32) -> Vec<i32> {\n\n", "prompt_text_chinese": "你是一只饥饿的兔子，你已经吃了一定数量的胡萝卜，但现在你需要吃更多的胡萝卜来完成一天的三餐。您应该返回一个数组[餐后吃的胡萝卜总数，餐后剩下的胡萝卜数量]如果没有足够的剩余胡萝卜，您将吃掉所有剩余的胡萝卜，但仍然会感到饥饿。"}
{"task_id": "Rust/160", "prompt": "/*\n\n    Given two lists operator, and operand. The first list has basic algebra operations, and \n    the second list is a list of integers. Use the two given lists to build the algebric \n    expression and return the evaluation of this expression.\n\n    The basic algebra operations:\n    Addition ( + ) \n    Subtraction ( - ) \n    Multiplication ( * ) \n    Floor division ( // ) \n    Exponentiation ( ** ) \n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn do_algebra(operato: Vec<&str>, operand: Vec<i32>) -> i32 {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn do_algebra(operato: Vec<&str>, operand: Vec<i32>) -> i32 {\n\n", "canonical_solution": "\n    let mut operand: Vec<i32> = operand;\n    let mut num: Vec<i32> = vec![];\n    let mut posto: Vec<i32> = vec![];\n    for i in 0..operand.len() {\n        posto.push(i as i32);\n    }\n    for i in 0..operato.len() {\n        if operato[i] == \"**\" {\n            while posto[posto[i] as usize] != posto[i] {\n                posto[i] = posto[posto[i] as usize];\n            }\n            while posto[posto[i + 1] as usize] != posto[i + 1] {\n                posto[i + 1] = posto[posto[i + 1] as usize];\n            }\n            operand[posto[i] as usize] =\n                operand[posto[i] as usize].pow(operand[posto[i + 1] as usize] as u32);\n            posto[i + 1] = posto[i];\n        }\n    }\n    for i in 0..operato.len() {\n        if operato[i] == \"*\" || operato[i] == \"//\" {\n            while posto[posto[i] as usize] != posto[i] {\n                posto[i] = posto[posto[i] as usize];\n            }\n            while posto[posto[i + 1] as usize] != posto[i + 1] {\n                posto[i + 1] = posto[posto[i + 1] as usize];\n            }\n            if operato[i] == \"*\" {\n                operand[posto[i] as usize] =\n                    operand[posto[i] as usize] * operand[posto[i + 1] as usize];\n            } else {\n                operand[posto[i] as usize] =\n                    operand[posto[i] as usize] / operand[posto[i + 1] as usize];\n            }\n            posto[i + 1] = posto[i];\n        }\n    }\n    for i in 0..operato.len() {\n        if operato[i] == \"+\" || operato[i] == \"-\" {\n            while posto[posto[i] as usize] != posto[i] {\n                posto[i] = posto[posto[i] as usize];\n            }\n            while posto[posto[i + 1] as usize] != posto[i + 1] {\n                posto[i + 1] = posto[posto[i + 1] as usize];\n            }\n            if operato[i] == \"+\" {\n                operand[posto[i] as usize] =\n                    operand[posto[i] as usize] + operand[posto[i + 1] as usize];\n            } else {\n                operand[posto[i] as usize] =\n                    operand[posto[i] as usize] - operand[posto[i + 1] as usize];\n            }\n            posto[i + 1] = posto[i];\n        }\n    }\n    operand[0]\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_do_algebra() {\n        assert_eq!(do_algebra(vec![\"**\", \"*\", \"+\"], vec![2, 3, 4, 5]), 37);\n        assert_eq!(do_algebra(vec![\"+\", \"*\", \"-\"], vec![2, 3, 4, 5]), 9);\n        assert_eq!(do_algebra(vec![\"//\", \"*\"], vec![7, 3, 4]), 8);\n    }\n\n\n}\n", "example_test": "None", "prompt_text": "Given two lists operator, and operand. The first list has basic algebra operations, and \n    the second list is a list of integers. Use the two given lists to build the algebric \n    expression and return the evaluation of this expression.", "prompt_explain": "Given two lists operator, and operand. The first list has basic algebra operations, and \n    the second list is a list of integers. Use the two given lists to build the algebric \n    expression and return the evaluation of this expression.\n        assert_eq!(do_algebra(vec![\"//\", \"*\"], vec![7, 3, 4]), 8)", "func_title": "fn do_algebra(operato: Vec<&str>, operand: Vec<i32>) -> i32 {\n\n", "prompt_text_chinese": "给定两个列表操作符和操作数。第一个列表有基本的代数运算，第二个列表是一个整数列表。使用两个给定的列表构建代数表达式并返回该表达式的求值。"}
{"task_id": "Rust/161", "prompt": "/*\nYou are given a string s.\n    if s[i] is a letter, reverse its case from lower to upper or vise versa, \n    otherwise keep it as it is.\n    If the string contains no letters, reverse the string.\n    The function should return the resulted string.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn solve_161(s: &str) -> String {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn solve_161(s: &str) -> String {\n\n", "canonical_solution": "\n    let mut nletter = 0;\n    let mut out = String::new();\n    for c in s.chars() {\n        let mut w = c;\n        if w >= 'A' && w <= 'Z' {\n            w = w.to_ascii_lowercase();\n        } else if w >= 'a' && w <= 'z' {\n            w = w.to_ascii_uppercase();\n        } else {\n            nletter += 1;\n        }\n        out.push(w);\n    }\n    if nletter == s.len() {\n        out.chars().rev().collect()\n    } else {\n        out\n    }\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_solve_161() {\n        assert_eq!(solve_161(\"AsDf\"), \"aSdF\");\n        assert_eq!(solve_161(\"1234\"), \"4321\");\n        assert_eq!(solve_161(\"ab\"), \"AB\");\n        assert_eq!(solve_161(\"#a@C\"), \"#A@c\");\n        assert_eq!(solve_161(\"#AsdfW^45\"), \"#aSDFw^45\");\n        assert_eq!(solve_161(\"#6@2\"), \"2@6#\");\n        assert_eq!(solve_161(\"#$a^D\"), \"#$A^d\");\n        assert_eq!(solve_161(\"#ccc\"), \"#CCC\");\n    }\n\n}\n", "example_test": "None", "prompt_text": "You are given a string s.\n    if s[i] is a letter, reverse its case from lower to upper or vise versa, \n    otherwise keep it as it is.\n    If the string contains no letters, reverse the string.\n    The function should return the resulted string.", "prompt_explain": "You are given a string s.\n    if s[i] is a letter, reverse its case from lower to upper or vise versa, \n    otherwise keep it as it is.\n    If the string contains no letters, reverse the string.\n    The function should return the resulted string.\n        assert_eq!(solve_161(\"#ccc\"), \"#CCC\")", "func_title": "fn solve_161(s: &str) -> String {\n\n", "prompt_text_chinese": "给你一个字符串s，如果s[i]是一个字母，将它的大小写从下到上颠倒，反之亦然，否则保持它的原样。如果字符串不包含字母，则反转字符串。函数应该返回结果字符串。"}
{"task_id": "Rust/162", "prompt": "/*\n\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn string_to_md5(text: &str) -> String {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn string_to_md5(text: &str) -> String {\n\n", "canonical_solution": "\n    if text.is_empty() {\n        return \"None\".to_string();\n    }\n\n    let digest = md5::compute(text.as_bytes());\n    return format!(\"{:x}\", digest);\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_string_to_md5() {\n        assert_eq!(\n            string_to_md5(\"Hello world\"),\n            \"3e25960a79dbc69b674cd4ec67a72c62\"\n        );\n        assert_eq!(string_to_md5(\"\"), \"None\");\n        assert_eq!(string_to_md5(\"A B C\"), \"0ef78513b0cb8cef12743f5aeb35f888\");\n        assert_eq!(\n            string_to_md5(\"password\"),\n            \"5f4dcc3b5aa765d61d8327deb882cf99\"\n        );\n    }\n\n}\n", "example_test": "None", "prompt_text": "Given a string 'text', return its md5 hash equivalent string. If 'text' is an empty string, return None. ", "prompt_explain": "Given a string 'text', return its md5 hash equivalent string. If 'text' is an empty string, return None. \n        assert_eq!(\n            string_to_md5(\"password\"),\n            \"5f4dcc3b5aa765d61d8327deb882cf99\"\n        )", "func_title": "fn string_to_md5(text: &str) -> String {\n\n", "prompt_text_chinese": "给定字符串'text'，返回其md5哈希等效字符串。如果'text'是空字符串，则返回None。"}
{"task_id": "Rust/163", "prompt": "/*\n\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order.\n    \n*/\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn generate_integers(a: i32, b: i32) -> Vec<i32> {\n\n", "declaration": "\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn generate_integers(a: i32, b: i32) -> Vec<i32> {\n\n", "canonical_solution": "\n    let mut a = a;\n    let mut b = b;\n    let mut m;\n\n    if b < a {\n        m = a;\n        a = b;\n        b = m;\n    }\n\n    let mut out = vec![];\n    for i in a..=b {\n        if i < 10 && i % 2 == 0 {\n            out.push(i);\n        }\n    }\n    out\n}\n", "test": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_generate_integers() {\n        assert_eq!(generate_integers(2, 10), vec![2, 4, 6, 8]);\n        assert_eq!(generate_integers(10, 2), vec![2, 4, 6, 8]);\n        assert_eq!(generate_integers(132, 2), vec![2, 4, 6, 8]);\n        assert_eq!(generate_integers(17, 89), vec![]);\n    }\n\n}\n", "example_test": "None", "prompt_text": "Given two positive integers a and b, return the even digits between a\n    and b, in ascending order. ", "prompt_explain": "Given two positive integers a and b, return the even digits between a\n    and b, in ascending order. \n        assert_eq!(generate_integers(17, 89), vec![])", "func_title": "fn generate_integers(a: i32, b: i32) -> Vec<i32> {\n\n", "prompt_text_chinese": "给定两个正整数a和b，按升序返回a和b之间的偶数。"}
