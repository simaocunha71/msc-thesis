        int min = Integer.MAX_VALUE;
        int sum = 0;
        for(int num : nums){
            sum += num;
            min = Math.min(min, sum);
            if(sum > 0){
                sum = 0;
            }
        }
        return min;
    }
}

This solution works by iterating through the array and adding each number to the current sum. It then compares this sum to the current minimum sum found. If the sum is greater than 0, it resets the sum to 0. This is because a subarray that starts at a positive sum and then becomes negative will yield a smaller sum, so it is discarded. The final minimum sum is returned at the end of the loop.

This solution has a time complexity of O(n), where n is the length of the input array, and a space complexity of O(1), as it only uses a constant amount of extra space.

This solution assumes that the input list is not empty and contains at least one positive number.

Please note that this solution doesn't find the smallest non-empty subarray, but the smallest subarray that can be made up of negative numbers.

Please, also note that the question seems to be a duplicate of "Minimum subarray sum" problem, which is a more general problem and this solution is a specific case of that problem.















































































































































































































