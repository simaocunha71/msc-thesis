        if (x < 1 || n < 1) {
            return false;
        }
        if (x == 1) {
            return true;
        }
        while (x % n == 0) {
            x /= n;
        }
        return x == 1;
    }
}

The solution is based on the idea that a number x is a simple power of n if x can be represented as the power of n, i.e., n^i, where i is an integer. Therefore, we can use a while loop to continuously divide x by n until x cannot be evenly divided by n anymore. If x is 1 at the end of this process, then x is a simple power of n. Otherwise, it is not.

The time complexity is O(log(x)) as we keep dividing x by n until x becomes 1. The space complexity is O(1), as we only use a constant amount of space to store the input and a few variables.

The solution also handles the case where x or n is 1 by returning true if x is 1 (since 1 is a simple power of any number) and false if n is 1 (since 1 is not a simple power of any number).

Test this code with several examples to ensure it works as expected.

```




























































































































































































































