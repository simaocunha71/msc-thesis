        String maxWord = "";
        int maxUnique = 0;

        for (String word : words) {
            Set<Character> uniqueChars = new HashSet<>();
            for (char c : word.toCharArray()) {
                uniqueChars.add(c);
            }

            if (uniqueChars.size() > maxUnique || 
                (uniqueChars.size() == maxUnique && word.compareTo(maxWord) < 0)) {
                maxUnique = uniqueChars.size();
                maxWord = word;
            }
        }

        return maxWord;
    }
}

This solution works by iterating through each word in the list and creating a HashSet of its unique characters. Then it checks if the size of this HashSet is greater than the current maximum number of unique characters found. If so, it updates the maximum and the corresponding word. If the number of unique characters is equal, it checks lexicographically.

In terms of time complexity, this is O(n*m) because for each word it iterates through each character, and in the worst case scenario (all words have same number of characters) it checks each word. The space complexity is O(n*m) because in the worst case scenario (all words have same number of characters) it stores each word in a HashSet.
*/















































































































































































































