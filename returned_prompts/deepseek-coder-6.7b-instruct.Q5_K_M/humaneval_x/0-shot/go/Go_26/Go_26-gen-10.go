
    // First, initialize a map to count the occurrence of each number
    counts := make(map[int]int)
    for _, num := range numbers {
        counts[num]++
    }

    // Then, iterate over the original list and only add numbers to the result
    // if their count in the map is 1 (meaning they were not duplicates)
    result := make([]int, 0, len(numbers))
    for _, num := range numbers {
        if counts[num] == 1 {
            result = append(result, num)
        }
    }

    return result
}


```

This is a simple solution in Go. Here we use a map to count the occurrence of each number. Then we iterate over the original list and add numbers to the result only if their count in the map is 1. The result list will not contain duplicates and will keep the original order.

The time complexity of this algorithm is O(n) because we iterate over the list twice. The space complexity is also O(n) because we use a map to keep track of the count of each number.


























































































































































































































































