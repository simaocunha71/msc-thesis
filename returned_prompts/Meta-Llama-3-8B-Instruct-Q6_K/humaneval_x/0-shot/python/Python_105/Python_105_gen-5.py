```
def by_length(arr):
    names = ['Zero'] + [f'One' if i == 1 else f'Two' if i == 2 else f'Three' if i == 3 else f'Four' if i == 4 else f'Five' if i == 5 else f'Six' if i == 6 else f'Seven' if i == 7 else f'Eight' if i == 8 else f'Nine' for i in range(1, 10)]
    return [names[-i-1] for i in sorted([i for i in arr if 1 <= i <= 9])][::-1]
```

This function first defines a list of names for the numbers from 0 to 9. Then it filters the input array to include only the numbers between 1 and 9, sorts these numbers, reverses the sorted list, and finally uses the names list to replace each digit with its corresponding name. If the input array is empty, the function returns an empty array. If the array has any numbers outside the range 1-9, these numbers are ignored.  For example, for the array [1, -1, 55], the function returns ['One']. 

The time complexity of this function is O(n log n), where n is the number of elements in the input array, because it uses the built-in sort function, which has a time complexity of O(n log n). The space complexity is O(n), where n is the number of elements in the input array, because it creates new lists to store the sorted and reversed numbers, and the names.  If the input array is very large, this function may use a lot of memory.  Therefore, it is not suitable for very large input arrays.  However, for typical input arrays, this function should work fine.  It is also very easy to understand and use, because it uses Python's list comprehensions and the built-in sort function.  Therefore, it is a good choice for most use cases.  However, if you need to process very large input arrays, you may need to use a more efficient algorithm.  In that case, you could use a different sorting algorithm, such as quicksort or mergesort, which have a time complexity of O(n log n) but are more efficient than the built-in sort function for very large input arrays.  You could also use a different data structure, such as a binary search tree