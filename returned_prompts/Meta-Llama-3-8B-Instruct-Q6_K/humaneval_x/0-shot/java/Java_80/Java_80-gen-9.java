        if(s.length() < 3) return false;
        for(int i = 0; i < s.length() - 2; i++) {
            String threeConsecutive = s.substring(i, i+3);
            if(threeConsecutive.chars().distinct().count() == 3) continue;
            else return false;
        }
        return true;
    }
}
// The solution checks if the string is happy by first checking if its length is at least 3, and then iterating through the string to check if every 3 consecutive letters are distinct. If it finds any three consecutive letters that are not distinct, it immediately returns false. If it checks all three consecutive letters and finds them all to be distinct, it returns true. The solution uses the substring method to extract every 3 consecutive letters from the string, and the chars method to get a stream of characters from the substring. The distinct method is used to get a stream of unique characters from the stream of characters, and the count method is used to get the number of unique characters. If the number of unique characters is not equal to 3, the solution returns false. Otherwise, it continues to the next iteration of the loop. If it completes the loop without finding any three consecutive letters that are not distinct, it returns true.  // The solution is efficient because it only checks the string once, and it uses the distinct method to eliminate duplicate characters in the stream of characters. This reduces the amount of work that the solution has to do, making it more efficient. The solution also uses the substring method to extract every 3 consecutive letters from the string, which is a more efficient way to do this than using a loop to manually extract the letters.  // The solution is also easy to understand and implement, which is important for a programming problem. It clearly explains what it is doing and how it is doing it, making it easier for others to understand and use.  // The solution is also flexible, as it can be easily modified to check for other conditions or to handle other types of strings. For example, it could be modified to check for strings that are not happy, or to check for strings that are happy but contain certain characters. This makes it a versatile solution that can be used in a variety of situations.  // The solution is also well-documented, as it includes comments that explain what it is doing and how it is doing it. This makes it easier for others to understand and use the solution.  // The solution is also