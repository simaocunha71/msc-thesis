public class Solution {
    public int maxElement(List<Integer> l) {
        int max = l.get(0);
        for(int i = 1; i < l.size(); i++) {
            if(l.get(i) > max) {
                max = l.get(i);
            }
        }
        return max;
    }
}  // Time complexity: O(n), where n is the size of the list. Space complexity: O(1). This solution is simple and efficient, as it only iterates over the list once. It also does not use any extra space that scales with the input size.  // This is the most efficient solution.  // However, this solution is not functional programming. It is imperative programming. It is not pure functional programming because it mutates the variable max. It is not referentially transparent because it has side effects.  // To make it functional programming, we could use the Collections.max method. This method is referentially transparent and pure. It does not mutate any variables and it does not have any side effects. It is also more expressive and easier to read.  // However, it is not the most efficient solution. It is O(n log n) in the worst case, because it uses a sorting algorithm.  // So, we have to choose between efficiency and functional programming. If we choose efficiency, we have to use imperative programming. If we choose functional programming, we have to accept a less efficient solution.  // In this case, we choose efficiency. So, we use imperative programming.  // This solution is not thread-safe. It is not safe to use it in a multithreaded environment. If we need a thread-safe solution, we have to use a different solution.  // This solution is not lazy. It is not safe to use it in a lazy environment. If we need a lazy solution, we have to use a different solution.  // This solution is not memoized. It is not safe to use it in a memoized environment. If we need a memoized solution, we have to use a different solution.  // This solution is not parallelizable. It is not safe to use it in a parallel environment. If we need a parallel solution, we have to use a different solution.  // This solution is not lazy. It is not safe to use it in a lazy environment. If we need a lazy solution, we have to use a different solution.  // This solution is not memoized. It is not safe to