    seen := make(map[int]bool)
    result := make([]int, 0)
    for _, num := range numbers {
        if !seen[num] {
            seen[num] = true
            result = append(result, num)
        }
    }
    return result
}  // or return filter(numbers, func(x int) bool { return !seen[x]; }) where filter is a function that filters a slice based on a predicate.  // This function creates a new map for each call, so it's not very efficient for large inputs.  // A more efficient approach is to use a slice of pairs {value, bool} where bool is a flag indicating if the value has been seen.  // We can then iterate over the slice and for each pair, check the bool, and if it's false, add the value to the result and set the bool to true.  // Here is the code for this approach:  // var seen = make([][2]int, 0)  // for _, num := range numbers {  //     found := false  //     for _, pair := range seen {  //         if pair[0] == num {  //             found = true  //             break  //         }  //     }  //     if !found {  //         seen = append(seen, [2]int{num, true})  //         result = append(result, num)  //     }  // }  // return result  // This approach is more efficient because it only needs to iterate over the slice once, and it doesn't create a new map for each call.  // It also uses less memory because it only needs to store the seen values in the slice, rather than the seen keys.  // The time complexity of this approach is O(n), where n is the length of the input slice, and the space complexity is also O(n).  // This is because we need to iterate over the slice once to find the unique elements, and we need to store the unique elements in the result slice.  // The space complexity is O(n) because we need to store the seen values in the slice.  // The time complexity of the original approach is also O(n), where n is the length of the input slice, but the space complexity is O(m), where m is the number of unique elements in the input slice.  // This is because we need to create a new map for each call, and the size of the map is proportional