  for (let i = n - 1; i > 0; i--) {
    if (n % i == 0) {
      return i;
    }
  }
  return 1;
} // or use Math.max(...Array.from({length: n}, (_, i) => n % (i + 1))) if you want to avoid the loop
}  // or return n/ Math.floor(Math.sqrt(n)) for a less accurate but faster solution
} // or return n/ Math.floor(Math.sqrt(n)) for a less accurate but faster solution
} // or return n/ Math.floor(Math.sqrt(n)) for a less accurate but faster solution
} // or return n/ Math.floor(Math.sqrt(n)) for a less accurate but faster solution
} // or return n/ Math.floor(Math.sqrt(n)) for a less accurate but faster solution
} // or return n/ Math.floor(Math.sqrt(n)) for a less accurate but faster solution
} // or return n/ Math.floor(Math.sqrt(n)) for a less accurate but faster solution
} // or return n/ Math.floor(Math.sqrt(n)) for a less accurate but faster solution
} // or return n/ Math.floor(Math.sqrt(n)) for a less accurate but faster solution
} // or return n/ Math.floor(Math.sqrt(n)) for a less accurate but faster solution
} // or return n/ Math.floor(Math.sqrt(n)) for a less accurate but faster solution
} // or return n/ Math.floor(Math.sqrt(n)) for a less accurate but faster solution
} // or return n/ Math.floor(Math.sqrt(n)) for a less accurate but faster solution
} // or return n/ Math.floor(Math.sqrt(n)) for a less accurate but faster solution
} // or return n/ Math.floor(Math.sqrt(n)) for a less accurate but faster solution
} // or return n/ Math.floor(Math.sqrt(n)) for a less accurate but faster solution
} // or return n/ Math.floor(Math.sqrt(n)) for a less accurate but faster solution
} // or return n/ Math.floor(Math.sqrt(n)) for a less accurate but faster solution
} // or return n/ Math.floor(Math.sqrt(n)) for a less accurate but faster solution
} // or return n/ Math.floor(Math.sqrt(n)) for a less accurate but faster solution
} // or return n/ Math.floor(Math.sqrt(n)) for a less accurate but faster solution
} // or return n/ Math.floor(Math.sqrt(n)) for a