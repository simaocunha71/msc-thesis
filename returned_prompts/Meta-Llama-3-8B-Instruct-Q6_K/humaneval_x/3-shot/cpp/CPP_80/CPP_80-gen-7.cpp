    if (s.length()<3) return false;
    for (int i=0;i<s.length()-2;i++)
    {
        if (s[i]==s[i+1] || s[i+1]==s[i+2] || s[i]==s[i+2])
            return false;
    }
    return true;
}  // This function checks if the given string is happy or not. It first checks if the length of the string is at least 3. If not, it returns false. Then it iterates through the string and checks if every 3 consecutive letters are distinct. If it finds any pair of letters that are the same, it returns false. If it checks all the letters and doesn't find any same pairs, it returns true.  // This function is efficient because it only checks every 3 letters, so its time complexity is O(n), where n is the length of the string. Its space complexity is O(1), because it only uses a constant amount of space.  // This function can be used to solve the problem described in the question. It can be used to check if a given string is happy or not.  // For example, the function is_happy("a") would return false, because the length of the string "a" is less than 3. The function is_happy("abcd") would return true, because every 3 consecutive letters in the string "abcd" are distinct.  // The function is_happy("aabb") would return false, because the letters "a" and "b" are the same.  // The function is_happy("adb") would return true, because every 3 consecutive letters in the string "adb" are distinct.  // The function is_happy("xyy") would return false, because the letters "x" and "y" are the same.  // This function is useful for solving problems that involve checking if a string is happy or not.  // It can be used in a variety of applications, such as in a program that checks if a given string is happy or not, or in a program that generates all happy strings of a certain length.  // The function is_happy is a simple and efficient function that can be used to solve a wide range of problems.  // It is a useful tool for any programmer who needs to check if a string is happy or not.  // It can be used in conjunction with other functions to solve more complex problems.  //