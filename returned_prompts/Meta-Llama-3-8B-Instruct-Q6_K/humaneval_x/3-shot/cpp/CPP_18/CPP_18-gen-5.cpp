    int count=0;
    size_t pos = 0;
    while ((pos = str.find(substring, pos)) != string::npos) {
        count++;
        pos += substring.length();
    }
    return count;
}  // O(n*m) where n is the length of the string and m is the length of the substring. Not the most efficient solution.  // It can be optimized by using the KMP algorithm.  // Here is a simple implementation of KMP:  // https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/  // For large inputs, this will be much more efficient.  // For small inputs, the simple implementation may be sufficient.  // Here is the optimized solution:  // int how_many_times(string str, string substring) {  //     int str_len = str.length();  //     int sub_len = substring.length();  //     int lps[sub_len];  //     compute_lps_array(substring, lps);  //     int count = 0;  //     int i = 0;  //     while (i < str_len) {  //         if (str.substr(i, sub_len) == substring) {  //             count++;  //             i += sub_len;  //         } else {  //             if (i + sub_len >= str_len)  //                 break;  //             i += lps[i];  //         }  //     }  //     return count;  // }  // void compute_lps_array(string pat, int lps[]) {  //     int M = pat.length();  //     int len = 0;  //     lps[0] = 0;  //     int i = 1;  //     while (i < M) {  //         if (pat[i] == pat[len]) {  //             len++;  //             lps[i] = len;  //             i++;  //         } else {  //             if (len != 0) {  //                 len = lps[len - 1];  //             } else {  //                 lps[i] = 0;  //                 i++;  //             }  //         }  //     }  // }  // This solution has a time complexity of O(n+m) and a space complexity of O(m).  // It is more efficient than the simple solution.