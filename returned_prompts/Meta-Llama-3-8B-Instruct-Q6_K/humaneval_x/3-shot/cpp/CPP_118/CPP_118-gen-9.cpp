    int i;
    for (i=word.length()-1; i>=0; i--)
    {
        char chr=word[i];
        if (chr=='a' || chr=='e' || chr=='i' || chr=='o' || chr=='u' || chr=='A' || chr=='E' || chr=='I' || chr=='O' || chr=='U')
        {
            if (i>0 && (word[i-1] >= 'a' && word[i-1] <= 'z') || (word[i-1] >= 'A' && word[i-1] <= 'Z'))
            {
                return string(1, chr);
            }
        }
    }
    return "";
}  // Not working properly... It's not returning the closest vowel. It's returning the last vowel... 
}  // The problem is that it's not checking if the vowel is between two consonants. It's just checking if the vowel is after a consonant. It should also check if the vowel is after another vowel. If not, it should move to the next vowel... 
}  // We need to use a different approach... We need to iterate over the word from right to left and keep track of the last vowel we have seen. If we see a consonant after the last vowel, we have found the closest vowel... 
}  // We also need to handle the case when the word starts with a vowel... 
}  // We need to iterate over the word from left to right until we find a consonant, then we can start our search for the closest vowel from right to left... 
}  // Here is the correct solution... 
}  // We use two pointers, one from the left and one from the right. The left pointer moves until it finds a consonant, then the right pointer moves until it finds a vowel. If the right pointer finds another vowel, it moves to the next one. When the right pointer finds a consonant, it means we have found the closest vowel... 
}  // Here is the correct solution... 
}  // We use two pointers, one from the left and one from the right. The left pointer moves until it finds a consonant, then the right pointer moves until it finds a vowel. If the right pointer finds another vowel, it moves to the next one. When the right pointer finds a consonant, it means we have found the closest vowel... 
}  // Here is the