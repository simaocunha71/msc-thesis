```
def nth_nums(nums, n):
    return [num**n for num in nums]
```


This function uses a list comprehension to iterate over the input list `nums` and raise each number to the power `n`. The result is a new list containing the `n`-th powers of each number in the original list. The unit test `assert nth_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],2)==[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]` verifies that the function works correctly.  For example, the 2nd power of each number in the list is `[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]`.  The function can be extended to work with any power by replacing `**n` with `**n` in the list comprehension.  For example, to compute the cube of each number, the function would be `nth_nums(nums, 3)`.  The function can also be used with a variable `n` that is defined elsewhere in the program.  For example, `n = 3` and then `result = nth_nums(nums, n)` would compute the cube of each number in the list.  This is a simple and flexible way to compute the `n`-th power of each number in a list.  It is also efficient because it uses a list comprehension, which is a built-in Python feature that is implemented in C and is therefore very fast.  The function does not modify the original list, so it is safe to use with any list.  It also works with lists of any length, not just lists of integers.  It can be used with lists of floats, strings, or any other type of object that supports the `**` operator.  It is a general-purpose function that can be used in many different contexts.  It is also easy to understand and use, because it is a simple and straightforward function that does one thing well.  It is a good example of a well-designed and well-implemented function in Python.  It is also a good example of how to use list comprehensions and the `**` operator to solve a common problem in a simple and efficient way.  It is a good example of how