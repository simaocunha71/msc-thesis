```
def unique_Element(lst):
    return len(set(lst)) == 1
```
This function uses the built-in Python set data structure to remove duplicates from the list. It then compares the length of the set (which is the number of unique elements) to 1, returning True if they are equal (i.e., there is only one distinct element) and False otherwise.

The unit test `assert unique_Element([1,1,1]) == True` ensures that the function works correctly for a list with all identical elements.  The function should return True in this case, because there is only one distinct element.  If the function were to return False in this case, it would indicate that it is not correctly identifying lists with only one distinct element.  The unit test helps to ensure that the function behaves correctly in this edge case.  It also serves as a way to verify that the function is working correctly in general, by testing it with a variety of different inputs.  If the function is correct, it should return True for all lists that contain only one distinct element, and False for all other lists.  The unit test helps to ensure that the function behaves correctly in this way.  The function is also tested for edge cases, like an empty list or a list with all distinct elements.  The unit test will fail if the function does not behave correctly in these cases, indicating that there is a bug in the function.  This helps to ensure that the function is robust and behaves correctly in all situations.  Overall, the unit test helps to ensure that the function is correct and behaves as expected.  It provides a way to verify that the function is working correctly, and helps to catch any bugs that might be present in the function.  This is especially important for complex functions that are difficult to test manually, or for functions that are used in a variety of different contexts.  In these cases, the unit test provides a way to ensure that the function is working correctly, without having to manually test it in all possible scenarios.  This helps to save time and effort, and ensures that the function is reliable and correct.  It also helps to ensure that the function is maintainable, by providing a way to test it in the future.  If the function needs to be modified in some way, the unit test can be used to verify that the modification did not introduce any bugs.  This helps to ensure that the function remains correct and reliable, even as it is modified over time.  Overall,