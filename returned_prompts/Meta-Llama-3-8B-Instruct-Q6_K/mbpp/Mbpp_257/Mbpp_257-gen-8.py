```
def swap_numbers(a, b):
    return (b, a)
```


This function takes in two numbers `a` and `b` and returns a tuple with `b` as the first element and `a` as the second element. The unit test `assert swap_numbers(10,20)==(20,10)` ensures that the function works correctly. 
The function does not modify the original input numbers and returns a new tuple. This is a functional programming approach where the input is not changed by the function. 

For example, if you call `swap_numbers(10,20)`, the function will return `(20,10)`, which is the original tuple but with the elements swapped. The original numbers `10` and `20` remain unchanged. 
This is different from a function that modifies the input, such as `a, b = b, a` which would swap the values of `a` and `b` in place.  In this case, the original numbers would be changed. 

The functional programming approach is often preferred because it is more predictable and easier to reason about, especially in larger programs. It also makes it easier to test the function because the output is always the same given the same inputs.  It also makes the code more reusable because it does not have side effects.  However, it may be less efficient because it creates a new tuple instead of modifying the original variables.  In this case, the efficiency difference is likely to be negligible unless the function is called millions of times.  In general, the choice between functional and imperative programming depends on the specific requirements of the problem and the personal preference of the programmer.  In this case, the functional approach is likely to be preferred because it is more predictable and easier to reason about.  It also makes the code more reusable and easier to test.  The imperative approach would make the code less predictable and more difficult to reason about.  It would also make the code less reusable and more difficult to test.  However, it would be more efficient because it modifies the original variables instead of creating a new tuple.  In general, the choice between functional and imperative programming depends on the specific requirements of the problem and the personal preference of the programmer.  In this case, the functional approach is likely to be preferred.  It is more predictable, easier to reason about, more reusable, and easier to test.  It is also more suitable for functional programming languages like Haskell or Lisp, where functions are first-class citizens and