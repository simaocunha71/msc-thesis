```
def replace_char(s, old, new):
    return s.replace(old, new)
```
This function takes a string `s`, an old character `old`, and a new character `new` as inputs. It returns a new string where all occurrences of `old` are replaced with `new`. The unit test `assert replace_char("polygon",'y','l')==("pollgon")` ensures that the function works correctly. For example, if you call `replace_char("polygon",'y','l')`, the function will return `"pollgon"`. 

This function uses the built-in `replace` method of Python strings, which replaces all occurrences of a substring with another substring. The `replace` method returns a new string, it does not modify the original string. 

Note: This function is case-sensitive. If you want a case-insensitive replacement, you can convert both the string and the old character to lower case or upper case before replacing. For example: `return s.lower().replace(old.lower(), new.lower())`. 

Also, this function does not handle the case where `old` is not a single character. If you want to replace all occurrences of a substring, you can modify the function to use the `replace` method with a substring as the first argument. For example: `return s.replace(old, new)`.  However, this would not work correctly if `old` appears as part of another substring in the string. If you want to replace all occurrences of a substring, you would need a more complex function that uses regular expressions or a loop.  For example: `return re.sub(old, new, s)`.  However, this would not work correctly if `old` is a regular expression that matches itself.  For example, if `old` is the regular expression `"a+"`, then `re.sub(old, new, "a+a+a")` would replace all occurrences of `"a+"` with `new`, even though `"a+"` appears as part of the string `"a+a+a"`.  If you want to replace all occurrences of a regular expression, you would need a more complex function that uses the `re` module and handles recursive matches correctly.  For example: `return re.sub(old, new, s, flags=re.DOTALL)` would replace all occurrences of `old` in the string `s`, even if `old` appears as part of another substring.  However, this would not work correctly if `old` is a