def extract_singly(lst):
    return set([i for sublist in lst for i in sublist])  # set comprehension to flatten the list into a set
    # or
    # return set(itertools.chain(*[sublist for sublist in lst]))
    # import itertools; 
    # itertools.chain is a function that makes an iterator that returns elements from the first iterable until it is exhausted, then proceeds to the next iterable, until all of the iterables are exhausted. 
    # This is useful for flattening lists of lists.  The * operator is used to unpack the list into separate arguments to the function.  So, *[sublist for sublist in lst] is equivalent to [sublist for sublist in lst][0], [sublist for sublist in lst][1], ..., [sublist for sublist in lst][n].  Where n is the number of sublists in lst. 
    # So, itertools.chain(*[sublist for sublist in lst]) is equivalent to itertools.chain([sublist[0] for sublist in lst], [sublist[1] for sublist in lst], ..., [sublist[n] for sublist in lst]).  Which is equivalent to itertools.chain([sublist[0] for sublist in lst], [sublist[1] for sublist in lst], ..., [sublist[n] for sublist in lst], [sublist[n+1] for sublist in lst]).  Where n is the number of sublists in lst - 1.  This will flatten the list of lists into a single iterator.  Then, set() is used to convert this iterator into a set.  So, set(itertools.chain(*[sublist for sublist in lst])) is equivalent to set(sublist[0] for sublist in lst) union set(sublist[1] for sublist in lst) union ... union set(sublist[n] for sublist in lst).  Where n is the number of sublists in lst.  This is equivalent to set([sublist[0] for sublist in lst] + [sublist[1] for sublist in lst] + ... + [sublist[n] for sublist in lst]).  Which is the set of all the elements in the list of lists.  So, set(itertools.chain(*[sublist for sublist in lst])) is equivalent to set([i for sublist in lst for i in sublist]), which is the same as the set comprehension used in the first line of this solution. 
    # So, both