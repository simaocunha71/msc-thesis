```
def count_Occurrence(tup, lst):
    return sum(tup.count(i) for i in lst)
```
This function uses the built-in count method of the list to count the occurrence of each element in the tuple. The sum function is then used to add up the counts of all elements in the list. The function takes two parameters: a tuple and a list. The list contains the elements to be counted in the tuple. The function returns the total count of all elements in the list. The unit test `assert count_Occurrence(('a', 'a', 'c', 'b', 'd'),['a', 'b'] ) == 3` ensures that the function works correctly.  If the list is not a subset of the tuple, the function will raise a ValueError when it tries to count the occurrence of an element that is not in the tuple. The function can be modified to handle this situation by checking if the element is in the tuple before trying to count its occurrence.  Here is a modified version of the function:

```
def count_Occurrence(tup, lst):
    return sum(tup.count(i) for i in lst if i in tup)
```
This modified function will return 0 for any elements in the list that are not in the tuple, instead of raising a ValueError.  It is more robust and will handle any lists and tuples, not just those that are guaranteed to work correctly.  It also follows the principle of "fail early, fail loudly", by checking if the element is in the tuple before trying to count its occurrence.  This makes the function more reliable and easier to debug.  It also follows the principle of "do the simplest thing that could possibly work", by using the built-in count method and the sum function, rather than trying to implement the counting and summing logic itself.  This makes the function more readable and maintainable.  It also follows the principle of "separation of concerns", by separating the logic of counting the occurrence of each element from the logic of summing up the counts.  This makes the function more modular and reusable.  It also follows the principle of "avoid side effects", by not modifying the tuple or the list, and by not using any global variables.  This makes the function more predictable and easier to test.  It also follows the principle of "avoid complex logic", by using the built-in count method and the sum function, rather than trying to implement the counting and summing logic itself