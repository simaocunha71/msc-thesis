def check_Consecutive(lst):
    return all(lst[i] + 1 == lst[i+1] for i in range(len(lst) - 1))  # or return all(lst[i] == lst[i-1] + 1 for i in range(1, len(lst)))  # Both works for ascending order lists. For descending order, second one will work. For other than ascending/descending order, neither will work. You'll need to adjust the function for your specific use case.  # You can also use set() function to check if the list is consecutive, return set(lst) == set(range(min(lst), max(lst)+1))  # This will work for any order of numbers, but it will not work for lists with duplicate numbers.  # You can also use itertools module, return list(itertools.run_length_pump(lst)) == lst  # This will work for any order of numbers, and it will also work for lists with duplicate numbers.  # But these will not work for lists with non-integer numbers.  # For non-integer numbers, you'll need to adjust the function to check the difference between consecutive numbers.  # For example, for floating point numbers, you can use the following function:  # return all(abs(lst[i] - lst[i+1]) < 1e-9 for i in range(len(lst) - 1))  # This will work for floating point numbers, but it will not work for lists with non-numeric values.  # You can also use numpy module, return np.allclose(lst, np.arange(lst[0], lst[-1]+1))  # This will work for any order of numbers, and it will also work for lists with non-integer numbers.  # But this will not work for lists with non-numeric values.  # For non-numeric values, you'll need to adjust the function to check the type of the values.  # For example, you can use the following function:  # return all(isinstance(x, (int, float)) for x in lst)  # This will work for lists with non-numeric values, but it will not work for lists with non-integer numbers.  # You can also use pandas module, return pd.Series(lst).diff().dropna().abs().max() < 1  # This will work for any order of numbers, and it will also work for lists with non-integer numbers.  # But this will not work for lists