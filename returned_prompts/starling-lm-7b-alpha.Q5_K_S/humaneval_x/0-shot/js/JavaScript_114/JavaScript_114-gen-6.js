/*
We can solve this problem by using Kadane's algorithm, which is a technique to find the maximum sum subarray of an array.
We can change the sign of all the elements of the array and find the minimum sum subarray, then return the negation of the minimum sum as the minimum sum subarray of the original array.
We can also add a prefix sum to the array to get the sum of the subarray for each index i.
We can then return the minimum of the prefix sums as the minimum sum of the subarray.

Here's a step by step guide:

1. Add a prefix sum to the original array.
2. Return the minimum of the prefix sums as the minimum sum of the subarray.
3. The time complexity of this algorithm is O(n), where n is the length of the array.
4. The space complexity of this algorithm is O(1), which means that the space complexity does not increase as the input size increases.

Here's a step by step guide:

1. Add a prefix sum to the original array.
2. Return the minimum of the prefix sums as the minimum sum of the subarray.
3. The time complexity of this algorithm is O(n), where n is the length of the array.
4. The space complexity of this algorithm is O(1), which means that the space complexity does not increase as the input size increases.

Here's a step by step guide:

1. Add a prefix sum to the original array.
2. Return the minimum of the prefix sums as the minimum sum of the subarray.
3. The time complexity of this algorithm is O(n), where n is the length of the array.
4. The space complexity of this algorithm is O(1), which means that the space complexity does not increase as the input size increases.

Here's a step by step guide:

1. Add a prefix sum to the original array.
2. Return the minimum of the prefix sums as the minimum sum of the subarray.
3. The time complexity of this algorithm is O(n), where n is the length of the array.
4. The space complexity of this algorithm is O(1), which means that the space complexity does not increase as the input size increases.

Here's a step by step guide: