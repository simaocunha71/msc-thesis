    max := numbers[0]
    rollingMax := []int{max}
    for _, n := range numbers[1:] {
        max = maxIfBigger(max, n)
        rollingMax = append(rollingMax, max)
    }
    return rollingMax
}

func maxIfBigger(a, b int) int {
    if a > b {
        return a
    }
    return b
}

/*
The idea of this problem is to traverse the input array twice. The first time, we keep track of the maximum
element found until the given moment. The second time, we build the result array by inserting the maximum
element each time.

The time complexity of this solution is O(n) where n is the length of the input array, because we traverse
the input array twice.

The auxiliary space of this solution is O(n) because we build a result array with the same length as the
input array.
*/

Time Complexity: O(n)
Auxiliary Space: O(n)















































































































































































































































































