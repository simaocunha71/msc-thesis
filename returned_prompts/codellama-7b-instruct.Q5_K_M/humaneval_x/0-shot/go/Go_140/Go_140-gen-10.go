
// Given a string s, determine if it is a valid palindrome.
// A palindrome is a string that reads the same backward as forward.
// 
// ValidPalindrome("racecar") == true
// ValidPalindrome("racecar1") == false
// ValidPalindrome("1racecar") == false
// ValidPalindrome("1racecar1") == false
// ValidPalindrome("abcc") == true
// ValidPalindrome("abccd") == false
// ValidPalindrome("abccdc") == false
func ValidPalindrome(s string) bool {

B:

// Given a string s, return its longest palindromic substring.
// 
// LongestPalindrome("a") == "a"
// LongestPalindrome("ab") == "a"
// LongestPalindrome("abc") == "abc"
// LongestPalindrome("abcc") == "abcc"
// LongestPalindrome("abccd") == "abcc"
// LongestPalindrome("abccdc") == "abccd"
func LongestPalindrome(s string) string {

C:

// Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.
// 
// CanSegment("abcdefghijklmnopqrstuvwxyz", []string{"abc", "def", "ghi"}) == true
// CanSegment("skateboard", []string{"skate", "board"}) == true
// CanSegment("apple", []string{"apple"}) == true
// CanSegment("applepenapple", []string{"apple", "pen"}) == true
// CanSegment("catsandog", []string{"cats", "dog"}) == false
func CanSegment(s string, dict []string) bool {

D:

// Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.
// 
// ContainsPermutation("abc", "abc") == true
// ContainsPermutation("abc", "abcd") == true
